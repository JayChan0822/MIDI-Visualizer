<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Visualizer</title>

    <link rel="preconnect" href="https://fonts.loli.net">
    <link rel="preconnect" href="https://gstatic.loli.net" crossorigin>
    <link href="https://fonts.loli.net/css2?family=Chango&display=swap" rel="stylesheet">


    <style>
        :root {
            /* --- æ ¸å¿ƒè‰²æ¿ï¼šDeep Midnight Glass (å‡çº§ç‰ˆ) --- */
            --bg-color: #050507; /* æ›´æ·±é‚ƒçš„åˆå¤œé»‘ï¼Œæ¯”åŸæ¥çš„ #0b0c15 æ›´çº¯å‡€ */

            /* ç»ç’ƒæ€ç³»ç»Ÿï¼šæ›´è–„ã€æ›´æ¸…é€ */
            --glass-panel: rgba(20, 20, 23, 0.75); /* é¢æ¿é¢œè‰²å¾®è°ƒ */
            --glass-header: rgba(11, 12, 18, 0.7); /* å¤´éƒ¨æ›´é€ */
            --glass-border: rgba(255, 255, 255, 0.08); /* è¾¹æ¡†å˜å¾—æç»†ã€ç²¾è‡´ */
            --glass-highlight: rgba(255, 255, 255, 0.05); /* è¡¨é¢åå…‰ */

            /* æ–‡æœ¬ç³»ç»Ÿ */
            --text-main: #ffffff;
            --text-muted: #98989d; /* ç¨å¾®åå†·ç°ï¼Œæ›´ç°ä»£ */

            /* Accentsï¼šéœ“è™¹è‰²ç³»ï¼Œé«˜é¥±å’Œåº¦ */
            --accent-blue: #2E9AFF;  /* æ›´äº®çš„ç§‘æŠ€è“ */
            --accent-green: #30d158;
            --accent-red: #ff453a;
            --accent-orange: #ff9f0a;
            --accent-yellow: #ffd60a;
            --accent-pink: #bf5af2;
            --accent-gradient: linear-gradient(135deg, #2E9AFF 0%, #bf5af2 100%); /* æ–°å¢ï¼šä¸»å“ç‰Œæ¸å˜ */

            --radius-lg: 16px;
            --radius-sm: 8px;
            --blur-amt: 40px; /* æ¨¡ç³Šåº¦åŠ å€ï¼Œç£¨ç ‚æ„Ÿæ›´é«˜çº§ */

            --timeline-height: 40vh;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            /* æ ¸å¿ƒä¿®æ”¹ï¼šæ·»åŠ é¡¶éƒ¨ç¯å¢ƒå…‰æ•ˆï¼Œåˆ¶é€ ç©ºé—´çºµæ·±æ„Ÿ */
            background-image: radial-gradient(circle at 50% -20%, #1c2540 0%, #050507 50%);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Inter", Roboto, sans-serif; /* å­—ä½“å¾®è°ƒ */
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-size: 13px;
            letter-spacing: -0.015em;
            -webkit-font-smoothing: antialiased; /* è®©å­—ä½“åœ¨æ·±è‰²èƒŒæ™¯ä¸‹æ›´æ¸…æ™° */
        }

        /* --- é€šç”¨æ»šåŠ¨æ¡ç¾åŒ– (éšå½¢æ¨¡å¼) --- */
        ::-webkit-scrollbar { width: 8px; height: 8px; background: transparent; }
        ::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            border: 2px solid transparent;
            background-clip: content-box;
        }
        ::-webkit-scrollbar-thumb:hover { background-color: rgba(255,255,255,0.25); }
        ::-webkit-scrollbar-corner { background: transparent; }

        /* --- é¡¶éƒ¨ DAW å®¹å™¨ --- */
        #daw-container {
            height: var(--timeline-height);
            display: flex;
            flex-direction: column;
            /* ä¿®æ”¹ï¼šç§»é™¤æ­»æ¿çš„å¾„å‘æ¸å˜ï¼Œä½¿ç”¨é€æ˜èƒŒæ™¯è®© Body çš„ç¯å¢ƒå…‰é€å‡ºæ¥ */
            background: transparent;
            border-bottom: 1px solid var(--glass-border);
            position: relative;
            z-index: 20;
        }

        /* --- å·¥å…·æ  (Toolbar) --- */
        #toolbar {
            height: 54px;
            display: flex;
            align-items: center;
            padding: 0 16px;
            background: var(--glass-header);
            backdrop-filter: blur(var(--blur-amt));
            -webkit-backdrop-filter: blur(var(--blur-amt));
            border-bottom: 1px solid var(--glass-border);
            /* æ–°å¢ï¼šé¡¶éƒ¨å¾®å¼±çš„é«˜å…‰çº¿ï¼Œæ¨¡æ‹Ÿç»ç’ƒè¾¹ç¼˜çš„åå…‰ï¼Œå¢åŠ ç«‹ä½“æ„Ÿ */
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
            gap: 12px;
            user-select: none;
        }

        /* --- æŒ‰é’®æ ·å¼é‡æ„ (Deep Midnight Glass / Bento Style) --- */
        .btn {
            /* åŸºç¡€ç»ç’ƒæ€ï¼šæ›´æ·±é‚ƒã€æ›´é€šé€çš„æè´¨ */
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-muted); /* é»˜è®¤æ–‡å­—ç°è‰²ï¼Œæ›´æ˜¾é«˜çº§ï¼ŒHoveræ—¶å˜ç™½ */
            padding: 0 14px; /* ä½¿ç”¨ Flex å‚ç›´å±…ä¸­ï¼Œpadding æ”¹ä¸ºå·¦å³ */
            border-radius: 8px; /* ä¿æŒåœ†è§’ */
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            /* æ›´åŠ ç»†è…»çš„è´å¡å°”æ›²çº¿è¿‡æ¸¡ */
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);

            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            height: 32px;

            /* æ ¸å¿ƒè´¨æ„Ÿï¼šé¡¶éƒ¨å¾®å¼±çš„é«˜å…‰å†…é˜´å½±ï¼Œåˆ¶é€ åšåº¦æ„Ÿ */
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);

            /* ğŸ”¥ ä¿æŒä¿®å¤é€»è¾‘ ğŸ”¥ */
            white-space: nowrap;
            flex-shrink: 0;
        }

        /* æ‚¬åœæ•ˆæœï¼šæè´¨å˜äº®ï¼Œæ–‡å­—å˜ç™½ */
        .btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.25);
            color: #fff; /* æ–‡å­—é«˜äº® */
            transform: translateY(-1px);
            box-shadow:
                    inset 0 1px 0 rgba(255, 255, 255, 0.1),
                    0 4px 12px rgba(0, 0, 0, 0.4); /* é˜´å½±æ›´æ·±ï¼Œå¢åŠ æ‚¬æµ®æ„Ÿ */
        }

        .btn:active {
            transform: translateY(0);
            background: rgba(255, 255, 255, 0.08);
            opacity: 0.9;
            box-shadow: none;
        }

        /* --- åŠŸèƒ½è‰²å˜ä½“ --- */

        /* 1. å¼ºè°ƒæ“ä½œ (ä¿å­˜/è¯»å–) - å¹½çµè“ (Electric Blue Ghost) */
        .btn-blue {
            background: rgba(46, 154, 255, 0.1); /* ä½¿ç”¨æ–°çš„äº®è“åº•è‰² */
            border-color: rgba(46, 154, 255, 0.25);
            color: #5CADFF; /* äº®è“è‰²æ–‡å­— */
        }
        .btn-blue:hover {
            background: rgba(46, 154, 255, 0.25);
            border-color: rgba(46, 154, 255, 0.5);
            color: #fff;
            box-shadow: 0 0 15px rgba(46, 154, 255, 0.3);
        }

        /* 2. æ ¸å¿ƒé«˜äº® (å¯¼å‡ºè§†é¢‘) - å“ç‰Œæ¸å˜ (Brand Gradient) */
        .btn-primary {
            /* ä½¿ç”¨ä¹‹å‰å®šä¹‰çš„è“ç´«æ¸å˜ */
            background: linear-gradient(135deg, #2E9AFF 0%, #bf5af2 100%) !important;
            color: #fff !important;
            border: 1px solid rgba(255,255,255,0.1) !important; /* å¢åŠ å¾®å¼±æè¾¹ */
            font-weight: 600;
            /* æ‰©æ•£å…‰å½± */
            box-shadow: 0 4px 15px rgba(46, 154, 255, 0.3);
        }
        .btn-primary:hover {
            box-shadow: 0 6px 20px rgba(191, 90, 242, 0.5); /* ç´«è‰²å…‰æ™• */
            transform: scale(1.02) translateY(-1px);
            filter: brightness(1.1);
        }

        /* 3. å±é™©æ“ä½œ (Stop/æ¸…é™¤) - å¹½çµçº¢ */
        .btn-red {
            background: rgba(255, 69, 58, 0.1);
            border-color: rgba(255, 69, 58, 0.25);
            color: #ff6b6b;
        }
        .btn-red:hover {
            background: rgba(255, 69, 58, 0.8); /* æ‚¬åœå˜ä¸ºå®è‰² */
            color: white;
            border-color: transparent;
            box-shadow: 0 0 15px rgba(255, 69, 58, 0.4);
        }

        /* 4. åˆ›æ„æ“ä½œ (è´´å›¾) - å¹½çµç´« */
        .btn-accent {
            background: rgba(191, 90, 242, 0.1);
            border-color: rgba(191, 90, 242, 0.25);
            color: #e0aaff;
        }
        .btn-accent:hover {
            background: rgba(191, 90, 242, 0.25);
            border-color: #e0aaff;
            color: white;
            box-shadow: 0 0 15px rgba(191, 90, 242, 0.3);
        }

        /* --- åˆ†éš”çº¿ç¾åŒ– (Subtle Divider) --- */
        .toolbar-separator {
            width: 1px;
            height: 20px; /* ç¨å¾®ç¼©çŸ­ï¼Œæ›´ç²¾è‡´ */
            /* ä½¿ç”¨è¾¹æ¡†å˜é‡ï¼Œä¿æŒç»Ÿä¸€ï¼Œæ”¹ä¸ºä¸Šä¸‹æ¸éš */
            background: linear-gradient(to bottom, transparent, rgba(255, 255, 255, 0.15), transparent);
            margin: 0 10px;
            opacity: 0.6;
        }

        /* --- æ ‡å°ºåŒºåŸŸ (Precision Ruler) --- */
        #ruler-container {
            display: flex;
            height: 32px;
            /* èƒŒæ™¯è‰²è°ƒæ•´ä¸ºæ·±è‰²åŠé€æ˜ï¼Œé€å‡ºä¸€ç‚¹ç¯å¢ƒå…‰ï¼Œä½†ä¿è¯åˆ»åº¦æ¸…æ™° */
            background: rgba(11, 12, 18, 0.6);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);

            border-bottom: 1px solid var(--glass-border);
            flex-shrink: 0;
            z-index: 30;

            /* åº•éƒ¨å¾®å¼±æŠ•å½±ï¼Œè®©æ ‡å°ºçœ‹èµ·æ¥å‹åœ¨è½¨é“ä¹‹ä¸Š */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        /* ä¿®æ”¹ï¼šè®©æ ‡å°ºå·¦ä¾§å«ç‰‡å˜æˆ Flex å®¹å™¨ï¼Œç”¨äºæ”¾ç½®æŒ‰é’® */
        #ruler-header-spacer {
            width: 250px;
            background: rgba(11, 12, 18, 0.8); /*ç¨å¾®åŠ æ·±èƒŒæ™¯*/
            border-right: 1px solid var(--glass-border);
            flex-shrink: 0;

            /* ğŸ”¥ æ–°å¢å¸ƒå±€å±æ€§ */
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 8px;
            box-sizing: border-box;
            z-index: 35; /* ç¡®ä¿åœ¨æœ€ä¸Šå±‚ï¼Œæ–¹ä¾¿ç‚¹å‡» */
        }

        /* æ–°å¢ï¼šæ–°å»ºè½¨é“æŒ‰é’®çš„æ ·å¼ (åµŒå…¥å¼é£æ ¼) */
        #addTrackBtn {
            width: 100%;
            height: 20px; /* æ‰å¹³ä¸€ç‚¹ï¼Œé€‚åº”æ ‡å°ºé«˜åº¦ */

            background: rgba(255, 255, 255, 0.05);
            border: 1px dashed rgba(255, 255, 255, 0.2);
            border-radius: 4px;

            color: #888;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;

            display: flex;
            align-items: center;
            justify-content: center;
        }

        #addTrackBtn:hover {
            background: rgba(46, 154, 255, 0.15);
            border-color: var(--accent-blue);
            color: var(--accent-blue);
            box-shadow: 0 0 8px rgba(46, 154, 255, 0.2);
        }

        #ruler-content {
            flex: 1;
            overflow: hidden;
            position: relative;
            background: transparent;
        }

        #bar-ruler, #time-ruler {
            height: 16px;
            position: relative;
            font-size: 10px; /* å­—ä½“å¾®è°ƒå¤§ 1pxï¼Œæ›´æ˜“è¯» */
            font-family: "SF Mono", "Menlo", "Consolas", monospace; /* å¼ºè°ƒç­‰å®½å­—ä½“ */
            color: var(--text-muted);
            pointer-events: none;
            letter-spacing: -0.5px;
        }

        /* ä¸¤ä¸ªæ ‡å°ºä¹‹é—´çš„åˆ†å‰²çº¿ */
        #bar-ruler {
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            color: #888;
        }

        /* --- åˆ»åº¦çº¿ç¾åŒ– --- */
        .ruler-mark {
            position: absolute; top: 0; bottom: 0;
            /* é»˜è®¤å°åˆ»åº¦ï¼šæç»†ã€ä½è°ƒ */
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            padding-left: 4px;
            line-height: 16px;
            transition: color 0.2s;
        }

        /* ä¸»åˆ»åº¦ (Major)ï¼šé«˜äº®æ˜¾ç¤ºï¼Œæ¨¡æ‹Ÿè§å…‰ä»ªè¡¨ç›˜ */
        .ruler-mark.major {
            border-left-color: rgba(255, 255, 255, 0.3); /* çº¿æ¡æ›´äº® */
            font-weight: 600;
            color: var(--accent-blue); /* ğŸ”¥ æ•°å­—å˜æˆç§‘æŠ€è“ï¼Œæå‡å¯è¯»æ€§ */
            text-shadow: 0 0 10px rgba(46, 154, 255, 0.3); /* å¾®å¼±çš„æ–‡å­—å‘å…‰ */
        }

        /* --- è½¨é“åŒºåŸŸæ•´ä½“å®¹å™¨ --- */
        #tracks-area {
            flex: 1;
            overflow: hidden;
            position: relative;
            display: flex;
            /* å¾®å¾®å‹æš—èƒŒæ™¯ï¼Œè®©è½¨é“å†…å®¹æ›´çªå‡º */
            background: rgba(0, 0, 0, 0.2);
            box-shadow: inset 0 4px 20px rgba(0,0,0,0.5); /* å†…éƒ¨é˜´å½±ï¼Œå¢åŠ æ·±é‚ƒæ„Ÿ */
        }

        /* --- å·¦ä¾§è½¨é“å¤´ (Track Headers / Rack) --- */
        #track-headers {
            width: 250px;

            /* ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šæ·»åŠ è¿™è¡Œï¼Œç¡®ä¿åŒ…å«è¾¹æ¡†åœ¨å†…æ€»å®½ä¸º 250pxï¼Œä¸ä¸Šæ–¹æ ‡å°ºå¯¹é½ */
            box-sizing: border-box;

            /* ä½¿ç”¨æ·±è‰²ç»ç’ƒé¢æ¿ï¼Œç¨³é‡ */
            background: rgba(11, 12, 18, 0.75);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);

            border-right: 1px solid var(--glass-border);
            flex-shrink: 0;
            z-index: 5;
            overflow: hidden;

            /* å¢åŠ å³ä¾§é˜´å½±ï¼Œè®©å®ƒçœ‹èµ·æ¥æµ®åœ¨æ—¶é—´è½´ä¸Šé¢ */
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.3);
        }

        /* --- å·¦ä¾§è½¨é“å¤´ (Track Headers / Rack) --- */
        .track-header {
            height: 64px;
            /* ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šé”å®šç›’æ¨¡å‹ï¼Œç¡®ä¿æ€»é«˜åº¦ä¸éšè¾¹æ¡†å¢åŠ  */
            box-sizing: border-box;

            /* æ¯ä¸€ä¸ªè½¨é“å¤´éƒ½æœ‰ç‹¬ç«‹çš„é¡¶éƒ¨å¾®å…‰ */
            border-bottom: 1px solid var(--glass-border);
            border-top: 1px solid rgba(255, 255, 255, 0.02);

            padding: 0 16px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            background: transparent;
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
        }

        /* é¼ æ ‡æ‚¬åœæ—¶çš„å¾®äº¤äº’ */
        .track-header:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        /* --- é€‰ä¸­çŠ¶æ€ï¼šèµ›åšæœ‹å…‹é£æ ¼é«˜äº® --- */
        .track-header.selected {
            /* èƒŒæ™¯å¸¦æœ‰å¾®å¼±çš„è“è‰²è°ƒ */
            background: rgba(46, 154, 255, 0.08) !important;
            border-bottom-color: rgba(46, 154, 255, 0.1);
            /* ç§»é™¤æ—§çš„è¾¹æ¡†ï¼Œæ”¹ç”¨æ›´é«˜çº§çš„ä¼ªå…ƒç´  */
            border-left: none;
        }

        /* é€‰ä¸­æ—¶çš„å·¦ä¾§å‘å…‰æ¡ */
        .track-header.selected::before {
            content: '';
            position: absolute; left: 0; top: 0; bottom: 0;
            width: 3px;
            background: var(--accent-blue);
            /* è“è‰²éœ“è™¹å…‰æ™• */
            box-shadow: 2px 0 12px rgba(46, 154, 255, 0.6);
            z-index: 2;
        }

        .track-name {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-main);
            margin-bottom: 6px;
            letter-spacing: 0.02em;
            /* æ–‡å­—é˜´å½±ï¼Œå¢åŠ ç«‹ä½“æ„Ÿ */
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);

            /* é€‰ä¸­æ—¶æ–‡å­—ç•¥å¾®å˜äº® */
            transition: color 0.2s;
        }
        .track-header.selected .track-name {
            color: #fff;
            text-shadow: 0 0 10px rgba(46, 154, 255, 0.3);
        }

        .track-controls {
            display: flex;
            align-items: center;
            gap: 8px; /* ç¨å¾®å¢åŠ é—´è· */
            opacity: 0.8; /* é»˜è®¤ç¨å¾®æš—ä¸€ç‚¹ï¼Œå‡å°‘è§†è§‰å¹²æ‰° */
            transition: opacity 0.2s;
        }
        .track-header:hover .track-controls {
            opacity: 1; /* æ‚¬åœæ—¶å®Œå…¨æ˜¾ç¤º */
        }

        /* --- è½¨é“å°æŒ‰é’® (Console Buttons) --- */
        .btn-sm {
            width: 22px; height: 22px;
            border-radius: 6px; /* ç¨å¾®æ›´åœ†æ¶¦ä¸€ç‚¹ */
            /* ç»ç’ƒåŸºåº• */
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(255, 255, 255, 0.05);
            color: #6e6e73; /* é»˜è®¤æ›´æš—ï¼Œä¸æŠ¢è§†è§‰ */

            font-size: 9px; font-weight: 700;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);

            display: inline-flex;
            align-items: center;
            justify-content: center;

            /* é¡¶éƒ¨å¾®å¼±é«˜å…‰ï¼Œåˆ¶é€ åšåº¦æ„Ÿ */
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .btn-sm:hover {
            border-color: rgba(255, 255, 255, 0.3);
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-1px);
        }

        /* æ¿€æ´»çŠ¶æ€ï¼šéœ“è™¹ç¯æ•ˆ */
        .mute-btn.active-mute {
            background: rgba(255, 69, 58, 0.9); /* çº¢è‰²åŠé€ */
            color: white;
            border-color: transparent;
            /* å¼ºçƒˆçš„çº¢è‰²å…‰æ™• */
            box-shadow: 0 0 12px rgba(255, 69, 58, 0.6), inset 0 1px 0 rgba(255,255,255,0.2);
        }

        .solo-btn.active-solo {
            background: var(--accent-yellow); /* é»„è‰²å®è‰² */
            color: black; /* é»‘è‰²æ–‡å­—å¯¹æ¯”åº¦æœ€é«˜ */
            border-color: transparent;
            /* é»„è‰²å…‰æ™• */
            box-shadow: 0 0 12px rgba(255, 214, 10, 0.6), inset 0 1px 0 rgba(255,255,255,0.4);
        }

        /* --- é¢œè‰²é€‰æ‹©å™¨ç¾åŒ– (Jewel Style) --- */
        input[type="color"] {
            -webkit-appearance: none; border: none;
            width: 18px; height: 18px; padding: 0;
            background: none; cursor: pointer;
            border-radius: 50%; overflow: visible; /* å…è®¸é˜´å½±æº¢å‡º */
            transition: transform 0.2s;
        }
        input[type="color"]:hover {
            transform: scale(1.1); /* æ‚¬åœå¾®æ”¾å¤§ */
        }

        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch {
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            /* ç»™è‰²å—å¢åŠ å¾®å¼±çš„å†…éƒ¨å…‰æ³½ */
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.3);
        }

        /* --- ç¼–ç»„æŒ‡ç¤ºæ¡ (LED Strip) --- */
        .group-indicator {
            position: absolute; left: 0; top: 0; bottom: 0; width: 4px;
            /* å¢åŠ å…‰æ™•ï¼Œä½¿å…¶çœ‹èµ·æ¥åƒ LED ç¯æ¡ */
            box-shadow: 2px 0 8px rgba(0,0,0,0.3);
        }

        /* --- å³ä¾§æ—¶é—´è½´ (Deep Space Grid) --- */
        #timeline-lanes {
            flex: 1;
            position: relative;
            overflow: scroll;

            /* èƒŒæ™¯è‰²æ”¹ä¸ºææ·±çš„åˆå¤œè“ï¼Œä¸ Body èåˆ */
            background-color: #08090e;

            /* ç½‘æ ¼ä¼˜åŒ–ï¼šä½¿ç”¨æä½é€æ˜åº¦çš„ç™½è‰²åœ†ç‚¹ï¼Œæ¯”ç°è‰²åœ†ç‚¹æ›´é€šé€ */
            background-image:
                    radial-gradient(rgba(255, 255, 255, 0.08) 1px, transparent 1px);

            /*ç¨å¾®æ‹‰å¤§ä¸€ç‚¹é—´è·ï¼Œæ˜¾å¾—è§†é‡æ›´å¼€é˜” */
            background-size: 24px 24px;

            /* é¡¶éƒ¨å†…é˜´å½±ï¼Œå¢åŠ çºµæ·±æ„Ÿï¼Œè®©æ ‡å°ºçœ‹èµ·æ¥æ˜¯æ‚¬æµ®çš„ */
            box-shadow: inset 0 10px 20px -10px rgba(0,0,0,0.5);
        }

        /* --- è½¨é“è¡Œ (Ambient Lane) --- */
        .track-lane {
            height: 64px;
            /* 1. é”å®šç›’æ¨¡å‹ */
            box-sizing: border-box;

            /* 2. åº•éƒ¨è¾¹æ¡† */
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);

            /* 3. ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šé¡¶éƒ¨è¾¹æ¡†æ”¹ä¸ºæ˜¾è‰²ï¼Œä¸å·¦ä¾§ Header ä¿æŒè§†è§‰ä¸€è‡´ */
            border-top: 1px solid rgba(255, 255, 255, 0.02);

            position: relative;

            /* 4. æ˜¾å¼å£°æ˜å±‚çº§ï¼Œé˜²æ­¢é®æŒ¡ç½‘æ ¼ */
            z-index: 0;

            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.02) 0%, transparent 40%);
            transition: background 0.2s;
        }

        /* æ‚¬åœè½¨é“è¡Œæ—¶ï¼Œç¨å¾®åŠ äº® */
        .track-lane:hover {
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.04) 0%, rgba(255, 255, 255, 0.01) 100%);
        }

        #lanes-container {
            position: relative; /* è®©å†…éƒ¨çš„æ’­æ”¾çº¿å’Œç½‘æ ¼çº¿ç›¸å¯¹äº"æ•´ä¸ªå†…å®¹"å®šä½ï¼Œè€Œä¸æ˜¯"çª—å£" */
            min-height: 100%;   /* ç¡®ä¿é«˜åº¦è‡³å°‘å¡«æ»¡ä¸€å± */
            display: flex;
            flex-direction: column;
            z-index: 0;
        }

        /* --- ä¿®å¤å±‚çº§ï¼šé˜²æ­¢ç½‘æ ¼çº¿è¢«èƒŒæ™¯é®æŒ¡ --- */
        .grid-lines {
            /* æé«˜å±‚çº§ï¼Œä½¿å…¶æµ®åœ¨è½¨é“èƒŒæ™¯ä¹‹ä¸Š */
            z-index: 1;
            pointer-events: none; /* è®©é¼ æ ‡ç©¿é€ï¼Œä¸å½±å“ç‚¹å‡» */
        }

        /* --- ä¿®å¤æ’­æ”¾çº¿å±‚çº§ --- */
        #ui-playhead {
            z-index: 200; /* ç¡®ä¿æ’­æ”¾çº¿åœ¨æœ€ä¸Šå±‚ */
        }

        /* --- Clip (éŸ³ç¬¦å—) - æ ¸å¿ƒç»„ä»¶ï¼šæ°´æ™¶ç»ç’ƒæ€ --- */
        .clip {
            position: absolute; top: 6px; height: 52px;

            /* æè´¨å‡çº§ï¼šå‚ç›´æ¸å˜ï¼Œæ¨¡æ‹Ÿå…‰ç…§ */
            background: linear-gradient(180deg, rgba(46, 154, 255, 0.15) 0%, rgba(46, 154, 255, 0.05) 100%);

            /* è¾¹æ¡†ï¼šä½¿ç”¨åŠé€æ˜çš„ Accent Color */
            border: 1px solid rgba(46, 154, 255, 0.3);
            border-radius: 6px;

            /* æ ¸å¿ƒç«‹ä½“æ„Ÿï¼š
               1. inset shadow (ç™½) -> é¡¶éƒ¨é«˜å…‰å€’è§’
               2. drop shadow (é»‘) -> æ‚¬æµ®é˜´å½±
               3. inset shadow (æ·±) -> åº•éƒ¨åšåº¦
            */
            box-shadow:
                    inset 0 1px 0 rgba(255, 255, 255, 0.2),
                    inset 0 -1px 0 rgba(0, 0, 0, 0.1),
                    0 4px 10px rgba(0, 0, 0, 0.3);

            cursor: grab; overflow: hidden;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);

            transition: transform 0.1s, box-shadow 0.1s, border-color 0.1s;
        }

        /* æ‹–æ‹½/æ¿€æ´»çŠ¶æ€ï¼šå˜å¾—æ›´äº®ã€æ›´å® */
        .clip:active {
            cursor: grabbing;
            border-color: rgba(255, 255, 255, 0.8);
            background: rgba(46, 154, 255, 0.25);
            transform: scale(1.02); /* å¾®å¾®æ”¾å¤§ï¼Œåé¦ˆæ‰‹æ„Ÿ */
            box-shadow:
                    0 8px 20px rgba(0, 0, 0, 0.5),
                    inset 0 0 0 1px rgba(255,255,255,0.2);
            z-index: 100;
        }

        /* Clip å†…éƒ¨çš„æ³¢å½¢/éŸ³ç¬¦åç§° */
        .clip-name {
            padding: 6px 8px;
            font-size: 11px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            letter-spacing: 0.5px;

            /* ç¡®ä¿æ–‡å­—æ¸…æ™°å¯è¯» */
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6);
            pointer-events: none;
            z-index: 2;

            /* é˜²æ­¢æ–‡å­—è¿‡é•¿æº¢å‡º */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* å¯é€‰ï¼šç»™ Clip å¢åŠ ä¸€ä¸ªå·¦ä¾§è£…é¥°æ¡ï¼Œå¢å¼ºä¸“ä¸šæ„Ÿ */
        .clip::before {
            content: '';
            position: absolute; left: 0; top: 0; bottom: 0; width: 4px;
            background: rgba(46, 154, 255, 0.5);
            opacity: 0.8;
        }

        /* --- æ’­æ”¾æŒ‡é’ˆ (Laser Beam) --- */
        #ruler-playhead, #ui-playhead {
            position: absolute; top: 0; bottom: 0;
            width: 1px; /* æç»†çš„æ ¸å¿ƒ */

            /* æ ¸å¿ƒé¢œè‰² */
            background: var(--accent-red);
            z-index: 100;
            pointer-events: none;

            /* æ¿€å…‰å…‰æ™•ï¼šåŒå±‚æŠ•å½±æ¨¡æ‹Ÿé«˜äº® */
            box-shadow:
                    0 0 4px var(--accent-red),           /* å†…å±‚é«˜äº® */
                    0 0 15px rgba(255, 69, 58, 0.4);     /* å¤–å±‚æ¼«å°„å…‰ */
        }

        /* æŒ‡é’ˆå¤´éƒ¨ (Emitter) */
        #ruler-playhead::after {
            content: '';
            position: absolute; top: 0; left: -4.5px;

            /* å½¢çŠ¶ï¼šå€’ä¸‰è§’ */
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 8px solid var(--accent-red);

            /* å¤´éƒ¨ä¹Ÿå‘å…‰ */
            filter: drop-shadow(0 0 5px rgba(255, 69, 58, 0.8));
        }

        /* --- è°ƒæ•´æŠŠæ‰‹ (Structural Split) --- */
        #resize-handle {
            height: 14px;

            /* èƒŒæ™¯ï¼šææ·±çš„é»‘è‰²ï¼Œæ¨¡æ‹Ÿä¸¤ä¸ªé¢æ¿ä¹‹é—´çš„ç¼éš™ */
            background: #020202;

            /* è¾¹æ¡†ï¼šé¡¶éƒ¨äº®çº¿ï¼Œåº•éƒ¨æš—å½±ï¼Œåˆ¶é€ å‡¹æ§½æ„Ÿ */
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            border-bottom: 1px solid rgba(0, 0, 0, 0.8);

            /* å‘ä¸ŠæŠ•å°„é˜´å½±ï¼Œå¢åŠ  DAW åŒºåŸŸçš„æ‚¬æµ®æ„Ÿ */
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.5);

            cursor: row-resize;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
            z-index: 60;
            transition: background 0.3s, border-color 0.3s;
        }

        #resize-handle:hover {
            background: #08090e; /* æ‚¬åœæ—¶å¾®å¾®å˜äº® */
            border-top-color: rgba(255, 255, 255, 0.15);
        }

        /* æ¨¡ä»¿ iPhone å°ç™½æ¡ (Interactive Capsule) */
        .handle-bar {
            width: 100px; /* é»˜è®¤ç¨å¾®çŸ­ä¸€ç‚¹ï¼Œæ˜¾å¾—ç²¾è‡´ */
            height: 4px;

            /* æè´¨ï¼šåŠé€æ˜é‡‘å±è´¨æ„Ÿ */
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;

            /* å¾®å¼±çš„å…‰æ³½ */
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);

            /* æè‡´é¡ºæ»‘çš„è¿‡æ¸¡ */
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        /* æ‚¬åœäº¤äº’ï¼šå˜é•¿ã€å˜äº®ã€å˜åš */
        #resize-handle:hover .handle-bar {
            background: var(--accent-blue); /* æ¿€æ´»å˜ä¸ºç§‘æŠ€è“ */
            width: 220px;
            height: 4px; /* ä¿æŒé«˜åº¦ï¼Œæˆ–è€…å¾®è°ƒ */
            box-shadow: 0 0 10px rgba(46, 154, 255, 0.6); /* è“è‰²è¾‰å…‰ */
        }

        /* æ‹–æ‹½æ—¶ç¦æ­¢é¡µé¢é€‰ä¸­æ–‡å­— */
        body.resizing {
            user-select: none;
            cursor: row-resize;
        }

        /* --- ä¸‹åŠéƒ¨åˆ†å¯è§†åŒ–åŒºåŸŸ (Cinematic Stage) --- */
        #visualizer-section {
            flex: 1;
            /* æ ¸å¿ƒèƒŒæ™¯ï¼šæ·±é‚ƒçš„é»‘æ´æ¸å˜ï¼Œä¸­å¿ƒå¾®äº®ï¼Œå››å‘¨çº¯é»‘ */
            background: radial-gradient(circle at center, #151922 0%, #000000 90%);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;

            /* é¡¶éƒ¨å†…é˜´å½±è¡”æ¥ï¼Œåˆ¶é€ â€œæ²‰å…¥â€æ„Ÿ */
            box-shadow: inset 0 20px 50px -10px rgba(0,0,0,0.9);

            /* å¢åŠ å¾®å¼±çš„é¡¶éƒ¨åå…‰è¾¹æ¡† */
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        /* æµ®åŠ¨ä¿¡æ¯å±‚ (Tech HUD) */
        #viz-overlay {
            position: absolute; top: 20px; right: 24px;
            color: rgba(255, 255, 255, 0.6);
            /* ç§‘æŠ€æ„Ÿå­—ä½“ */
            font-family: "SF Mono", "Menlo", monospace;
            font-size: 10px;
            letter-spacing: 1px;
            text-transform: uppercase;

            /* æ·±è‰²ç£¨ç ‚èƒ¶å›Š */
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 14px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);

            backdrop-filter: blur(20px);
            pointer-events: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        /* --- åº•éƒ¨æ§åˆ¶æ  (Command Deck) --- */
        #bottom-controls {
            height: 72px; /* ç¨å¾®å¢é«˜ï¼Œæ›´æ˜¾å¤§æ°” */

            /* æè´¨ï¼šåšé‡çš„æ·±è‰²ç»ç’ƒ */
            background: rgba(11, 12, 18, 0.85);
            backdrop-filter: blur(40px); /* å¼ºåŠ›æ¨¡ç³Šï¼Œè¿‡æ»¤æ‰ä¸‹æ–¹æ‚è´¨ */
            -webkit-backdrop-filter: blur(40px);

            /* é¡¶éƒ¨é«˜å…‰è¾¹æ¡† */
            border-top: 1px solid rgba(255, 255, 255, 0.1);

            display: flex;
            align-items: center;
            justify-content: center;
            gap: 40px; /* æ‹‰å¤§é—´è· */
            padding: 0 32px;
            flex-shrink: 0;
            z-index: 50;

            /* åº•éƒ¨æ‰˜åº•é˜´å½± */
            box-shadow: 0 -10px 30px rgba(0,0,0,0.3);
        }

        .slider-group {
            display: flex; align-items: center; gap: 12px;
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .slider-group > span {
            min-width: 60px;
            text-align: right;
            opacity: 0.8;
        }

        /* --- é‡å†™ Range Slider (High-End Audio Gear) --- */
        input[type=range] {
            -webkit-appearance: none;
            width: 140px; /* åŠ å®½ä¸€ç‚¹ */
            background: transparent;
            height: 24px; /* å¢åŠ ç‚¹å‡»åŒºåŸŸ */
            cursor: pointer;
        }

        /* è½¨é“ (Groove Track) */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px; /* ç¨åš */
            cursor: pointer;

            /* æ·±å‡¹æ§½è®¾è®¡ */
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.8); /* å†…éƒ¨é˜´å½± */
        }

        /* æ»‘å— (Metallic Thumb) */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px; width: 18px;
            margin-top: -7px; /* å‚ç›´å±…ä¸­ä¿®æ­£ */
            border-radius: 50%;

            /* é‡‘å±è´¨æ„Ÿï¼šé“¶ç™½æ¸å˜ */
            background: linear-gradient(145deg, #ffffff, #d1d1d6);
            border: 1px solid rgba(255,255,255,0.5);

            /* æŠ•å½±ï¼šè®©æ»‘å—æµ®èµ·æ¥ */
            box-shadow: 0 2px 6px rgba(0,0,0,0.6);
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        /* æ‚¬åœ/æ‹–æ‹½äº¤äº’ï¼šå…‰æ™•çˆ†å‘ */
        input[type=range]:hover::-webkit-slider-thumb {
            transform: scale(1.1);
            box-shadow: 0 0 0 2px rgba(255,255,255,0.1), 0 4px 10px rgba(0,0,0,0.5);
        }

        input[type=range]:active::-webkit-slider-thumb {
            background: #fff;
            transform: scale(1.2);
            /* æ¿€æ´»æ—¶å˜ä¸ºç§‘æŠ€è“å…‰æ™• */
            box-shadow: 0 0 0 4px rgba(46, 154, 255, 0.3), 0 0 15px rgba(46, 154, 255, 0.5);
            border-color: var(--accent-blue);
        }

        /* --- åº•éƒ¨ Select ä¸‹æ‹‰æ¡† (Glass Capsule) --- */
        #bottom-controls select {
            background-color: rgba(255, 255, 255, 0.05);
            color: #fff;

            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 6px 12px;

            font-size: 11px;
            font-weight: 500;
            outline: none;
            cursor: pointer;

            /* å¢åŠ å¾®å¼±å…‰æ³½ */
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
            transition: all 0.2s;
        }

        #bottom-controls select:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.25);
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        #bottom-controls select:focus {
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(46, 154, 255, 0.15);
        }

        /* --- æ–°å¢ï¼šé«˜çº§å‚æ•°è¾“å…¥æ¡† (Embedded Data Modules) --- */
        .param-box {
            /* æè´¨ï¼šæ·±è‰²åµŒå…¥å¼ç»ç’ƒ */
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px; /* ç¨å¾®æ›´åœ†æ¶¦ï¼Œä¸æŒ‰é’®ç»Ÿä¸€ */
            padding: 8px 12px; /* å¢åŠ ä¸€ç‚¹å†…è¾¹è·ï¼Œå‘¼å¸æ„Ÿæ›´å¼º */
            margin-bottom: 8px;

            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            display: flex;
            flex-direction: column;

            /* æ ¸å¿ƒç«‹ä½“æ„Ÿï¼šé¡¶éƒ¨å¾®å¼±å†…å‘å…‰ï¼Œåº•éƒ¨å¾®å¼±æŠ•å½± -> åˆ¶é€ åµŒå…¥æ„Ÿ */
            box-shadow:
                    inset 0 1px 0 rgba(255, 255, 255, 0.03),
                    0 2px 4px rgba(0, 0, 0, 0.2);

            position: relative;
            overflow: hidden;
        }

        /* --- è¦†ç›–ï¼šç§»é™¤æ‰€æœ‰å½©è‰²çº¿æ¡ï¼Œå›å½’æç®€ (Stealth Mode) --- */
        .param-box[class*="theme-"] {
            border-left-width: 0 !important;
            border-left-style: none !important;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.03), 0 2px 4px rgba(0, 0, 0, 0.2) !important; /* ä¿æŒé€šç”¨é˜´å½± */
            background: rgba(0, 0, 0, 0.4);
            padding-left: 12px !important; /* ä¿æŒå¯¹é½ */
        }

        /* é¼ æ ‡æ‚¬åœæ—¶çš„é€šç”¨å¾®äº¤äº’ */
        .param-box:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px); /* å¾®å¾®æµ®èµ· */
        }

        /* é€‰ä¸­æ—¶é«˜äº®ï¼šé€šç”µæ¿€æ´»æ•ˆæœ */
        .param-box:focus-within {
            border-color: var(--accent-blue);
            /* èƒŒæ™¯å˜äº®ï¼Œä»¿ä½›å±å¹•èƒŒå…‰äº®èµ· */
            background: rgba(10, 132, 255, 0.1);
            /* è“è‰²å…‰æ™•æ‰©æ•£ */
            box-shadow:
                    0 0 0 1px var(--accent-blue),
                    0 4px 15px rgba(10, 132, 255, 0.2);
        }

        /* å‚æ•°æ ‡ç­¾ (Technical Label) */
        .param-label {
            font-size: 9px; /* å¾®å‹å­—ä½“ */
            color: var(--text-muted); /* ä½¿ç”¨å…¨å±€å‰¯è‰² */
            margin-bottom: 4px;
            font-weight: 700;

            /* å¢åŠ å­—é—´è·ï¼Œæå‡ç§‘æŠ€æ„Ÿ */
            letter-spacing: 0.08em;
            text-transform: uppercase;
            opacity: 0.8;
        }

        /* é€‰ä¸­æ—¶æ ‡ç­¾ä¹Ÿå˜è“ï¼Œæç¤ºæ€§æ›´å¼º */
        .param-box:focus-within .param-label {
            color: var(--accent-blue);
            opacity: 1;
        }

        /* å‚æ•°æ•°å€¼ (Digital Readout) */
        .param-input {
            background: transparent;
            border: none;
            color: #fff;

            font-family: "SF Mono", "Menlo", "Consolas", monospace; /* å¼ºåˆ¶ç­‰å®½ */
            font-size: 14px;
            font-weight: 600;
            width: 100%;
            outline: none;
            padding: 0;

            /* æ•°å­—å…‰æ™•ï¼šæ¨¡æ‹Ÿ OLED å±å¹•æ˜¾ç¤º */
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            transition: text-shadow 0.2s;
        }

        /* é€‰ä¸­æ—¶æ•°å­—æ›´äº® */
        .param-box:focus-within .param-input {
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
        }

        /* é’ˆå¯¹ input type=number éšè—é»˜è®¤çš„ä¸Šä¸‹ç®­å¤´ */
        .param-input::-webkit-inner-spin-button,
        .param-input::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* --- Modals (Hyper-Glass / Deep Depth) --- */
        .modal-content {
            /* æ ¸å¿ƒæè´¨ï¼šææ·±ã€æé€çš„åˆå¤œç»ç’ƒ */
            background: rgba(18, 18, 24, 0.85) !important;
            backdrop-filter: blur(50px);
            -webkit-backdrop-filter: blur(50px);

            /* è¾¹æ¡†ï¼šåŒå±‚è¾¹æ¡†é€»è¾‘ï¼Œå†…äº®å¤–æš—ï¼Œæ¨¡æ‹Ÿç»ç’ƒè¾¹ç¼˜åå…‰ */
            border: 1px solid rgba(255, 255, 255, 0.08) !important;

            /* é˜´å½±ï¼šè¶…å¤§æ‰©æ•£é˜´å½±æ‰˜èµ·å¼¹çª— + å†…éƒ¨å¾®å¼±é«˜å…‰æè¾¹ */
            box-shadow:
                    0 40px 100px rgba(0, 0, 0, 0.8),
                    inset 0 1px 0 rgba(255, 255, 255, 0.05) !important;

            border-radius: 20px !important; /* æ›´å¤§çš„åœ†è§’ï¼Œæ›´ç°ä»£ */
            color: var(--text-main);
            width: 360px !important; /* ç¨å¾®åŠ å®½ï¼Œå¸ƒå±€æ›´èˆ’å±• */
            padding: 32px !important; /* å¢åŠ å†…è¾¹è·ï¼Œå‡å°‘æ‹¥æŒ¤æ„Ÿ */
        }

        .modal-content h3 {
            font-weight: 700;
            font-size: 20px;
            margin-bottom: 24px;
            text-align: center;
            color: #fff;
            /* æ ‡é¢˜å¢åŠ å¾®å¼±çš„å…‰æ™•ï¼Œæå‡å±‚çº§ */
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            letter-spacing: 0.5px;
        }

        .form-group label {
            color: var(--text-muted);
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
            /* å¢åŠ å­—é—´è·å’Œå…¨å¤§å†™ï¼Œå¢åŠ ç§‘æŠ€æ„Ÿï¼ˆå¯é€‰ï¼‰ */
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        /* è¾“å…¥æ¡†ä¸ä¸‹æ‹‰æ¡†ï¼šæ·±å‘è®¾è®¡ (Deep Recess) */
        .form-group select, .form-group input[type="text"] {
            width: 100%;
            /* èƒŒæ™¯ææ·±ï¼Œå½¢æˆå‡¹æ§½æ„Ÿ */
            background: rgba(0, 0, 0, 0.4) !important;
            border: 1px solid rgba(255, 255, 255, 0.08) !important;
            border-radius: 10px !important;
            padding: 12px !important; /* æ›´èˆ’é€‚çš„ç‚¹å‡»åŒºåŸŸ */
            color: #fff !important;
            font-size: 13px;
            outline: none;
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);

            /* å†…éƒ¨å¾®é˜´å½±ï¼Œå¼ºåŒ–å‡¹é™·æ„Ÿ */
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
        }

        /* ç„¦ç‚¹çŠ¶æ€ï¼šèƒ½é‡æ¿€æ´» */
        .form-group select:focus, .form-group input:focus {
            border-color: var(--accent-blue) !important;
            /* èšç„¦æ—¶èƒŒæ™¯ç¨å¾®æäº® */
            background: rgba(0, 0, 0, 0.6) !important;
            /* è“è‰²å…‰æ™•æ‰©æ•£ */
            box-shadow:
                    0 0 0 3px rgba(46, 154, 255, 0.15),
                    inset 0 1px 2px rgba(0, 0, 0, 0.5) !important;
        }

        .modal-buttons {
            gap: 16px !important; /* æ‹‰å¤§æŒ‰é’®é—´è· */
            margin-top: 32px !important;
        }

        .modal-buttons .btn {
            flex: 1;
            padding: 12px; /* å¢åŠ é«˜åº¦ */
            border-radius: 10px;
            font-size: 13px;
            font-weight: 600;
        }

        #context-menu {
            position: fixed; /* ğŸ”¥ å…³é”®ä¿®å¤ï¼šå¿…é¡»æ˜¯å›ºå®šå®šä½ï¼Œtop/left æ‰ä¼šç”Ÿæ•ˆ */
            display: none;   /* é»˜è®¤éšè— */
            z-index: 10000;  /* ç¡®ä¿åœ¨æœ€ä¸Šå±‚ï¼Œé®æŒ¡ä½è½¨é“ */

            background: rgba(30,30,30,0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 6px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .menu-item {
            border-radius: 6px; padding: 6px 12px; font-size: 12px;
        }
        .menu-item:hover { background: var(--accent-blue); color: #fff; }

        /* --- å³é”®èœå• (Floating OS Menu) --- */
        #context-menu {
            position: fixed; /* ğŸ”¥ ä¿æŒå…³é”®ä¿®å¤ */
            display: none;
            z-index: 10000;

            /* æè´¨å‡çº§ï¼šç£¨ç ‚æ„Ÿæ›´å¼ºï¼ŒèƒŒæ™¯æ›´æ·±ï¼Œæ¥è¿‘ macOS é£æ ¼ */
            background: rgba(20, 20, 25, 0.85);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);

            /* è¾¹æ¡†ï¼šæç»†å¾®çš„äº®è¾¹ */
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px; /* æ›´åœ†æ¶¦ */
            padding: 6px;

            /* é˜´å½±ï¼šé”åˆ©çš„æ‚¬æµ®é˜´å½±ï¼Œå¢åŠ å±‚æ¬¡æ„Ÿ */
            box-shadow:
                    0 10px 40px rgba(0, 0, 0, 0.6),
                    0 0 0 1px rgba(255, 255, 255, 0.05); /* åŒé‡è¾¹æ¡†å¼ºåŒ–ç»†èŠ‚ */

            min-width: 160px; /* ä¿è¯æœ€å°å®½åº¦ */

            /* å¢åŠ ä¸€ä¸ªå¾®å¼±çš„è¿›åœºåŠ¨ç”» */
            animation: menuFade 0.1s ease-out;
            transform-origin: top left;
        }

        @keyframes menuFade {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        .menu-item {
            border-radius: 6px;
            padding: 8px 12px; /* ç¨å¾®å¢åŠ ç‚¹å‡»åŒºåŸŸ */
            font-size: 12px;
            color: var(--text-main);
            cursor: pointer;
            transition: all 0.1s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .menu-item:hover {
            background: var(--accent-blue);
            color: #fff;
            /* è“è‰²å…‰æ™•ï¼Œå¢åŠ é€‰ä¸­è´¨æ„Ÿ */
            box-shadow: 0 4px 12px rgba(46, 154, 255, 0.3);
        }

        /* --- Logo æ ·å¼ (Premium Brand) --- */
        #app-logo {
            display: flex;
            align-items: center;
            gap: 10px;            /* æ‹‰å¼€ä¸€ç‚¹é—´è· */
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 8px;
            transition: all 0.2s;
            user-select: none;
            text-decoration: none;
            height: 100%;
        }

        /* ä¼˜åŒ–æ‚¬åœï¼šä¸å†æ˜¯å˜é€æ˜ï¼Œè€Œæ˜¯èƒŒæ™¯å¾®äº®ï¼Œæ›´æ˜¾é«˜çº§ */
        #app-logo:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.05);
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.05);
        }

        /* --- è¡¥å…… Logo å†…éƒ¨æ–‡å­—æ ·å¼ (Pro Max å¿…éœ€) --- */
        .logo-wrapper {
            display: flex;
            flex-direction: column;
            align-items: flex-start; /* å·¦å¯¹é½ */
            justify-content: center;
            line-height: 1.0;
        }

        .logo-text {
            font-family: 'Chango', sans-serif;
            font-weight: 400;

            /* å‡çº§ï¼šé“¶è‰²åˆ°ç™½è‰²çš„é«˜çº§é‡‘å±æ¸å˜ */
            background: linear-gradient(180deg, #ffffff 20%, #a1a1aa 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;

            /* æ–‡å­—æŠ•å½± */
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        .title-main {
            font-size: 18px;
            letter-spacing: 0.05em;
        }

        .title-sub {
            font-size: 9px;
            letter-spacing: 0.2em;
            opacity: 0.8;
            color: #fff;
            margin-top: 2px;
        }

        /* ç‰ˆæœ¬å·æ ‡ç­¾ */
        .version-tag {
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
            font-size: 9px;
            background: var(--accent-blue); /* å¦‚æœæœ‰ defined gradient æ›´å¥½ */
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 700;
            align-self: center;
            margin-top: 2px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        /* --- Loading é®ç½© (Seamless Launch) --- */
        #loading {
            /* æ ¸å¿ƒä¼˜åŒ–ï¼šä½¿ç”¨ä¸ Body ä¸€è‡´çš„æ·±è‰²èƒŒæ™¯ï¼Œæ¶ˆé™¤åŠ è½½æ—¶çš„å‰²è£‚æ„Ÿ */
            background: var(--bg-color) !important;
            background-image: radial-gradient(circle at 50% -20%, #1c2540 0%, #050507 50%) !important;

            backdrop-filter: blur(20px);
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--text-muted);

            /* å¢åŠ æ·¡å…¥æ·¡å‡ºè¿‡æ¸¡ */
            transition: opacity 0.5s ease;
        }

        /* --- å…¨å±€æ‹–æ‹½è¦†ç›– (Import Zone) --- */
        body.global-drag-over::after {
            content: 'å¯¼å…¥æ–‡ä»¶ (MIDI / Audio / Image / Video / JSON)';
            position: fixed;
            /* ç¨å¾®ç•™å‡ºè¾¹è·ï¼Œè®¾è®¡æ„Ÿæ›´å¼º */
            top: 12px; left: 12px; right: 12px; bottom: 12px;
            width: auto; height: auto;

            /* æè´¨ï¼šæ·±è‰²ç£¨ç ‚ç»ç’ƒ */
            background: rgba(11, 12, 18, 0.85);

            /* è¾¹æ¡†ï¼šå“ç‰Œè“è™šçº¿ */
            border: 2px dashed var(--accent-blue);
            border-radius: 16px;

            backdrop-filter: blur(15px);
            z-index: 99999;
            pointer-events: none; /* è®©é¼ æ ‡äº‹ä»¶ç©¿é€ï¼Œé˜²æ­¢é—ªçƒ */

            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 20px; /* å­—ä½“å¾®è°ƒ */
            font-weight: 600;
            box-sizing: border-box;

            /* æ–‡å­—æµ®èµ·æ„Ÿ */
            text-shadow: 0 0 20px rgba(0,0,0,0.8);
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        #canvas-wrapper.recording-mode {
            /* å¼ºåˆ¶ wrapper ä¿æŒåŸæœ‰å¤§å°ï¼Œä¸è¢«å­å…ƒç´ æ’‘å¼€ */
            pointer-events: auto !important; /* ğŸ”¥ ä¿æŒäº¤äº’å¼€å¯ */
        }

        #canvas-wrapper.recording-mode canvas {
            /* æ ¸å¿ƒä¿®å¤ä¿æŒä¸å˜ */
            width: 100% !important;
            height: 100% !important;
            object-fit: contain;
        }

        /* --- ä¿®å¤å½•åˆ¶çŠ¶æ€æ ä½ç½® (Red Alert Capsule) --- */
        #recording-status {
            position: fixed;

            /* ğŸ”¥ ä¿æŒæ ¸å¿ƒä½ç½®ä¿®æ”¹ */
            top: auto;
            bottom: 90px;

            left: 50%;
            transform: translateX(-50%);
            z-index: 9999;

            /* ğŸ”¥ ä¿®æ”¹ 1ï¼šèƒŒæ™¯æ”¹ä¸ºæ·±è‰²åŠé€æ˜ (Glass) */
            background: rgba(0, 0, 0, 0.6) !important;
            backdrop-filter: blur(20px);

            /* è¾¹æ¡†ä¿æŒå¾®å¼±äº®è‰² */
            border: 1px solid rgba(255, 255, 255, 0.15) !important;

            /* ğŸ”¥ ä¿®æ”¹ 2ï¼šé˜´å½±æ”¹ä¸ºæ™®é€šçš„é»‘è‰²æŠ•å½±ï¼Œå»æ‰çº¢å…‰ */
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);

            padding: 8px 24px !important;
            font-variant-numeric: tabular-nums;
            border-radius: 30px;

            display: none;
            align-items: center;
            color: white;
            font-weight: 600;
            letter-spacing: 0.5px;
            pointer-events: auto;

            transition: all 0.3s;
        }

        /* --- æ–°å¢ï¼šå·¦ä¾§è½¨é“åˆ—è¡¨å·¥å…·æ  --- */
        #track-list-toolbar {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.02);
            border-bottom: 1px solid var(--glass-border);
            flex-shrink: 0;
        }

        /* --- æ–°å¢ï¼šR (Record Arm) æŒ‰é’®æ ·å¼ --- */
        .record-arm-btn.active-arm {
            background: rgba(255, 69, 58, 0.9) !important; /* é²œè‰³çš„çº¢è‰² */
            color: white !important;
            border-color: transparent;
            box-shadow: 0 0 10px rgba(255, 69, 58, 0.6), inset 0 1px 0 rgba(255,255,255,0.2);
            animation: armPulse 2s infinite;
        }

        @keyframes armPulse {
            0% { box-shadow: 0 0 5px rgba(255, 69, 58, 0.4); }
            50% { box-shadow: 0 0 12px rgba(255, 69, 58, 0.8); }
            100% { box-shadow: 0 0 5px rgba(255, 69, 58, 0.4); }
        }

        /* å¯¼å‡ºé®ç½©å±‚ */
        #export-modal {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            /* èƒŒæ™¯åŠ æ·±ï¼Œèšç„¦ä¸­é—´å†…å®¹ */
            background: rgba(5, 5, 7, 0.85);
            z-index: 5000;

            /* Flex å±…ä¸­ä¸‰ä»¶å¥— */
            display: none;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
        }

        /* æ¨¡å‹é¢„è§ˆçª—å£ç‰¹å®šæ ·å¼ */
        #model-preview-modal .modal-content {
            width: 900px !important;
            max-width: 95vw !important;
            height: 700px !important;
            padding: 0 !important;
            display: flex !important;
            flex-direction: column !important;

            /* ç¡®ä¿å¤§çª—å£ä¹Ÿç»§æ‰¿ç»ç’ƒè´¨æ„Ÿè¾¹æ¡† */
            border: 1px solid rgba(255,255,255,0.1) !important;
            background: rgba(18, 18, 24, 0.95) !important; /* ä¸é€æ˜åº¦ç¨é«˜ï¼Œé˜²æ­¢æ¨¡å‹èƒŒæ™¯å¹²æ‰° */
        }

        /* --- é‡æ„åçš„ iOS å¼€å…³æ ·å¼ (Neon Toggle) --- */
        .ios-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px; /* ç¨å¾®åŠ é«˜ 2pxï¼Œæ‰‹æ„Ÿæ›´å¥½ */
            vertical-align: middle;
            margin-left: 8px;
            flex-shrink: 0;
        }

        /* éšè—åŸå§‹ Checkbox */
        .ios-switch input {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
            margin: 0;
        }

        /* è½¨é“ (Groove Track) */
        .ios-switch .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;

            /* æœªé€‰ä¸­ï¼šæ·±è‰²å‡¹æ§½èƒŒæ™¯ */
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);

            /* æ ¸å¿ƒè´¨æ„Ÿï¼šå†…é˜´å½±åˆ¶é€ æ·±åº¦ */
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);

            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            border-radius: 20px;
            box-sizing: border-box;
        }

        /* æ—‹é’® (Pearl Knob) */
        .ios-switch .slider:before {
            position: absolute;
            content: "";
            height: 16px; /* é€‚é…æ–°çš„é«˜åº¦ */
            width: 16px;

            /* åˆå§‹çŠ¶æ€ï¼šé å·¦ */
            left: 1px;
            bottom: 1px;

            /* æè´¨ï¼šå¾®æ¸å˜çç ç™½ */
            background: linear-gradient(180deg, #ffffff 0%, #e0e0e0 100%);

            /* æŠ•å½±ï¼šè®©æ—‹é’®æ‚¬æµ® */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);

            transition: left 0.3s cubic-bezier(0.4, 0.0, 0.2, 1), transform 0.3s;
            border-radius: 50%;
        }

        /* é€‰ä¸­çŠ¶æ€ - è½¨é“å˜è‰² (Active Glow) */
        .ios-switch input:checked + .slider {
            background-color: var(--accent-green);
            border-color: transparent; /* æ¿€æ´»æ—¶ç§»é™¤è¾¹æ¡†ï¼Œè®©å…‰æ™•æ‰©æ•£ */

            /* ç»¿è‰²è§å…‰å…‰æ™• + å†…éƒ¨é«˜å…‰ */
            box-shadow:
                    0 0 10px rgba(48, 209, 88, 0.4),
                    inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        /* é€‰ä¸­çŠ¶æ€ - æ—‹é’®ç§»åŠ¨ */
        .ios-switch input:checked + .slider:before {
            /* åŠ¨æ€è®¡ç®—ä½ç½®ï¼š100% - çƒå®½16px - è¾¹è·1px - è¾¹æ¡†ä¿®æ­£ */
            left: calc(100% - 18px);

            /* æ¿€æ´»æ—¶æ—‹é’®ä¹Ÿå˜äº® */
            background: #fff;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            transform: none;
        }

        /* --- è‰²å—æ ·å¼ (Jewel Swatches) --- */
        .color-swatch {
            width: 80%;
            aspect-ratio: 1; /* æ­£æ–¹å½¢ */
            border-radius: 50%; /* åœ†å½¢ */
            cursor: pointer;

            /* æè´¨ï¼šå¸¦å¾®å¼±å†…å‘å…‰çš„å®çŸ³æ„Ÿ */
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow:
                    inset 0 2px 4px rgba(255, 255, 255, 0.2), /* é¡¶éƒ¨é«˜å…‰ */
                    0 2px 5px rgba(0, 0, 0, 0.5); /* åº•éƒ¨æ‚¬æµ®å½± */

            transition: transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94), border-color 0.2s;
            position: relative;
        }

        .color-swatch:hover {
            transform: scale(1.15); /* æ”¾å¤§æ›´å¤šä¸€ç‚¹ */
            z-index: 2;
            /* æ‚¬åœæ›´äº® */
            box-shadow:
                    inset 0 2px 6px rgba(255, 255, 255, 0.4),
                    0 4px 12px rgba(0, 0, 0, 0.6);
        }

        /* é€‰ä¸­çŠ¶æ€ï¼šåŒå±‚å…‰åœˆ */
        .color-swatch.active {
            border-color: #fff; /* å†…åœˆçº¯ç™½ */
            box-shadow:
                    0 0 0 2px var(--accent-blue), /* å¤–åœˆç§‘æŠ€è“ */
                    0 0 15px var(--accent-blue);  /* è“è‰²è¾‰å…‰ */
        }

        /* æ–°å¢ï¼šè‡ªå®šä¹‰é¢œè‰²æŒ‰é’® (å½©è™¹æ¸å˜) */
        .color-swatch.custom-picker {
            background: linear-gradient(135deg, #ff3b30, #ff9500, #ffcc00, #4cd964, #5ac8fa, #007aff, #5856d6, #ff2d55);
            position: relative;
            overflow: hidden; /* ç¡®ä¿ input ä¸æº¢å‡º */
        }

        /* éšè—åŸç”Ÿçš„ input æ§ä»¶ï¼Œä½†é“ºæ»¡æ•´ä¸ªæŒ‰é’®ä»¥å“åº”ç‚¹å‡» */
        .color-swatch.custom-picker input[type="color"] {
            position: absolute;
            top: 0; left: 0;
            width: 200%; /* æ”¾å¤§ä»¥ç¡®ä¿åœ¨æŸäº›æµè§ˆå™¨ä¸­èƒ½å®Œå…¨è¦†ç›– */
            height: 200%;
            opacity: 0; /* è§†è§‰éšè— */
            cursor: pointer;
            padding: 0;
            margin: -50%;
        }

        /* --- å½©è™¹æŒ‰é’® (å…¥å£) --- */
        .color-swatch.rainbow-entry {
            background: linear-gradient(135deg, #ff3b30, #ff9500, #ffcc00, #4cd964, #5ac8fa, #007aff, #5856d6, #ff2d55);
            position: relative;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }
        .color-swatch.rainbow-entry::after {
            content: '+';
            position: absolute; top:50%; left:50%; transform:translate(-50%, -50%);
            color: white; font-weight: bold; font-size: 16px; text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        /* --- è‡ªå®šä¹‰è°ƒè‰²ç›˜é¢æ¿ (Hidden Panel) --- */
        #cp-custom-panel {
            display: none; /* é»˜è®¤éšè— */
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
            animation: fadeIn 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        /* é¥±å’Œåº¦/äº®åº¦ é€‰å–åŒºåŸŸ (SB Box) */
        .cp-sb-box {
            width: 100%; height: 150px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            position: relative;
            cursor: crosshair;
            /* èƒŒæ™¯è‰²ç”± JS åŠ¨æ€è®¾ç½® (Hue), ä¸Šå±‚è¦†ç›– é¥±å’Œåº¦(ç™½->é€) å’Œ äº®åº¦(é€->é»‘) */
            background-color: #ff0000;
            background-image:
                    linear-gradient(to top, #000, transparent),
                    linear-gradient(to right, #fff, transparent);
            overflow: hidden;
        }

        /* é€‰å–æ‰‹æŸ„ (Circle Handle) */
        .cp-handle {
            width: 12px; height: 12px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€ */
        }

        /* è‰²ç›¸æ¡ (Hue Slider) */
        .cp-hue-slider {
            width: 100%; height: 16px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            position: relative;
            cursor: pointer;
            /* å®Œç¾çš„å½©è™¹æ¸å˜ */
            background: linear-gradient(to right, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%);
        }

        .cp-hue-handle {
            width: 8px; height: 100%;
            background: #fff;
            border: 1px solid rgba(0,0,0,0.2);
            position: absolute;
            top: 0; left: 0;
            transform: translateX(-50%);
            border-radius: 2px;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
            pointer-events: none;
        }

        /* è¿”å›ç½‘æ ¼æŒ‰é’® */
        .btn-back-grid {
            font-size: 10px; color: #aaa; background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1); width: 100%; margin-bottom: 10px;
        }
        .btn-back-grid:hover { background: rgba(255,255,255,0.1); color: #fff; }

        /* éšè—åŸç”Ÿçš„é¢œè‰²è¾“å…¥æ¡† (Hidden Trigger) */
        .color-trigger-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255,255,255,0.05);
            cursor: pointer;
            transition: all 0.2s;
        }
        .color-trigger-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: #fff;
        }

        /* --- æ¡†é€‰çŸ©å½¢ (Holographic Marquee) --- */
        .selection-box {
            position: absolute;
            /* æ›´åŠ é€šé€çš„è“è‰² */
            background: rgba(46, 154, 255, 0.1);
            border: 1px solid rgba(46, 154, 255, 0.5);

            /* å¢åŠ æ¨¡ç³Šï¼Œæ¨¡æ‹Ÿå…¨æ¯æ‰«ææ„Ÿ */
            backdrop-filter: blur(2px);
            /* è¾¹ç¼˜å¾®å…‰ */
            box-shadow: 0 0 10px rgba(46, 154, 255, 0.2);

            pointer-events: none;
            z-index: 999;
            display: none;
            border-radius: 4px;
        }

        /* --- Clip é€‰ä¸­çŠ¶æ€ (High Energy State) --- */
        .clip.selected-clip {
            /* èƒŒæ™¯å˜äº®ä¸”å¸¦æœ‰è“è‰²å€¾å‘ */
            background: rgba(46, 154, 255, 0.4) !important;

            /* è¾¹æ¡†é«˜äº® */
            border-color: #fff !important;

            /* å¼ºçƒˆçš„å‘å…‰æ•ˆæœï¼Œç¡®ä¿åœ¨æ·±è‰²èƒŒæ™¯ä¸‹æ¸…æ™°å¯è§ */
            box-shadow:
                    0 0 0 1px #fff,  /* å†…åœˆé”åˆ©ç™½çº¿ */
                    0 0 20px rgba(46, 154, 255, 0.6) !important; /* å¤–åœˆè“è‰²å…‰æ™• */

            z-index: 10;
            transform: scale(1.01); /* å¾®å¾®æµ®èµ· */
        }

        /* ç¦æ­¢é€‰ä¸­æ–‡å­— */
        #timeline-lanes, #tracks-area, .clip {
            user-select: none;
            -webkit-user-select: none;
        }

        /* ä¿æŒè¾“å…¥æ¡†å¯é€‰ä¸­ */
        input, textarea {
            user-select: text !important;
            -webkit-user-select: text !important;
        }

        /* --- åŠ è½½åŠ¨ç”» (Neon Dot Matrix) --- */
        .loader {
            width: 65px;
            aspect-ratio: 1;
            /* è¿™é‡Œä¿æŒä½ çš„åŠ¨ç”»é€»è¾‘ï¼Œä½†ä¼˜åŒ–é¢œè‰²å˜é‡ */
            --c: #ffffff; /* ç²’å­é¢œè‰² */

            --g: radial-gradient(farthest-side, #0000 calc(95% - 3px), var(--c) calc(100% - 3px) 98%, #0000 101%) no-repeat;
            background: var(--g), var(--g), var(--g);
            background-size: 30px 30px;
            animation: l10 1.5s infinite;

            /* å¢åŠ å‘å…‰æ»¤é•œï¼Œè®©ç²’å­å‘å…‰ */
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.5)) drop-shadow(0 0 10px var(--accent-blue));
        }

        @keyframes l10 {
            0% { background-position: 0 0, 0 100%, 100% 100%; }
            25% { background-position: 100% 0, 0 100%, 100% 100%; }
            50% { background-position: 100% 0, 0 0, 100% 100%; }
            75% { background-position: 100% 0, 0 0, 0 100%; }
            100% { background-position: 100% 100%, 0 0, 0 100%; }
        }

        /* ç¡®ä¿åŠ è½½é®ç½©å±‚å®Œå…¨ä¸é€æ˜ (Seamless Background) */
        #loading {
            /* å¼ºåˆ¶ä½¿ç”¨æ·±è‰²èƒŒæ™¯ï¼Œä¸ body ä¿æŒä¸€è‡´ */
            background: #050507 !important;
            background-image: radial-gradient(circle at 50% -20%, #1c2540 0%, #050507 50%) !important;
            backdrop-filter: blur(20px);
            z-index: 99999; /* ç¡®ä¿æœ€é«˜ */
        }

        @keyframes recordPulse {
            0% { box-shadow: 0 0 5px #ff453a; }
            50% { box-shadow: 0 0 15px #ff453a, inset 0 0 10px #ff453a; }
            100% { box-shadow: 0 0 5px #ff453a; }
        }
        .active-record div {
            animation: recordPulse 1s infinite;
            background: #fff !important; /* æ¿€æ´»æ—¶ä¸­å¿ƒå˜ç™½ */
        }

        /* ========================================= */
        /* ğŸ”¥ ç»ˆæç‰ˆ v3ï¼šLight Mode (å®ä½“è´¨æ„Ÿ & é€»è¾‘ä¿®æ­£) */
        /* ========================================= */

        body.light-mode {
            /* 1. èƒŒæ™¯åŠ æ·±ä¸ºâ€œç™½é‡‘ç°â€ï¼Œå½»åº•å‘Šåˆ«åˆºçœ¼ */
            --bg-color: #dcdce0;
            --text-main: #000000;
            --text-muted: #555555;

            /* ç»ç’ƒé¢æ¿ï¼šä½¿ç”¨åŠé€æ˜çš„ä¹³ç™½è‰² */
            --glass-panel: rgba(255, 255, 255, 0.9);
            --glass-header: #f2f2f7; /* å·¥å…·æ åº•è‰²å¾®ç° */
            --glass-border: rgba(0, 0, 0, 0.1);

            /* å¼ºåˆ¶è¦†ç›–èƒŒæ™¯ */
            background-image: none !important;
            background-color: var(--bg-color) !important;
        }

        /* --- A. é¡¶éƒ¨ Logo --- */
        body.light-mode .logo-text {
            /* æ·±ç°è‰²é‡‘å±æ¸å˜ */
            background: linear-gradient(180deg, #444 20%, #000 100%) !important;
            -webkit-background-clip: text !important;
            background-clip: text !important;
            text-shadow: none !important;
        }
        body.light-mode .title-sub {
            color: #666 !important;
        }

        /* 1. é»˜è®¤æŒ‰é’®ï¼šçº¯ç™½å®ä½“ */
        body.light-mode .btn {
            background: #ffffff !important;
            border: 1px solid #c7c7cc !important;
            color: #1c1c1e !important;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            font-weight: 600;
        }
        body.light-mode .btn:hover {
            background: #f2f2f7 !important;
            border-color: #8e8e93 !important;
            transform: translateY(-1px);
        }
        body.light-mode .btn:active {
            transform: translateY(0);
            box-shadow: none;
        }

        /* 2. æ ¸å¿ƒæ“ä½œ (å¯¼å‡ºè§†é¢‘) - ä¿æŒæ¸å˜ï¼Œå› ä¸ºå®ƒæ˜¯æœ€é‡è¦çš„ */
        body.light-mode .btn-primary {
            background: linear-gradient(135deg, #007aff 0%, #5856d6 100%) !important;
            color: #fff !important;
            border: none !important;
            box-shadow: 0 4px 10px rgba(0, 122, 255, 0.3) !important;
        }
        body.light-mode .btn-primary:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }

        /* 3. è“è‰²åŠŸèƒ½é”® (ä¿å­˜/è¯»å–) - ææ·¡è“åº• + æ·±è“å­— */
        body.light-mode .btn-blue {
            background: rgba(0, 122, 255, 0.1) !important; /* æ·¡è“æœå†»åº• */
            border-color: rgba(0, 122, 255, 0.3) !important;
            color: #007aff !important; /* è‹¹æœè“æ–‡å­— */
        }
        body.light-mode .btn-blue:hover {
            background: rgba(0, 122, 255, 0.2) !important;
            border-color: #007aff !important;
        }

        /* 4. çº¢è‰²å±é™©é”® (åœæ­¢/æ¸…é™¤/å½•éŸ³) - ææ·¡çº¢åº• + æ·±çº¢å­— */
        body.light-mode .btn-red {
            background: rgba(255, 59, 48, 0.1) !important; /* æ·¡çº¢æœå†»åº• */
            border-color: rgba(255, 59, 48, 0.3) !important;
            color: #d70015 !important; /* æ·±çº¢è‰²æ–‡å­—ï¼Œä¿è¯å¯¹æ¯”åº¦ */
        }
        body.light-mode .btn-red:hover {
            background: rgba(255, 59, 48, 0.2) !important;
            border-color: #ff3b30 !important;
        }

        /* 5. æ’­æ”¾æŒ‰é’® (Play) - ç‰¹æ®Šå¤„ç†ç»¿è‰² */
        /* å› ä¸ºä½ çš„ HTML é‡Œ Play æŒ‰é’®ç”¨äº†å†…è”æ ·å¼ï¼Œæˆ‘ä»¬éœ€è¦ç”¨ ID å¼ºåˆ¶è¦†ç›– */
        body.light-mode #playBtn {
            background: rgba(52, 199, 89, 0.15) !important; /* æ·¡ç»¿æœå†»åº• */
            border-color: rgba(52, 199, 89, 0.4) !important;
            color: #008f28 !important; /* æ·±ç»¿è‰²æ–‡å­— */
        }
        body.light-mode #playBtn:hover {
            background: rgba(52, 199, 89, 0.25) !important;
            transform: translateY(-1px);
        }

        /* 6. ç´«è‰²æŒ‰é’® (Accent) */
        body.light-mode .btn-accent {
            background: rgba(175, 82, 222, 0.1) !important;
            border-color: rgba(175, 82, 222, 0.3) !important;
            color: #af52de !important;
        }

        /* --- C. å·¥å…·æ  (Toolbar) --- */
        body.light-mode #toolbar {
            /* æµ…ç°åº•è‰²ï¼Œè¡¬æ‰˜ç™½è‰²æŒ‰é’® */
            background: #f2f2f7 !important;
            border-bottom: 1px solid #d1d1d6 !important;
        }

        /* --- D. è½¨é“å¤´ (é€»è¾‘ä¿®æ­£) --- */
        body.light-mode #track-headers,
        body.light-mode #ruler-header-spacer {
            background: #e5e5ea !important; /* è½¨é“æ§½é¢œè‰² */
            border-right: 1px solid #d1d1d6 !important;
        }

        /* ğŸ”¥ é€»è¾‘åè½¬ï¼šæœªé€‰ä¸­ = çº¯ç™½ (é»˜è®¤) */
        body.light-mode .track-header {
            background: #ffffff !important;
            border-bottom: 1px solid #e5e5ea !important;
            border-top: none !important;
            /* ç»™æœªé€‰ä¸­çš„è½¨é“åŠ ä¸€ä¸ªå¾®å¼±çš„å³è¾¹æ¡†ï¼Œå¢åŠ ç«‹ä½“æ„Ÿ */
            box-shadow: inset -3px 0 0 transparent;
            transition: background 0.1s;
        }
        body.light-mode .track-header:hover {
            background: #fafafa !important;
        }

        /* ğŸ”¥ é€»è¾‘åè½¬ï¼šé€‰ä¸­ = é“¶ç°/æ·¡è“ (æ¿€æ´») */
        body.light-mode .track-header.selected {
            background: #e4e5f0 !important; /* æ˜æ˜¾çš„é€‰ä¸­è‰² */
            /* è“è‰²å·¦ä¾§æŒ‡ç¤ºæ¡ */
            box-shadow: inset 4px 0 0 #007aff !important;
            z-index: 2;
        }

        /* è½¨é“åç§°æ–‡å­— */
        body.light-mode .track-name {
            color: #1c1c1e !important;
            font-weight: 600 !important;
            text-shadow: none !important;
        }

        /* M/S/R å°æŒ‰é’® (å¢å¼ºè¾¨è¯†åº¦) */
        body.light-mode .btn-sm {
            background: #f2f2f7; /* é»˜è®¤æµ…ç° */
            border: 1px solid #d1d1d6;
            color: #666;
            box-shadow: 0 1px 1px rgba(0,0,0,0.05);
        }
        body.light-mode .btn-sm:hover {
            background: #ffffff;
            border-color: #999;
            color: #000;
        }

        /* --- E. ä¸­é—´æ—¶é—´è½´ (Timeline) --- */
        body.light-mode #timeline-lanes {
            /* èƒŒæ™¯æ›´æ·±ï¼Œçªå‡ºè½¨é“ */
            background-color: #dcdce0 !important;
            /* ç½‘æ ¼ç‚¹åŠ æ·± */
            background-image: radial-gradient(#999 1px, transparent 1px) !important;
        }

        /* è½¨é“è¡Œï¼šæŸ”å…‰ç™½ */
        body.light-mode .track-lane {
            background: #fafafa !important; /* ä¸å†æ˜¯åˆºçœ¼çš„çº¯ç™½ */
            border-bottom: 1px solid #d1d1d6 !important;
            border-top: none !important;
        }
        body.light-mode .track-lane:hover {
            background: #ffffff !important;
        }

        /* é€‰ä¸­æ¡† */
        body.light-mode .selection-box {
            background: rgba(0, 122, 255, 0.1);
            border: 1px solid rgba(0, 122, 255, 0.4);
        }

        /* --- F. æ ‡å°º (Ruler) --- */
        body.light-mode #ruler-container {
            background: #f2f2f7 !important;
            border-bottom: 1px solid #d1d1d6 !important;
        }
        body.light-mode #bar-ruler,
        body.light-mode #time-ruler {
            color: #666 !important;
            border-bottom: 1px solid rgba(0,0,0,0.05) !important;
        }
        body.light-mode .ruler-mark {
            border-left: 1px solid #c7c7cc !important;
        }
        body.light-mode .ruler-mark.major {
            color: #000 !important;
            font-weight: 700 !important;
            border-left-color: #888 !important;
        }

        /* --- G. æ‚¬æµ®é¢æ¿ HUD (å®Œç¾å¡ç‰‡ä¿®å¤ç‰ˆ) --- */

        /* 1. å¤–å±‚å®¹å™¨ï¼šä¸è®ºæŠ˜å å±•å¼€ï¼Œéƒ½æ˜¯å®ä½“å¡ç‰‡ */
        body.light-mode #shortcut-overlay,
        body.light-mode #viz-overlay {
            /* æ ¸å¿ƒï¼šå¼ºåˆ¶ç™½åº•ï¼Œä¸å†é€æ˜ */
            background-color: #ffffff !important;

            /* å®ä½“è¾¹æ¡†ï¼Œè®©å®ƒä»èƒŒæ™¯ä¸­ç‹¬ç«‹å‡ºæ¥ */
            border: 1px solid #c7c7cc !important;

            /* è¾ƒæ·±çš„æŠ•å½±ï¼Œå¢åŠ æ‚¬æµ®å±‚æ¬¡æ„Ÿ */
            box-shadow: 0 8px 30px rgba(0,0,0,0.15) !important;

            color: #1d1d1f !important;
            border-radius: 10px !important;

            /* ç§»é™¤å†…è”æ ·å¼å¯èƒ½çš„å¹²æ‰° */
            backdrop-filter: none !important;
        }

        /* 2. æ ‡é¢˜æ ï¼šæµ…ç°èƒŒæ™¯ï¼Œå½¢æˆåŒºåˆ† */
        body.light-mode #shortcut-header,
        body.light-mode #viz-header {
            color: #000000 !important;
            font-weight: 700 !important;

            /* æµ…ç°è‰²èƒŒæ™¯ï¼Œåƒ macOS çª—å£æ ‡é¢˜æ  */
            background-color: #f2f2f7 !important;

            border-bottom: 1px solid #e5e5ea !important;

            /* ä¿®æ­£è¾¹è·ï¼Œè®©èƒŒæ™¯é“ºæ»¡é¡¶éƒ¨åœ†è§’ */
            margin: -14px -14px 10px -14px !important;
            padding: 10px 14px !important;
            border-radius: 10px 10px 0 0 !important;
        }

        /* 3. å†…å®¹åŒºåŸŸæ–‡å­—ä¿®å¤ */
        body.light-mode #shortcut-content,
        body.light-mode #viz-content {
            /* ç¨å¾®å¢åŠ ä¸€ç‚¹åº•éƒ¨å†…è¾¹è·ï¼Œæ›´ç¾è§‚ */
            padding-bottom: 4px;
        }

        /* é€šç”¨æ–‡å­—å˜æ·±ç° */
        body.light-mode #shortcut-content span,
        body.light-mode #viz-content span {
            color: #1d1d1f;
            text-shadow: none !important;
        }

        /* å·¦ä¾§è¯´æ˜æ ‡ç­¾ (Label) -> ä¸­ç° */
        body.light-mode span[style*="color:#aaa"],
        body.light-mode span[style*="color:#888"] {
            color: #6e6e73 !important;
            font-weight: 500 !important;
        }

        /* --- 4. å¿«æ·é”®é«˜äº®è‰²ä¿®æ­£ (æ·±è‰²åŒ–é€‚é…ç™½åº•) --- */

        /* ç»¿è‰² (Space / S / M) */
        body.light-mode span[style*="color:#30d158"],
        body.light-mode span[style*="color:#30D158"] {
            color: #008f28 !important; /* æ·±ç»¿ */
            background: rgba(0, 143, 40, 0.1); /* å¢åŠ æ·¡æ·¡çš„èƒŒæ™¯å— */
            padding: 2px 4px;
            border-radius: 4px;
        }

        /* çº¢è‰² (Del) */
        body.light-mode span[style*="color:#ff453a"],
        body.light-mode span[style*="color:#ff6b6b"] {
            color: #d70015 !important; /* æ·±çº¢ */
        }

        /* è“è‰² (Ctrl+Z) */
        body.light-mode span[style*="color:#0a84ff"],
        body.light-mode span[style*="color:#5e5ce6"] {
            color: #0062cc !important; /* æ·±è“ */
        }

        /* é»„è‰² (Save) */
        body.light-mode span[style*="color:#ffd60a"] {
            color: #b36b00 !important; /* æ·±ç¥ç€è‰² */
        }

        /* ç´«è‰² (View) */
        body.light-mode span[style*="color:#bf5af2"] {
            color: #9c27b0 !important; /* æ·±ç´« */
        }

        /* æ•°å€¼é«˜äº® */
        body.light-mode span[style*="color:#fff"] {
            color: #000000 !important;
            font-weight: 800;
        }

        /* --- H. åº•éƒ¨æ§åˆ¶æ  --- */
        body.light-mode #bottom-controls {
            background: #f2f2f7 !important;
            border-top: 1px solid #d1d1d6 !important;
        }
        body.light-mode .slider-group {
            color: #333 !important;
        }
        body.light-mode .slider-group span[style*="color:#fff"] {
            color: #007aff !important;
        }

        /* è¾“å…¥æ§ä»¶å®ä½“åŒ– */
        body.light-mode select,
        body.light-mode input[type="text"],
        body.light-mode input[type="number"] {
            background-color: #ffffff !important;
            color: #000 !important;
            border: 1px solid #c7c7cc !important;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.05) !important;
        }

        /* æ»‘å— */
        body.light-mode input[type=range]::-webkit-slider-runnable-track {
            background: #d1d1d6 !important;
            border: none !important;
        }
        body.light-mode input[type=range]::-webkit-slider-thumb {
            background: #ffffff !important;
            border: 1px solid #888 !important;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2) !important;
        }

        /* 1. å¼¹çª—å®¹å™¨ï¼šçº¯ç™½å¡ç‰‡ï¼Œå»é™¤è„æ„Ÿ */
        body.light-mode .modal-content,
        body.light-mode #context-menu {
            background-color: #ffffff !important;
            border: 1px solid #d1d1d6 !important;
            /* ä½¿ç”¨æŸ”å’Œçš„æ·±è‰²æ‰©æ•£é˜´å½±ï¼Œå¢åŠ æµ®èµ·æ„Ÿ */
            box-shadow: 0 20px 50px rgba(0,0,0,0.15), 0 0 0 1px rgba(0,0,0,0.05) !important;
            color: #1d1d1f !important;
            backdrop-filter: none !important; /* ç§»é™¤æ¨¡ç³Šï¼Œä¿è¯é”åˆ© */
        }

        /* 2. æ ‡é¢˜ä¿®å¤ */
        body.light-mode .modal-content h3 {
            color: #000000 !important;
            border-bottom: 1px solid #e5e5ea !important;
            text-shadow: none !important; /* å»é™¤å‘å…‰ */
        }

        /* æ ‡é¢˜ä¸­çš„ Logo æ–‡å­— (é’ˆå¯¹ç‰ˆæœ¬å¼¹çª—) */
        body.light-mode .modal-content h3 span[style*="gradient"] {
            /* å¼ºåˆ¶æ”¹ä¸ºæ·±ç°è‰²é‡‘å±æ¸å˜ */
            background: linear-gradient(180deg, #444 20%, #000 100%) !important;
            -webkit-background-clip: text !important;
            background-clip: text !important;
            text-shadow: none !important;
        }

        /* 3. è¾“å…¥æ¡†ä¸ä¸‹æ‹‰å•ï¼šæµ…ç°åº•è‰² */
        body.light-mode .form-group input,
        body.light-mode .form-group select,
        body.light-mode #project-name-input {
            background-color: #f2f2f7 !important; /* è‹¹æœæµ…ç° */
            border: 1px solid #d1d1d6 !important;
            color: #1d1d1f !important;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.03) !important; /* ææ·¡çš„å†…é˜´å½± */
        }

        body.light-mode .form-group input:focus,
        body.light-mode .form-group select:focus {
            background-color: #ffffff !important; /* èšç„¦å˜ç™½ */
            border-color: #007aff !important;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.15) !important;
        }

        /* 4. æ ‡ç­¾æ–‡å­— (Label) */
        body.light-mode .form-group label,
        body.light-mode p {
            color: #636366 !important;
            font-weight: 600 !important;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* 5. ç‰ˆæœ¬æ›´æ–°åˆ—è¡¨ä¿®å¤ */
        body.light-mode .modal-content ul {
            color: #333 !important;
        }
        body.light-mode .modal-content li {
            color: #1d1d1f !important;
        }
        /* åˆ—è¡¨å®¹å™¨èƒŒæ™¯ */
        body.light-mode .modal-content div[style*="overflow-y"] {
            background-color: #f9f9f9 !important; /* æµ…ç°åº• */
            border: 1px solid #e5e5ea !important;
        }
        /* åˆ—è¡¨å†…çš„å°æ ‡é¢˜ */
        body.light-mode .modal-content p[style*="font-weight: 700"] {
            color: #000 !important;
        }
        /* åˆ—è¡¨å†…çš„è¾…åŠ©è¯´æ˜ */
        body.light-mode .modal-content ul li[style*="color: #888"] {
            color: #666 !important;
        }

        /* 6. è§†è§’å‚æ•° (Param Box) ç‰¹æ®Šä¿®å¤ */
        body.light-mode .param-box {
            background-color: #f2f2f7 !important;
            border: 1px solid #d1d1d6 !important;
            box-shadow: none !important;
        }
        body.light-mode .param-label {
            color: #86868b !important;
        }
        body.light-mode .param-input {
            color: #000000 !important;
            text-shadow: none !important;
            font-weight: 700 !important;
        }
        body.light-mode .param-box:focus-within {
            background-color: #ffffff !important;
            border-color: #007aff !important;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.15) !important;
        }
        body.light-mode .param-box:focus-within .param-label {
            color: #007aff !important;
        }

        /* 7. æ¨¡å‹é¢„è§ˆçª—å£ (Model Preview) */
        body.light-mode #model-preview-modal .modal-content {
            background-color: #ffffff !important;
        }
        body.light-mode .control-group label {
            color: #666 !important;
        }
        /* é¢„è§ˆçª—å£å³ä¾§æ§åˆ¶æ  */
        body.light-mode #model-preview-modal .modal-content > div:last-child {
            background-color: #f9f9f9 !important;
            border-left: 1px solid #e5e5ea !important;
        }
        /* æ ‡é¢˜æ  */
        body.light-mode #model-preview-modal .modal-content > div:first-child {
            background-color: #f2f2f7 !important;
            border-bottom: 1px solid #d1d1d6 !important;
        }
        body.light-mode #model-preview-modal h3 {
            color: #000 !important;
            border: none !important;
        }

    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@tonejs/midi": "https://esm.sh/@tonejs/midi"
            }
        }
    </script>
    <script>
        window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
    </script>
    <script defer src="/_vercel/insights/script.js"></script>
</head>
<body>

<div id="context-menu">
    <div class="menu-item" id="menu-group">ç¼–ç»„é€‰ä¸­è½¨é“</div>
    <div class="menu-item" id="menu-ungroup">è§£æ•£ç¼–ç»„</div>
    <div class="menu-separator"></div>
    <div class="menu-item" id="menu-color">
        è®¾ç½®ç¼–ç»„é¢œè‰²
    </div>
</div>

<div id="loading" style="display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; justify-content: center; align-items: center;">
    <div class="loader"></div>
</div>

<div id="export-modal" style="display:none;">
    <div class="modal-content">
        <h3>å¯¼å‡ºè§†é¢‘è®¾ç½®ï¼ˆå®é™…å¸§ç‡å—æ€§èƒ½å½±å“ï¼‰</h3>

        <div class="form-group">
            <label>ç”»é¢æ¯”ä¾‹ (Aspect Ratio)</label>
            <select id="exportRatio">
                <option value="1.7777">16:9 (æ¨ªå±)</option>
                <option value="0.5625">9:16 (ç«–å± Shorts/TikTok)</option>
                <option value="1.3333">4:3</option>
                <option value="1.0">1:1 (Square)</option>
            </select>
        </div>

        <div class="form-group">
            <label>åˆ†è¾¨ç‡ (Resolution)</label>
            <select id="exportRes">
                <option value="720">720p (HD)</option>
                <option value="1080">1080p (FHD)</option>
                <option value="1440">1440p (QHD)</option>
                <option value="2160">4K (UHD)</option>
            </select>
        </div>

        <div class="form-group">
            <label>å¸§ç‡ (FPS)</label>
            <select id="exportFps">
                <option value="30">30 FPS</option>
                <option value="60" selected>60 FPS</option>
            </select>
        </div>

        <div class="form-group">
            <label>æ ¼å¼ (Format)</label>
            <select id="exportFormat">
            </select>
        </div>

        <div class="modal-buttons">
            <button class="btn" id="cancelExportBtn">å–æ¶ˆ</button>
            <button class="btn btn-primary" id="startExportBtn">å¼€å§‹å½•åˆ¶</button>
        </div>
        <p style="font-size:10px; color:#aaa; margin-top:10px;">
            æ³¨æ„ï¼šå½•åˆ¶æœŸé—´è¯·å‹¿åˆ‡æ¢æ ‡ç­¾é¡µï¼Œè¿™é€šè¿‡å®æ—¶å½•å±å®ç°ã€‚
        </p>
    </div>
</div>

<div id="save-project-modal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 3000; justify-content: center; align-items: center;">
    <div class="modal-content" style="background: #2a2a2a; padding: 20px; border-radius: 8px; width: 300px; border: 1px solid #444;">
        <h3 style="margin-top:0;">ä¿å­˜å·¥ç¨‹</h3>
        <div class="form-group">
            <label>å·¥ç¨‹åç§°</label>
            <input type="text" id="project-name-input" placeholder="è¾“å…¥åç§°..." style="width: 100%; background: #111; color: #fff; border: 1px solid #444; padding: 8px; border-radius: 4px; box-sizing: border-box;">
        </div>
        <div class="modal-buttons" style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
            <button class="btn" id="cancelSaveBtn">å–æ¶ˆ</button>
            <button class="btn btn-primary" id="confirmSaveBtn">ä¸‹è½½ JSON</button>
        </div>
    </div>
</div>

<div id="recording-status" style="display:none;">
    <div style="background:red; width:10px; height:10px; border-radius:50%; margin-right:10px; animation: blink 1s infinite;"></div>
    <span id="rec-time">00:00</span> / <span id="rec-total">00:00</span>
    <button class="btn" id="stopRecBtn" style="margin-left:15px; background:#333;">åœæ­¢</button>
</div>

<div id="daw-container">
    <div id="toolbar">
        <div id="app-logo" title="ç‚¹å‡»æŸ¥çœ‹ç‰ˆæœ¬æ›´æ–°">
            <div class="logo-wrapper">
                <span class="logo-text title-main">MIDI</span>
                <span class="logo-text title-sub">Visualizer</span>
            </div>
            <span class="version-tag">v2.2.0</span>
        </div>

        <div class="toolbar-separator"></div>

        <button class="btn btn-blue" id="playBtn" style="border-color: rgba(48, 209, 88, 0.4); background: rgba(48, 209, 88, 0.1); color: #30d158;">
            PLAY
        </button>
        <button class="btn btn-red" id="stopBtn">STOP</button>

        <button class="btn btn-red" id="recordBtn" style="width: 32px; padding: 0;" title="MIDI Record">
            <div style="width: 12px; height: 12px; background: #ff453a; border-radius: 50%; box-shadow: 0 0 5px #ff453a;"></div>
        </button>

        <div class="toolbar-separator"></div>

        <button class="btn btn-primary" id="showExportBtn">âœ¨ å¯¼å‡ºè§†é¢‘</button>

        <div class="toolbar-separator"></div>

        <button class="btn btn-blue" id="saveProjectBtn">ä¿å­˜å·¥ç¨‹</button>
        <button class="btn btn-blue" id="loadProjectBtn">è¯»å–å·¥ç¨‹</button>
        <input type="file" id="projectInput" accept=".json" style="display:none">

        <div class="toolbar-separator"></div>

        <button class="btn" id="btn-midi">å¯¼å…¥ MIDI</button>
        <input type="file" id="midiInput" accept=".mid,.midi" style="display:none">

        <button class="btn" id="btn-audio">å¯¼å…¥ Audio</button>
        <input type="file" id="audioInput" accept="audio/*" style="display:none">

        <div class="toolbar-separator"></div>

        <button class="btn btn-accent" id="btn-bg">è®¾ç½®èƒŒæ™¯</button>
        <input type="file" id="bgInput" accept="image/*,video/*" style="display:none">

        <button class="btn" id="bgSettingsBtn" style="padding: 0 8px;" title="èƒŒæ™¯å‚æ•°è®¾ç½®">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
        </button>

        <button class="btn btn-accent" id="btn-highlight-color" style="display: flex; align-items: center; gap: 6px;">
            é«˜å…‰æ ·å¼
        </button>

        <button class="btn" id="viewSettingsBtn">è§†è§’å‚æ•°</button>

        <button class="btn btn-red" id="clearTextureBtn" style="font-size:11px; padding: 4px 8px; height: 26px;">æ¸…é™¤</button>
    </div>

    <div id="ruler-container">
        <div id="ruler-header-spacer">
            <button id="addTrackBtn" title="æ·»åŠ æ–°è½¨é“">+ æ–°å»ºè½¨é“</button>
        </div>

        <div id="ruler-content">
            <div id="ruler-playhead"></div>
            <div id="bar-ruler"></div>
            <div id="time-ruler"></div>
        </div>
    </div>

    <div id="tracks-area">
        <div id="track-headers"></div>

        <div id="timeline-lanes">
            <div id="lanes-container">
                <div class="grid-lines" id="gridLines"></div>
                <div id="ui-playhead"></div>
            </div>
        </div>
    </div>
</div>

<div id="resize-handle">
    <div class="handle-bar"></div>
</div>

<div id="visualizer-section">
    <div id="canvas-wrapper">
        <div id="shortcut-overlay" style="
            position: absolute;
            top: 16px;
            left: 20px; /* ğŸ“ è¿™é‡Œè®¾ä¸º leftï¼Œä¸å³è¾¹çš„ right:20px å¯¹ç§° */
            background: rgba(0,0,0,0.7);
            padding: 14px;
            border-radius: 8px;
            backdrop-filter: blur(8px);
            pointer-events: none; /* è®©é¼ æ ‡ç©¿é€ï¼Œä¸å½±å“æ“ä½œ */
            border: 1px solid rgba(255,255,255,0.1);
            font-family: 'SF Mono', 'Menlo', monospace;
            font-size: 11px;
            line-height: 1.6;
            color: #ddd;
            z-index: 100;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        ">
            <div id="shortcut-header" style="font-weight:700; color:#fff; border-bottom:1px solid rgba(255,255,255,0.2); margin-bottom:8px; padding-bottom:4px; cursor: pointer; pointer-events: auto;">
                å¿«æ·é”®æŒ‡å—ï¼ˆç‚¹å‡»æŠ˜å ï¼‰
            </div>

            <div id="shortcut-content" style="display: grid; grid-template-columns: 1fr auto; gap: 4px 20px;">
                <span style="color:#aaa;">æ’­æ”¾ / æš‚åœ</span>      <span style="color:#30d158; font-weight:700;">Space</span>
                <span style="color:#aaa;">Solo / Mute</span>      <span style="color:#30d158; font-weight:700;">S / M</span>
                <span style="color:#aaa;">åˆ é™¤è½¨é“</span>        <span style="color:#ff453a;">Del / Backspace</span>
                <span style="color:#aaa;">æ’¤é”€æ“ä½œ</span>        <span style="color:#0a84ff;">Ctrl/Cmd + Z</span>
                <span style="color:#aaa;">é‡åšæ“ä½œ</span>        <span style="color:#0a84ff;">Ctrl/Cmd + Shift + Y</span>
                <span style="color:#aaa;">ä¿å­˜å·¥ç¨‹</span>        <span style="color:#ffd60a;">Ctrl/Cmd + S</span>
                <span style="color:#aaa;">å¦å­˜å·¥ç¨‹</span>        <span style="color:#ffd60a;">Ctrl/Cmd + Shift + S</span>

                <div style="grid-column: span 2; height:1px; background:rgba(255,255,255,0.1); margin:4px 0;"></div>

                <span style="color:#aaa;">è§†è§’å¹³ç§»</span>        <span style="color:#bf5af2;">Ctrl/Cmd + æ‹–æ‹½</span>
                <span style="color:#aaa;">è§†è§’é‡ç½®</span>        <span style="color:#bf5af2;">Ctrl/Cmd + åŒå‡»</span>
                <span style="color:#aaa;">å…¨é€‰äº‹ä»¶</span>      <span>Ctrl/Cmd + A</span>
                <span style="color:#aaa;">å¤šé€‰ / è¿é€‰</span>      <span>Ctrl / Shift</span>
            </div>
        </div>

        <div id="viz-overlay" style="
    position: absolute;
    top: 16px;
    right: 20px;
    background: rgba(0,0,0,0.7); /* ç¨å¾®åŠ æ·±èƒŒæ™¯æé«˜å¯¹æ¯”åº¦ */
    padding: 14px;
    border-radius: 8px;
    backdrop-filter: blur(8px);
    pointer-events: none;
    border: 1px solid rgba(255,255,255,0.1);
    font-family: 'SF Mono', 'Menlo', monospace;
    font-size: 11px;
    line-height: 1.8; /* å¢åŠ è¡Œé«˜ï¼Œå‚ç›´æ’åˆ—ä¸æ‹¥æŒ¤ */
    color: #ddd;
    min-width: 160px; /* ç¨å¾®å˜çª„ï¼Œå› ä¸ºä¸éœ€è¦æ¨ªå‘æ’å¸ƒäº† */
    z-index: 100;
    text-shadow: 0 1px 2px rgba(0,0,0,0.8);
">
            <div id="viz-header" style="font-weight:700; color:#fff; border-bottom:1px solid rgba(255,255,255,0.2); margin-bottom:8px; padding-bottom:4px; display:flex; justify-content:space-between; cursor: pointer; pointer-events: auto;">
                <span>è§†è§’å‚æ•°ï¼ˆç‚¹å‡»æŠ˜å ï¼‰</span>
                <span style="color:#0a84ff;">â— å®æ—¶</span>
            </div>

            <div id="viz-content">

                <div style="display:flex; justify-content:space-between;">
                    <span style="color:#aaa;">ç›¸æœºè·ç¦» (Zoom)</span>
                    <span id="hud-radius" style="color:#fff; font-weight:bold;">--</span>
                </div>

                <div style="margin:6px 0; border-top:1px dashed rgba(255,255,255,0.1);"></div>

                <div style="color:#0a84ff; font-weight:600; margin-bottom:2px;">è§†è§’æ—‹è½¬ (Rotation)</div>
                <div style="display:flex; justify-content:space-between; padding-left:8px;">
                    <span style="color:#888;">æ°´å¹³ (Î¸)</span>
                    <span id="hud-theta" style="color:#ff6b6b;">0Â°</span>
                </div>
                <div style="display:flex; justify-content:space-between; padding-left:8px;">
                    <span style="color:#888;">å‚ç›´ (Ï†)</span>
                    <span id="hud-phi" style="color:#30d158;">0Â°</span>
                </div>

                <div style="margin:6px 0; border-top:1px dashed rgba(255,255,255,0.1);"></div>

                <div style="color:#30d158; font-weight:600; margin-bottom:2px;">è§†è§’å¹³ç§» (Panning)</div>
                <div style="display:flex; justify-content:space-between; padding-left:8px;">
                    <span style="color:#888;">X å¹³ç§»</span>
                    <span id="hud-pan-x" style="color:#5e5ce6;">0</span>
                </div>
                <div style="display:flex; justify-content:space-between; padding-left:8px;">
                    <span style="color:#888;">Y å¹³ç§»</span>
                    <span id="hud-pan-y" style="color:#5e5ce6;">0</span>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="bottom-controls">

    <div class="slider-group">
        <span>W-Scale: <span id="val-sceneZoom" style="color:#fff; margin-left:2px;">20</span></span>
        <input type="range" id="sceneZoom" min="1" max="100" value="20">
    </div>

    <div class="slider-group">
        <span>H-Scale: <span id="val-height" style="color:#fff; margin-left:2px;">1.5</span></span>
        <input type="range" id="heightSlider" min="1" max="600" value="150">
    </div>

    <div class="slider-group">
        <span>Thickness: <span id="val-thickness" style="color:#fff; margin-left:2px;">1.0</span></span>
        <input type="range" id="thicknessSlider" min="1" max="300" value="100">
    </div>

    <div class="slider-group">
        <span>Z-Space: <span id="val-zSpace" style="color:#fff; margin-left:2px;">0.5</span></span>
        <input type="range" id="zSpaceSlider" min="0" max="200" value="5">
    </div>

    <div class="slider-group" style="margin-left: 15px; border-left: 1px solid rgba(255,255,255,0.1); padding-left: 15px;">
        <span>Stars:</span>
        <label class="ios-switch" title="æ˜¾ç¤º/éšè—æ˜Ÿç©º">
            <input type="checkbox" id="starfieldToggle" checked>
            <span class="slider"></span>
        </label>
    </div>

    <div class="slider-group" style="margin-left: 15px;">
        <span>Realtime Fade:</span> <label class="ios-switch" title="å¼€å¯åï¼ŒéŸ³ç¬¦å°†éšæ’­æ”¾è¿›åº¦é€æ¸æ˜¾ç°">
        <input type="checkbox" id="midiFadeToggle" checked>
        <span class="slider"></span>
    </label>
    </div>

    <div class="slider-group">
        <span>Shape:</span>
        <select id="noteShapeSelect" style="background:#333; color:#fff; border:1px solid #555; border-radius:3px; padding:2px; max-width: 100px;">
            <option value="capsule" selected>Capsule (Default)</option>
            <option value="box">Box (Cube)</option>
            <option value="box-line">Box (Outlined)</option>
            <option value="cylinder">Cylinder</option>
            <option value="diamond">Diamond</option>
            <option value="hexagon">Hexagon</option>
            <option value="torus">Donut (Torus)</option>
            <option value="knot">Torus Knot</option>
            <option value="cone">Cone (Spike)</option>
            <option value="custom">Custom (.glb)...</option>
        </select>

        <input type="file" id="customModelInput" accept=".glb,.gltf" style="display: none;">
    </div>

    <button id="resetViewBtn" class="btn" style="margin-left: 15px; height: 24px; line-height: 1;">â†º é‡ç½®å‚æ•°</button>
</div>

<div id="bg-settings-modal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 3000; justify-content: center; align-items: center;">
    <div class="modal-content" style="background: #2a2a2a; padding: 20px; border-radius: 8px; width: 320px; border: 1px solid #444; box-shadow: 0 0 20px rgba(0,0,0,0.8);">
        <h3 style="margin-top:0; border-bottom:1px solid #444; padding-bottom:10px;">èƒŒæ™¯å‚æ•°è®¾ç½®</h3>

        <div class="form-group" style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; margin-bottom: 15px;">
            <label style="margin-bottom: 8px; display:block;">èƒŒæ™¯ä¸»é¢˜ (Background Theme)</label>
            <div style="display: flex; gap: 10px;">
                <button class="btn btn-primary" id="bg-mode-dark" style="flex: 1;">é»‘è‰² (é»˜è®¤)</button>
                <button class="btn" id="bg-mode-white" style="flex: 1; background: #e5e5e5; color: #333; text-shadow:none;">ç™½è‰²</button>
            </div>
        </div>

        <div class="form-group">
            <label>ä¸é€æ˜åº¦ (Opacity): <span id="val-opacity">1.0</span></label>
            <input type="range" id="bg-opacity" min="0" max="1" step="0.05" value="0.6" style="width:100%">
        </div>

        <div class="form-group" style="margin-bottom: 15px;">
            <label>æ¨¡ç³Šåº¦ (Blur): <span id="val-blur">0px</span></label>
            <input type="range" id="bg-blur" min="0" max="20" step="1" value="0" style="width:100%">
        </div>

        <div class="form-group" style="margin-bottom: 15px;">
            <label>äº®åº¦ (Brightness): <span id="val-bright">100%</span></label>
            <input type="range" id="bg-brightness" min="0" max="200" step="5" value="100" style="width:100%">
        </div>

        <div class="form-group" style="margin-bottom: 15px;">
            <label>å¯¹æ¯”åº¦ (Contrast): <span id="val-contrast">100%</span></label>
            <input type="range" id="bg-contrast" min="0" max="200" step="5" value="100" style="width:100%">
        </div>

        <div class="form-group" style="margin-bottom: 15px;">
            <label>å¡«å……æ¨¡å¼ (Fit Mode)</label>
            <select id="bg-fit" style="width:100%; padding:5px; background:#111; color:#fff; border:1px solid #555;">
                <option value="cover">Cover (é“ºæ»¡è£å‰ª)</option>
                <option value="contain">Contain (å®Œæ•´æ˜¾ç¤º)</option>
                <option value="fill">Fill (æ‹‰ä¼¸é“ºæ»¡)</option>
            </select>
        </div>

        <div class="modal-buttons" style="margin-top: 20px;">
            <button class="btn btn-primary" id="closeBgSettingsBtn" style="width:100%">å…³é—­</button>
        </div>
    </div>
</div>

<div id="view-settings-modal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 3500; justify-content: center; align-items: center;">
    <div class="modal-content" style="background: #1c1c1e; padding: 24px; border-radius: 16px; width: 360px; border: 1px solid #333; box-shadow: 0 20px 60px rgba(0,0,0,0.8);">

        <h3 style="margin-top:0; margin-bottom:20px; color:#fff; font-size:16px; font-weight:600; text-align:center;">è§†è§’å‚æ•° (Spherical)</h3>

        <div class="param-box">
            <span class="param-label" style="color:#aaa;">ç›¸æœºè·ç¦» (Distance / Zoom)</span>
            <input type="number" id="cam-radius" class="param-input" step="1">
        </div>

        <div style="height:1px; background:#333; margin:20px 0;"></div>

        <div style="font-size:11px; color:#aaa; margin-bottom:8px; font-weight:600;">è§†è§’æ—‹è½¬ (Rotation)</div>
        <div style="display:flex; gap:12px;">
            <div class="param-box" style="flex:1;">
                <span class="param-label">æ°´å¹³æ—‹è½¬ (Horz Â°)</span>
                <input type="number" id="cam-theta" class="param-input" step="1">
            </div>

            <div class="param-box" style="flex:1;">
                <span class="param-label">å‚ç›´æ—‹è½¬ (Vert Â°)</span>
                <input type="number" id="cam-phi" class="param-input" step="1">
            </div>
        </div>

        <div style="height:1px; background:#333; margin:20px 0;"></div>

        <div style="font-size:11px; color:#aaa; margin-bottom:8px; font-weight:600;">è§†è§’å¹³ç§» (Panning)</div>
        <div style="display:flex; gap:12px;">
            <div class="param-box" style="flex:1;">
                <span class="param-label">X è½´åç§»</span>
                <input type="number" id="target-off-x" class="param-input" step="1" value="0">
            </div>
            <div class="param-box" style="flex:1;">
                <span class="param-label">Y è½´åç§»</span>
                <input type="number" id="target-off-y" class="param-input" step="1" value="0">
            </div>
        </div>

        <div style="display:flex; gap:12px; margin-top:12px;">
            <button class="btn" id="exportViewBtn" style="flex:1; background:rgba(255,255,255,0.1); font-size:11px; border:1px solid rgba(255,255,255,0.1);">â¬‡ å¯¼å‡ºé¢„è®¾</button>
            <button class="btn" id="importViewBtn" style="flex:1; background:rgba(255,255,255,0.1); font-size:11px; border:1px solid rgba(255,255,255,0.1);">â¬† å¯¼å…¥é¢„è®¾</button>
            <input type="file" id="viewParamInput" accept=".json" style="display:none">
        </div>

        <button class="btn" id="closeViewSettingsBtn" style="width:100%; margin-top:12px; background:transparent; border:1px solid #333; color:#888;">å…³é—­</button>
    </div>
</div>

<div id="model-preview-modal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 4000; justify-content: center; align-items: center;">
    <div class="modal-content" style="width: 800px; height: 600px; display: flex; flex-direction: column; background: #1e1e1e; padding: 0; overflow: hidden;">

        <div style="padding: 15px; background: #252525; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin:0; color: #ddd;">å¯¼å…¥æ¨¡å‹é¢„è§ˆ / è°ƒæ•´æ–¹å‘</h3>
            <span style="font-size: 12px; color: #888;">çº¢è‰²=Xè½´ (æ‹‰ä¼¸æ–¹å‘) | ç»¿è‰²=Yè½´ | è“è‰²=Zè½´</span>
        </div>

        <div style="flex: 1; display: flex; overflow: hidden;">

            <div id="preview-canvas-container" style="flex: 2; background: #111; position: relative;">
                <div style="position: absolute; bottom: 10px; left: 10px; color: rgba(255,255,255,0.5); font-size: 12px; pointer-events: none;">
                    å·¦ä¾§ï¼šåŸå§‹æ¨¡å‹ <br> å³ä¾§ï¼šæ¨¡æ‹Ÿ MIDI æ‹‰ä¼¸æ•ˆæœ
                </div>
            </div>

            <div style="flex: 1; min-width: 250px; background: #2a2a2a; padding: 20px; border-left: 1px solid #333; display: flex; flex-direction: column; gap: 20px;">

                <div class="control-group">
                    <label style="color: #aaa; font-size: 12px; display: block; margin-bottom: 5px;">æ—‹è½¬ X (Rotate X)</label>
                    <input type="range" id="rot-x" min="0" max="360" value="0" style="width: 100%;">
                </div>
                <div class="control-group">
                    <label style="color: #aaa; font-size: 12px; display: block; margin-bottom: 5px;">æ—‹è½¬ Y (Rotate Y)</label>
                    <input type="range" id="rot-y" min="0" max="360" value="0" style="width: 100%;">
                </div>
                <div class="control-group">
                    <label style="color: #aaa; font-size: 12px; display: block; margin-bottom: 5px;">æ—‹è½¬ Z (Rotate Z)</label>
                    <input type="range" id="rot-z" min="0" max="360" value="0" style="width: 100%;">
                </div>

                <div style="height: 1px; background: #444; margin: 10px 0;"></div>

                <div class="control-group">
                    <label style="color: #aaa; font-size: 12px; display: block; margin-bottom: 5px;">é¢„è§ˆé¢œè‰²</label>
                    <label style="display: flex; align-items: center; color: #fff; font-size: 12px;">
                        <input type="checkbox" id="preview-use-texture" disabled>
                        ä¿ç•™åŸæè´¨ (æš‚ä¸æ”¯æŒ Shader æ‹‰ä¼¸)
                    </label>
                    <p style="font-size: 10px; color: #666; margin-top: 5px;">
                        * å½“å‰é«˜æ€§èƒ½æ¸²æŸ“ç®¡çº¿å¼ºåˆ¶ä½¿ç”¨è½¨é“é¢œè‰²ã€‚
                    </p>
                </div>

                <div style="flex: 1;"></div> <div style="display: flex; gap: 10px;">
                <button class="btn" id="cancelPreviewBtn" style="flex: 1;">å–æ¶ˆ</button>
                <button class="btn btn-primary" id="confirmImportBtn" style="flex: 1;">ç¡®è®¤å¯¼å…¥</button>
            </div>
            </div>
        </div>
    </div>
</div>

<div id="version-modal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 6000; justify-content: center; align-items: center;">
    <div class="modal-content" style="width: 400px !important;">
        <h3 style="border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 15px; margin-top: 0;">
            <span style="
                font-family: 'Chango', sans-serif;
                font-weight: 400;
                letter-spacing: 1px;
                background: linear-gradient(to bottom, #ffffff 30%, #9ca3af 100%);
                -webkit-background-clip: text;
                background-clip: text;
                color: transparent;
            ">
                MIDI Visualizer
            </span>

            <span style="
                background: #0a84ff; /* æ ¸å¿ƒï¼šLogo åŒæ¬¾è“è‰² */
                color: white;
                padding: 2px 6px;    /* ç¨å¾®æ¯” Logo å¤„å¤§ä¸€ç‚¹ç‚¹ä»¥é€‚é…å¼¹çª— */
                border-radius: 4px;
                font-weight: 600;
                font-size: 11px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                text-shadow: none;   /* å»æ‰å¯èƒ½çš„æ–‡å­—é˜´å½± */
                line-height: 1.2;
            ">
                v2.2.0
            </span>
        </h3>

        <div style="height: 250px; overflow-y: auto; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; margin-bottom: 20px;">
            <p style="color: #fff; font-weight: 700; font-size: 13px; margin-top: 0; border-left: 3px solid #ff453a; padding-left: 8px;">
                2026-02-02 v2.2.0 (Performance Hotfix)
            </p>
            <ul style="padding-left: 20px; color: #ddd; line-height: 1.6; margin-bottom: 20px;">
                <li>æ–°å¢ï¼šç™½è‰²èƒŒæ™¯</li>
                <li>ä¼˜åŒ–ï¼šç§»é™¤å…¨å±€ç›¸æœºé˜»å°¼ (Damping)ï¼Œå½»åº•è§£å†³æ’­æ”¾æ—¶çš„ç”»é¢æŠ½åŠ¨ä¸æ‰å¸§æ„Ÿï¼Œå®ç°ä¸æ»‘ç§»åŠ¨ã€‚</li>
                <li>ä¼˜åŒ–ï¼šæ¨¡å‹é¢„è§ˆçª—å£å…³é—­é˜»å°¼ï¼Œæå‡è‡ªå®šä¹‰æ¨¡å‹é¢„è§ˆæ—¶çš„æ“ä½œæµç•…åº¦ã€‚</li>
            </ul>

            <div style="height:1px; background:rgba(255,255,255,0.1); margin: 15px 0;"></div>

            <p style="color: #aaa; font-size: 12px; margin-top: 0;">
                2026-02-05 v2.1.0
            </p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>æ–°å¢ï¼šå½•éŸ³åŠŸèƒ½ï¼ŒæŒ‰Rå½•åˆ¶ï¼Œé€‰æ‹©è½¨é“æ¿€æ´»å½•éŸ³</li>
                <li>æ–°å¢ï¼š"Realtime Fade" æ¨¡å¼ï¼Œå¼€å¯åï¼ŒéŸ³ç¬¦å°†éšæ’­æ”¾è¿›åº¦å¹³æ»‘æ˜¾ç°ã€‚</li>
                <li>æ–°å¢ï¼šæ–°å»ºè½¨é“æŒ‰é’®</li>
                <li>ä¼˜åŒ–ï¼šæ”¯æŒ Delete/Backspace é”®åˆ é™¤é€‰ä¸­çš„ Clip äº‹ä»¶</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 0;">
                2026-02-02 v2.0.1
            </p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>æ–°å¢ï¼šè‡ªå®šä¹‰è‰²å½©è°ƒè‰²ç›˜</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 0;">
                2026-01-20 v2.0.0
            </p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>
                    <strong>å…¨æ–°è®¾è®¡è¯­è¨€:</strong>
                    é‡‡ç”¨ <strong>"Deep Midnight Glass"</strong>é£æ ¼ã€‚å¼•å…¥å…¨å±€ç¯å¢ƒå…‰æ•ˆã€3D æ‚¬æµ®é¢æ¿ä¸é«˜æ–¯æ¨¡ç³Šæ™¯æ·±ã€‚
                </li>
                <li>æ–°å¢ï¼šâ€œshift + æ»šè½®â€æ»šåŠ¨æ’­æ”¾çº¿çš„åŠŸèƒ½</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 0;">2026-01-17 1.6.1</p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>æ–°å¢ï¼šå¯¼å…¥å¯¼å‡ºè§†è§’é¢„è®¾ (View Preset JSON) åŒ…æ‹¬åº•éƒ¨æ»‘å—æ•°å€¼</li>
                <li>ä¼˜åŒ–ï¼šåº•éƒ¨å‚æ•°æ»‘å— (Scale, Thickness, Z-Space) ç°å·²æ”¯æŒæ•°å€¼æ˜¾ç¤º</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 0;">2026-01-17 1.6.0</p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>æ–°å¢ï¼šäº‹ä»¶é€‰æ‹© - æ”¯æŒæ‹–æ‹½æ¡†é€‰å¤šä¸ª Clipï¼Œé…åˆ Shift é”®å¯å¢é‡åŠ é€‰</li>
                <li>ä¼˜åŒ–ï¼šèƒŒæ™¯è§†é¢‘æ—¶é—´çº¿åŒæ­¥ - èƒŒæ™¯è§†é¢‘ç°å·²ä¸æ—¶é—´è½´å®Œå…¨å¯¹é½ï¼Œä¸å†ç‹¬ç«‹æ’­æ”¾</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 0;">2026-01-16 1.5.2</p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>ç´§æ€¥ä¿®å¤ï¼šè§†é¢‘æ— æ³•å½•åˆ¶</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 0;">2026-01-16 1.5.1</p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>æ–°å¢ï¼šbox-line (Outlined) éŸ³ç¬¦æ ·å¼</li>
                <li>ä¼˜åŒ–ï¼šå¢å¼ºå½•åˆ¶ç¨³å®šæ€§</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 0;">2026-01-15 1.5.0</p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>æ–°å¢ï¼š3D æ˜Ÿç©ºèƒŒæ™¯ (Starfield)ï¼Œæ”¯æŒ UI å¼€å…³æ§åˆ¶</li>
                <li>ä¼˜åŒ–ï¼šå¿«æ·é”®æŒ‡å—ã€è§†è§’å‚æ•°æŠ˜å çŠ¶æ€è®°å¿†</li>
                <li>ä¿®å¤ï¼šWindows ç³»ç»Ÿæµè§ˆå™¨ä¸‹å˜é€Ÿ/å˜è°ƒé—®é¢˜</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 0;">2026-01-14 1.4.0</p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>æ–°å¢ï¼šé¢œè‰²é€‰æ‹©å™¨</li>
                <li>æ–°å¢ï¼šé«˜å…‰æ ·å¼è°ƒèŠ‚</li>
                <li>æ–°å¢ï¼šå…¨å±€ ESC é”®å¯å…³é—­æ‰€æœ‰å¼¹çª—</li>
                <li>æ–°å¢ï¼šå¿«æ·é”®æç¤º</li>
                <li>ä¼˜åŒ–ï¼šå¿«æ·é”®æç¤ºä¸è§†è§’å‚æ•°æ”¯æŒæŠ˜å </li>
                <li>ä¼˜åŒ–ï¼šç»Ÿä¸€äº†é«˜å…‰æ¸²æŸ“ç®—æ³•ï¼Œç§»é™¤å¼ºåˆ¶å…‰æ™•ï¼Œæ”¯æŒæ›´å®½çš„è°ƒèŠ‚èŒƒå›´ (0-100)</li>
                <li>ä¼˜åŒ–ï¼šæ’­æ”¾åŒæ­¥é€»è¾‘ï¼Œä¿®å¤åˆ‡æ¢æ ‡ç­¾é¡µåæ’­æ”¾çº¿è·³å˜/ä¸åŒæ­¥çš„é—®é¢˜</li>
                <li>ä¿®å¤ï¼šä¿®æ­£ç¼©ç•¥å›¾ä¸è½¨é“é¢œè‰²ä¸€è‡´æ€§</li>
                <li>ä¿®å¤ï¼šåˆ é™¤è½¨é“åè°ƒèŠ‚æ»‘å—ä¼šå¯¼è‡´â€œåƒµå°¸éŸ³ç¬¦â€å¤æ´»çš„ Bug</li>
            </ul>
            <p style="color: #aaa; font-size: 12px; margin-top: 0;">2026-01-14 1.3.0</p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>æ–°å¢ï¼šå·¦ä¸Šè§’ç‰ˆæœ¬ä¿¡æ¯æŸ¥çœ‹å…¥å£</li>
                <li>æ–°å¢ï¼šæ”¯æŒéŸ³é¢‘å¼€å¤´çš„é™éŸ³è‡ªåŠ¨å‰ªåˆ‡</li>
                <li>æ–°å¢ï¼šå·¥ç¨‹æ”¯æŒç›´æ¥ä¿å­˜å›åŸæ–‡ä»¶ (Ctrl+S / Cmd+S)</li>
                <li>æ–°å¢ï¼šå¢åŠ â€œå¦å­˜ä¸ºâ€å¿«æ·é”® (Shift + Ctrl+S / Shift+Cmd+S)</li>
                <li>ä¼˜åŒ–ï¼šèƒŒæ™¯è®¾ç½®é½¿è½®ç§»åŠ¨è‡³èƒŒæ™¯æŒ‰é’®æ—</li>
                <li>ä¼˜åŒ–ï¼šå½•åˆ¶è§†é¢‘æ”¯æŒæµå¼å†™å…¥ (ä¸å å†…å­˜)</li>
                <li>ä¼˜åŒ–ï¼šW-Scaleè°ƒæ•´èŒƒå›´</li>
                <li>ä¿®å¤ï¼šä¿®å¤æ–‡ä»¶æ‹–æ‹½å¯¼å…¥å¤±æ•ˆçš„é—®é¢˜</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 15px;">2026-01-12 1.2.1</p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>ä¿®å¤ï¼šä¿®å¤å¯¼å…¥/å¯¼å‡ºå·¥ç¨‹</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 15px;">2026-01-12 1.2.0</p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>æ–°å¢ï¼šâ€œè§†è§’å‚æ•°â€è®¾ç½®åŠŸèƒ½ï¼Œä¿è¯å¤šå·¥ç¨‹è§†è§’çš„ç»Ÿä¸€ï¼ˆå¯å¯¼å‡ºå¯¼å…¥å‚æ•°ï¼‰</li>
                <li>æ–°å¢ï¼šæ’­æ”¾åŒºåŸŸé«˜å…‰é¢œè‰²æ›´æ”¹åŠŸèƒ½ï¼ˆæ¨èäº®è‰²ï¼‰</li>
                <li>æ–°å¢ï¼šä¸Šä¸‹åŒºåŸŸè°ƒæ•´æŠŠæ‰‹</li>
                <li>ä¼˜åŒ–ï¼šæ”¯æŒMIDIã€éŸ³é¢‘ã€å›¾ç‰‡ã€è§†é¢‘ã€è§†è§’JSONã€å·¥ç¨‹JSONæ‹–åŠ¨å¯¼å…¥</li>
                <li>ä¼˜åŒ–ï¼šå¯è§†åŒ–åŒºåŸŸâ€œCommand/Control+åŒå‡»â€å¯é‡ç½®è§†è§’ï¼ŒæŒ‰ä½â€œCommand/Controlâ€æ‹–åŠ¨å¯å¹³ç§»ï¼Œæ»šè½®æ”¾å¤§ç¼©å°</li>
                <li>ä¼˜åŒ–ï¼šâ€œå¯¼å…¥æ–‡ä»¶â€çš„æ“ä½œæ”¯æŒæ’¤å›</li>
                <li>ä¼˜åŒ–ï¼šä¼˜åŒ–midiå¯¼å…¥è½¨é“çš„åŒæ­¥</li>
                <li>ä¼˜åŒ–ï¼šåˆ é™¤äº†éŸ³ç¬¦è´´å›¾å’Œtimeline zoomçš„è°ƒèŠ‚</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 15px;">2026-01-11 1.1.0</p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>æ–°å¢ï¼šåŠ å…¥Z-Spaceæ»‘å—</li>
                <li>ä¿®å¤ï¼šä¿®å¤æŸäº›æµè§ˆå™¨è°ƒè‰²ç›˜é—ªé€€é—®é¢˜</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 15px;">2026-01-10 1.0.0</p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>åŸºç¡€åŠŸèƒ½ä¸Šçº¿ï¼šMIDI/Audio å¯¼å…¥</li>
                <li>3D å¯è§†åŒ–æ¸²æŸ“å¼•æ“</li>
            </ul>
        </div>
        <div style="text-align: center; margin-bottom: 15px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); width: 100%;">
            <p style="font-size: 11px; color: #666; margin: 0; line-height: 1.6;">
                Open Source Project<br>
                <span style="color: #888; font-weight: 500;">Author: Jay Chan</span><br>
                <span style="color: #666; font-size: 10px;">Email: 3119929945@qq.com</span>
            </p>
        </div>

        <div class="modal-buttons" style="display: flex; justify-content: center; width: 100%; margin-top: 0;">
            <button class="btn btn-primary" id="closeVersionBtn" style="flex: 1;">å…³é—­</button>
        </div>

    </div>
</div>

<div id="color-picker-modal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 9999; justify-content: center; align-items: center;">
    <div class="modal-content">
        <h3 style="margin-top:0; margin-bottom: 15px; font-size: 16px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px;">
            é€‰æ‹©é¢œè‰² <span id="cp-target-name" style="font-size: 11px; color: #888; margin-left: 8px;"></span>
        </h3>

        <div id="cp-grid" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; margin-bottom: 20px;">
        </div>

        <div class="form-group" style="display: flex; gap: 10px; align-items: center;">
            <div id="cp-preview" style="width: 36px; height: 36px; border-radius: 6px; background: #fff; border: 1px solid rgba(255,255,255,0.2);"></div>
            <div style="flex: 1;">
                <label style="margin-bottom: 2px;">Hex Code</label>
                <input type="text" id="cp-hex-input" value="#FFFFFF" style="font-family: monospace; letter-spacing: 1px;">
            </div>
        </div>

        <div id="cp-extra-controls" style="display:none; margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 20px;">
            <div style="margin-bottom: 15px;">
                <label style="margin-bottom: 8px; display: block;">é«˜å…‰æ•ˆæœé¢„è§ˆ</label>
                <div style="height: 80px; background: #1a1a1a; border-radius: 6px; overflow:hidden; border: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: center; align-items: center;">
                    <canvas id="cp-3d-preview-canvas"></canvas>
                </div>
            </div>

            <div class="slider-group">
                <span>é«˜å…‰å®½åº¦: <span id="cp-width-val" style="font-family: monospace;">1.0</span></span>
                <input type="range" id="cp-width-slider" min="0.1" max="100.0" step="0.1" value="50.0">
            </div>
            <div class="slider-group" style="margin-top: 10px;">
                <span>é«˜å…‰äº®åº¦: <span id="cp-bright-val" style="font-family: monospace;">1.0</span></span>
                <input type="range" id="cp-bright-slider" min="0.5" max="5.0" step="0.1" value="1.0">
            </div>
        </div>

        <div class="modal-buttons">
            <button class="btn" id="cp-cancel-btn">å–æ¶ˆ</button>
            <button class="btn btn-primary" id="cp-confirm-btn">ç¡®å®š</button>
        </div>
    </div>
</div>

<audio id="audioElement"></audio>

<script type="x-shader/x-vertex" id="vertexShader">
    attribute float aExtraLength;
    uniform float uExtraLength;

    varying vec3 vWorldPosition;
    varying vec2 vUv;
    varying vec3 vLocalPos;
    varying float vHalfLength;

    uniform float uPlayheadX;
    uniform float uGlowRadius;
    uniform vec3 uBaseColor;
    uniform vec3 uActiveColor;
    uniform bool uUseTexture;
    uniform sampler2D uMap;

    void main() {
        vUv = uv;
        vec3 newPos = position;

        float totalExtra = aExtraLength + uExtraLength;

        if (newPos.x > 0.0) {
            newPos.x += totalExtra * 0.5;
        } else {
            newPos.x -= totalExtra * 0.5;
        }

        vLocalPos = newPos;
        vHalfLength = 0.5 + totalExtra * 0.5;

        #ifdef USE_INSTANCING
            vec4 worldPosition = modelMatrix * instanceMatrix * vec4(newPos, 1.0);
        #else
            vec4 worldPosition = modelMatrix * vec4(newPos, 1.0);
        #endif

        vWorldPosition = worldPosition.xyz;

        gl_Position = projectionMatrix * viewMatrix * worldPosition;
    }
</script>

<script type="x-shader/x-fragment" id="fragmentShader">
    varying vec3 vWorldPosition;
    varying vec3 vLocalPos;
    varying float vHalfLength;

    uniform vec3 uBaseColor;
    uniform vec3 uHighlightColor;
    uniform float uHighlightWidth;
    uniform float uHighlightBrightness; // äº®åº¦å˜é‡
    uniform float uPlayheadX;
    uniform float uShowEdges;

    // æ§åˆ¶æ˜¯å¦å¼€å¯â€œå®æ—¶æ¸æ˜¾â€
    uniform float uEnableFade;

    void main() {
        // --- 1. å®æ—¶æ¸æ˜¾é€»è¾‘ (Real-time Fade) ---
        float alpha = 1.0;

        if (uEnableFade > 0.5) {
            float dist = uPlayheadX - vWorldPosition.x;

            if (dist < 0.0) {
                // å¦‚æœæ˜¯æœªæ¥çš„éŸ³ç¬¦ï¼Œç›´æ¥éšè— (Discard)
                discard;
            } else {
                // å¦‚æœæ˜¯å·²æ’­æ”¾çš„éŸ³ç¬¦ï¼Œåšä¸€ä¸ªå¿«é€Ÿçš„æ·¡å…¥æ•ˆæœ (0 -> 1)
                alpha = smoothstep(0.0, 15.0, dist);
            }
        }

        // --- 2. åŸæœ‰çš„é«˜å…‰é€»è¾‘ ---
        float distToHead = abs(vWorldPosition.x - uPlayheadX);
        float intensity = exp(-distToHead * 2.0 / max(0.1, uHighlightWidth));

        // åº”ç”¨äº®åº¦ç³»æ•°
        vec3 finalHighlight = uHighlightColor * uHighlightBrightness;
        vec3 finalColor = mix(uBaseColor, finalHighlight, intensity);

        // --- 3. æ£±è§’çº¿æ¸²æŸ“é€»è¾‘ ---
        if (uShowEdges > 0.5) {
            float w = 0.05;
            float edgeX = step(vHalfLength - w, abs(vLocalPos.x));
            float edgeY = step(0.5 - w, abs(vLocalPos.y));
            float edgeZ = step(0.5 - w, abs(vLocalPos.z));

            if ((edgeX + edgeY + edgeZ) >= 2.0) {
                gl_FragColor = vec4(finalColor + vec3(0.1), 0.8 * alpha);
            } else {
                gl_FragColor = vec4(finalColor * 1.0, 0.8 * alpha);
            }
        } else {
            // æ™®é€šæ¨¡å¼
            gl_FragColor = vec4(finalColor, alpha);
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { Midi } from '@tonejs/midi';
    import * as BufferGeometryUtils from 'https://unpkg.com/three@0.160.0/examples/jsm/utils/BufferGeometryUtils.js';

    // ==========================================
    // 1. å…¨å±€çŠ¶æ€ä¸é…ç½®
    // ==========================================

    let bgMesh = null;
    let bgMaterial = null;
    let bgTexture = null;
    let bgImageAspect = 1;
    let customGeometry = null;
    let sharedAudioCtx = null;
    let starMesh = null; // å…¨å±€æ˜Ÿæ˜Ÿå¯¹è±¡
    let activeShaderMaterials = [];
    let currentHighlightColor = new THREE.Color(1, 1, 1);
    let currentHighlightWidth = 50.0;
    let currentHighlightBrightness = 1.0;
    let blurScene, blurCamera;
    let blurRtX, blurRtY; // ä¸¤ä¸ªæ¸²æŸ“ç›®æ ‡ (Render Targets): Xè½´ç»“æœ, Yè½´ç»“æœ
    let blurMatX, blurMatY; // ä¸¤ä¸ªæè´¨: æ¨ªå‘æ¨¡ç³Š, çºµå‘æ¨¡ç³Š
    let blurMesh; // ç”¨äºç¦»å±æ¸²æŸ“çš„æ¿å­
    let previewScene, previewCamera, previewRenderer, previewControls;
    let previewMeshOriginal = null;  // å·¦è¾¹çš„åŸå§‹æ›¿èº«
    let previewMeshStretched = null; // å³è¾¹çš„æ‹‰ä¼¸æ›¿èº«
    let tempLoadedGeometry = null;   // æš‚å­˜åˆšåŠ è½½è¿›æ¥çš„å‡ ä½•ä½“
    let previewAnimationId = null;

    let tempLoadedMaterial = null;

    function setStarfieldState(visible) {
        // 1. è®¾ç½® 3D æ˜Ÿæ˜Ÿç²’å­å¯è§æ€§
        if (starMesh) starMesh.visible = visible;

        // 2. åŒæ­¥ UI å¼€å…³çŠ¶æ€
        const toggle = document.getElementById('starfieldToggle');
        if (toggle) toggle.checked = visible;

        const vizSection = document.getElementById('visualizer-section');

        // ğŸ”¥ã€ä¿®å¤ã€‘è¯»å–å½“å‰çš„ä¸»é¢˜è®°å¿†ï¼Œä»¥ä¾¿å†³å®šå…³é—­æ˜Ÿæ˜Ÿåæ¢å¤ä»€ä¹ˆé¢œè‰²
        const currentTheme = localStorage.getItem('mv_bg_theme_mode') || 'dark';

        if (visible) {
            // === å¼€å¯æ˜Ÿæ˜Ÿ ===
            // å¦‚æœç”¨æˆ·æ²¡æœ‰ä¸Šä¼ è‡ªå®šä¹‰èƒŒæ™¯ï¼Œæ˜¾ç¤ºæ˜Ÿç©ºæ¿å­
            if (!currentBgType) {
                if (bgMaterial && window.starfieldBgTexture) {
                    bgMaterial.uniforms.tMap.value = window.starfieldBgTexture;
                    bgMaterial.uniforms.uOpacity.value = 1.0;
                    bgMaterial.uniforms.uBrightness.value = 0.0;
                    bgMaterial.uniforms.uContrast.value = 1.0;
                    bgImageAspect = 1.0;
                    BG_STATE.fit = 'cover';
                    if(document.getElementById('bg-fit')) document.getElementById('bg-fit').value = 'cover';
                    updateBackgroundUV();

                    if (bgMesh) bgMesh.visible = true;

                    // ğŸŒŸ å¼€å¯æ˜Ÿç©ºæ—¶ï¼ŒèƒŒæ™¯å¼ºåˆ¶å…¨é»‘ä»¥èåˆæ˜Ÿæ˜Ÿ
                    if (vizSection) vizSection.style.background = "#000000";
                }
            } else {
                if (bgMesh) bgMesh.visible = true;
            }
        } else {
            // === å…³é—­æ˜Ÿæ˜Ÿ ===
            if (!currentBgType) {
                if (bgMesh) bgMesh.visible = false;

                // ğŸ”¥ã€ä¿®å¤ã€‘å…³é—­æ˜Ÿæ˜Ÿæ—¶ï¼Œæ ¹æ®å½“å‰ä¸»é¢˜æ¢å¤èƒŒæ™¯ï¼Œè€Œä¸æ˜¯å¼ºåˆ¶å˜é»‘
                if (currentTheme === 'white') {
                    if (vizSection) vizSection.style.background = "#ffffff";
                } else {
                    // é»˜è®¤æ·±è‰²æ¸å˜
                    if (vizSection) vizSection.style.background = "#000000";
                }
            }
        }
    }

    const STATE = {
        isPlaying: false,
        currentTime: 0,         // å…¨å±€æ—¶é—´ (ç§’)
        lastFrameTime: 0,
        totalDuration: 60,      // é»˜è®¤è‡³å°‘60ç§’
        pxPerSec: 50,           // æ—¶é—´è½´ç¼©æ”¾: 1ç§’ = 50px
        playbackSpeed: 20,     // 3D åœºæ™¯é€Ÿåº¦ç³»æ•° (ä¸ zoomSlider å…³è”)
        noteThickness: 1.0,
        noteShape: 'capsule',
        tracks: [],             // å­˜å‚¨æ‰€æœ‰è½¨é“å¯¹è±¡
        clips: [],              // å­˜å‚¨æ‰€æœ‰ Clip å¯¹è±¡
        nextTrackId: 1,
        noteHeightScale: 1.5,
        audioGain: 1.5,
        bpm: 120,
        timeSignature: 4, // 4/4 æ‹
        selectedTrackIds: new Set(),
        selectedClips: new Set(), // ğŸ”¥ æ–°å¢ï¼šå­˜å‚¨é€‰ä¸­çš„ Clip å¯¹è±¡
        lastSelectedTrackId: null, // ğŸ”¥ æ–°å¢ï¼šè®°å½•æœ€åä¸€æ¬¡ç‚¹å‡»çš„è½¨é“ï¼ˆé”šç‚¹ï¼‰
        groups: {},
        nextGroupId: 1,
        soloCount: 0,
        zSeparation: 0.3,
        isRecording: false,
        recordingStartTime: 0,     // ç‚¹å‡»å½•åˆ¶æ—¶çš„æ—¶é—´æˆ³
        activeMidiNotes: new Map(), // å­˜å‚¨å½“å‰æŒ‰ä½çš„éŸ³ç¬¦
        recordingTrack: null,
        recordedSession: [],
        nextClipId: 1,
        enableMidiFade: true, // ğŸ”¥ æ–°å¢ï¼šæ§åˆ¶å½•åˆ¶æ¸æ˜¾
    };


    const DOM = {
        headers: document.getElementById('track-headers'),
        lanes: document.getElementById('lanes-container'),
        grid: document.getElementById('gridLines'),
        playhead: document.getElementById('ui-playhead'),
        timelineLanes: document.getElementById('timeline-lanes'),
        audio: document.getElementById('audioElement'),
        playBtn: document.getElementById('playBtn'),
        stopBtn: document.getElementById('stopBtn'),
        sceneZoom: document.getElementById('sceneZoom'),
        loading: document.getElementById('loading'),
        rulerContent: document.getElementById('ruler-content'),
        barRuler: document.getElementById('bar-ruler'),
        timeRuler: document.getElementById('time-ruler'),
        rulerPlayhead: document.getElementById('ruler-playhead'), // ğŸ”¥ æ–°å¢å¼•ç”¨
        recordBtn: document.getElementById('recordBtn')
    };

    const ResourceMgr = {
        audioCache: new Map(),

        // æ³¨å†Œèµ„æºå¹¶è¿”å›ä¸€ä¸ªå¯å¤ç”¨çš„ Blob URL
        register(fileOrBase64) {
            // å¦‚æœæ˜¯ Base64 å­—ç¬¦ä¸²ï¼Œè½¬ä¸º Blob
            if (typeof fileOrBase64 === 'string' && fileOrBase64.startsWith('data:')) {
                const blob = this.base64ToBlob(fileOrBase64);
                const url = URL.createObjectURL(blob);
                return url;
            }
            // å¦‚æœç›´æ¥æ˜¯ File æˆ– Blob å¯¹è±¡
            return URL.createObjectURL(fileOrBase64);
        },

        base64ToBlob(base64) {
            const parts = base64.split(';base64,');
            const contentType = parts[0].split(':')[1];
            const raw = window.atob(parts[1]);
            const uInt8Array = new Uint8Array(raw.length);
            for (let i = 0; i < raw.length; ++i) uInt8Array[i] = raw.charCodeAt(i);
            return new Blob([uInt8Array], { type: contentType });
        },

        // æ‰‹åŠ¨é‡Šæ”¾å†…å­˜
        revoke(url) {
            if (url && url.startsWith('blob:')) {
                URL.revokeObjectURL(url);
            }
        }
    };

    // æ–°å¢ Group ç±»
    class Group {
        constructor(name, color) {
            this.id = STATE.nextGroupId++;
            this.name = name;
            this.color = color; // ç¼–ç»„çš„ä¸»é¢œè‰²
            this.trackIds = new Set();
        }
    }


    // ==========================================
    // 2. ç±»å®šä¹‰ï¼šTrack & Clip
    // ==========================================

    const HistoryMgr = {
        undoStack: [],
        redoStack: [],
        maxLimit: 10,

        add(cmd) {
            // åœ¨æ·»åŠ æ–°æ“ä½œå‰ï¼Œå¦‚æœé‡åšæ ˆä¸ä¸ºç©ºï¼Œéœ€å…ˆé‡Šæ”¾é‡åšæ ˆä¸­çš„ Blob èµ„æº
            this.clearStackResources(this.redoStack);
            this.redoStack = [];

            this.undoStack.push(cmd);

            // å¦‚æœè¶…è¿‡é™åˆ¶ï¼Œå¼¹å‡ºæœ€æ—§çš„æ“ä½œå¹¶é‡Šæ”¾å…¶å…³è”çš„èµ„æº
            if (this.undoStack.length > this.maxLimit) {
                const oldestCmd = this.undoStack.shift();
                this.disposeCommandResources(oldestCmd);
            }
            console.log("History Add:", cmd.type);
        },

        // å…³é”®ï¼šè¯†åˆ«å‘½ä»¤ä¸­åŒ…å«çš„èµ„æºå¹¶é‡Šæ”¾
        disposeCommandResources(cmd) {
            if (!cmd) return;

            // 1. å¦‚æœæ˜¯èƒŒæ™¯å›¾æ›´æ”¹
            if (cmd.type === 'change_background') {
                if (cmd.oldData) ResourceMgr.revoke(cmd.oldData);
                if (cmd.newData) ResourceMgr.revoke(cmd.newData);
            }

            // 2. å¦‚æœæ˜¯éŸ³é¢‘å¯¼å…¥
            if (cmd.type === 'import_audio') {
                if (cmd.oldData?.clips) {
                    cmd.oldData.clips.forEach(c => ResourceMgr.revoke(c.sourceData));
                }
                if (cmd.newData?.clips) {
                    cmd.newData.clips.forEach(c => ResourceMgr.revoke(c.sourceData));
                }
            }

            // 3. å¦‚æœæ˜¯åˆ é™¤è½¨é“
            if (cmd.type === 'delete_track' && cmd.trackData?.clips) {
                cmd.trackData.clips.forEach(c => ResourceMgr.revoke(c.sourceData));
            }

            // 4. å¤„ç† Project JSON (å¦‚æœå­˜å‚¨çš„æ˜¯å¯¹è±¡ï¼ŒJS å¼•æ“ä¼šè‡ªåŠ¨å›æ”¶ï¼Œ
            // ä½†å¦‚æœé‡Œé¢åŒ…å«å¤§é‡ Blob å¼•ç”¨ï¼Œéœ€ç¡®ä¿æ¸…ç†)
            cmd.oldProject = null;
            cmd.newProject = null;
        },

        clearStackResources(stack) {
            stack.forEach(cmd => this.disposeCommandResources(cmd));
        },

        undo() {
            if (this.undoStack.length === 0) return;
            const cmd = this.undoStack.pop();
            this.redoStack.push(cmd);
            this.execute(cmd, true);
        },

        redo() {
            if (this.redoStack.length === 0) return;
            const cmd = this.redoStack.pop();
            this.undoStack.push(cmd);
            this.execute(cmd, false);
        },

        execute(cmd, isUndo) {
            switch (cmd.type) {
                case 'move_clip':
                    const clip = cmd.clip;
                    const targetTime = isUndo ? cmd.oldStart : cmd.newStart;
                    // æ¢å¤æ•°æ®
                    clip.startTime = targetTime;
                    // æ¢å¤è§†å›¾
                    clip.updateDOMPosition();
                    clip.update3DPosition();
                    updateTotalDuration();
                    break;

                case 'change_view':
                    const viewParams = isUndo ? cmd.oldView : cmd.newView;
                    ViewMgr.restore(viewParams);
                    break;

                // ğŸ”¥ æ–°å¢ Case: å·¥ç¨‹åŠ è½½ (æ•´ç›˜æ’¤å›)
                case 'load_project':
                    const projectData = isUndo ? cmd.oldProject : cmd.newProject;
                    // ç›´æ¥è°ƒç”¨ restoreState æ¢å¤æ•´ä¸ªå·¥ç¨‹
                    // æ³¨æ„ï¼šè¿™æ˜¯ä¸€ä¸ªè€—æ—¶æ“ä½œï¼Œå¯èƒ½ä¼šç¨å¾®å¡é¡¿ä¸€ä¸‹
                    ProjectMgr.restoreState(projectData);
                    break;

                case 'change_background':
                    const bgData = isUndo ? cmd.oldData : cmd.newData;
                    const bgType = isUndo ? cmd.oldType : cmd.newType;

                    const bgBase64 = isUndo ? cmd.oldBase64 : cmd.newBase64;
                    storedBgBase64ForSave = bgBase64;

                    if (bgData) {
                        // A. æ¢å¤å›¾ç‰‡
                        applyBackgroundSource(bgData, bgType);
                        currentBgBase64 = bgData;
                        currentBgType = bgType;
                        setStarfieldState(false); // å…³æ˜Ÿæ˜Ÿ
                    } else {
                        // B. æ¢å¤åˆ°æ— èƒŒæ™¯ï¼ˆæ˜Ÿç©ºï¼‰
                        if (bgMesh) bgMesh.visible = false;
                        if (bgMaterial && bgMaterial.uniforms.tMap) bgMaterial.uniforms.tMap.value = null;
                        if (bgVideoElement) {
                            bgVideoElement.pause();
                            bgVideoElement.src = "";
                            bgVideoElement = null;
                        }

                        // æ¸…ç©ºæ ‡è®°
                        currentBgBase64 = null;
                        currentBgType = null;
                        storedBgBase64ForSave = null;
                        bgTexture = null;

                        setStarfieldState(true); // å¼€æ˜Ÿæ˜Ÿ
                        requestAnimationFrame(() => onResize());
                    }
                    break;

                case 'record_midi':
                    const session = cmd.sessionData;

                    if (isUndo) {
                        // === æ’¤é”€å½•éŸ³ ===
                        // 1. å‡†å¤‡ä¸€ä¸ªé›†åˆï¼Œè®°å½•æœ¬æ¬¡æ’¤é”€æ¶‰åŠåˆ°çš„ Clipï¼Œä»¥ä¾¿åç»­æ£€æŸ¥æ˜¯å¦å˜ç©º
                        const potentiallyEmptyClips = new Set();

                        // åˆå§‹åŒ–/é‡ç½®æš‚å­˜æ•°ç»„ï¼ˆç”¨äº Redo æ—¶æ¢å¤ Clipï¼‰
                        cmd.deletedClipsInfo = [];

                        session.forEach(item => {
                            const track = STATE.tracks.find(t => t.id === item.trackId);
                            if (track) {
                                // ç²¾ç¡®æŸ¥æ‰¾ Clipï¼Œä¸å†ä½¿ç”¨ || track.clips[0] è¿™ç§æ¨¡ç³ŠåŒ¹é…ï¼Œé˜²æ­¢è¯¯åˆ 
                                const clip = track.clips.find(c => c.id === item.clipId);
                                if (clip && clip.data.notes) {
                                    // ç§»é™¤éŸ³ç¬¦
                                    const idx = clip.data.notes.indexOf(item.note);
                                    if (idx > -1) clip.data.notes.splice(idx, 1);

                                    // æ ‡è®°è¯¥ Clip éœ€è¦æ£€æŸ¥
                                    potentiallyEmptyClips.add(clip);
                                }
                            }
                        });

                        // 2. æ£€æŸ¥ Clip æ˜¯å¦å˜ç©ºï¼Œå¦‚æœæ˜¯åˆ™åˆ é™¤
                        potentiallyEmptyClips.forEach(clip => {
                            if (clip.data.notes.length === 0) {
                                // ğŸ”¥ å…³é”®ï¼šä¿å­˜ Clip ä¿¡æ¯ï¼Œä»¥ä¾¿ Redo æ—¶èƒ½å¤æ´»å®ƒ
                                cmd.deletedClipsInfo.push({
                                    trackId: clip.track.id,
                                    clipId: clip.id,
                                    start: clip.startTime,
                                    duration: clip.duration,
                                    name: clip.name
                                });

                                // å½»åº•é”€æ¯ Clip
                                clip.destroy(); // é”€æ¯ DOM å’Œ 3D èµ„æº

                                // ä»è½¨é“æ•°æ®ä¸­ç§»é™¤
                                const tIdx = clip.track.clips.indexOf(clip);
                                if (tIdx > -1) clip.track.clips.splice(tIdx, 1);

                                // ä»å…¨å±€ STATE ä¸­ç§»é™¤
                                const gIdx = STATE.clips.indexOf(clip);
                                if (gIdx > -1) STATE.clips.splice(gIdx, 1);

                            } else {
                                // å¦‚æœè¿˜æœ‰å‰©ä½™éŸ³ç¬¦ï¼ˆæ¯”å¦‚æ˜¯åœ¨æ—§ Clip ä¸Šå å½•ï¼‰ï¼Œåˆ™åªåˆ·æ–°æ˜¾ç¤º
                                clip.build3D();
                                clip.updateDOMPosition();
                            }
                        });

                    } else {
                        // === é‡åšå½•éŸ³ (Redo) ===

                        // 1. ğŸ”¥ å…ˆå¤æ´»è¢« Undo åˆ é™¤çš„ Clip (å¦‚æœæœ‰)
                        if (cmd.deletedClipsInfo && cmd.deletedClipsInfo.length > 0) {
                            cmd.deletedClipsInfo.forEach(info => {
                                const track = STATE.tracks.find(t => t.id === info.trackId);
                                if (track) {
                                    // é˜²æ­¢é‡å¤åˆ›å»º
                                    let existing = track.clips.find(c => c.id === info.clipId);
                                    if (!existing) {
                                        // åˆ›å»ºæ–° Clip
                                        const newClip = track.addClip(info.start, info.duration, { notes: [] }, info.name);
                                        // âš¡ï¸ å¼ºåˆ¶ä¿®æ­£ IDï¼šå¿…é¡»å’ŒåŸæ¥çš„ ID ä¸€æ ·ï¼Œå¦åˆ™ä¸‹é¢çš„éŸ³ç¬¦å¡ä¸è¿›å»
                                        // addClip ä¼šè‡ªåŠ¨è®© STATE.nextClipId++ï¼Œæˆ‘ä»¬è¦å›é€€è¿™ä¸ªè®¡æ•°ï¼Œå¹¶è¦†ç›– ID
                                        STATE.nextClipId--;
                                        newClip.id = info.clipId;
                                    }
                                }
                            });
                        }

                        // 2. å†æŠŠéŸ³ç¬¦å¡å›å»
                        session.forEach(item => {
                            const track = STATE.tracks.find(t => t.id === item.trackId);
                            if (track) {
                                const clip = track.clips.find(c => c.id === item.clipId);
                                if (clip && clip.data.notes) {
                                    clip.data.notes.push(item.note);
                                    clip.build3D();
                                    clip.updateDOMPosition();
                                }
                            }
                        });
                    }
                    break;

                case 'delete_events':
                    if (isUndo) {
                        cmd.restoredClips = [];

                        cmd.backup.forEach(item => {
                            const track = STATE.tracks.find(t => t.id === item.trackId);
                            if (track) {
                                const clipData = item.data;

                                if (track.type === 'audio') {
                                    // 1. åˆ›å»º Clip (æ•°æ®ä¼  nullï¼Œä¾é åç»­å¼‚æ­¥åŠ è½½)
                                    const clip = track.addClip(clipData.start, clipData.duration, null, clipData.name, clipData.sourceData);
                                    cmd.restoredClips.push(clip);

                                    // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šé‡æ–°ç»‘å®šæ’­æ”¾å™¨æº
                                    // å› ä¸º destroy æ—¶æŠŠ src æ¸…ç©ºäº†ï¼Œè¿™é‡Œå¿…é¡»è¡¥å›æ¥ï¼Œå¦åˆ™åªæœ‰æ³¢å½¢æ²¡å£°éŸ³
                                    if (!STATE.activeAudioClip || STATE.activeAudioClip === clip) {
                                        STATE.activeAudioClip = clip;
                                        DOM.audio.src = clip.sourceFile;
                                        DOM.audio.load();

                                        // å¦‚æœå½“å‰è¿›åº¦ä¸åœ¨ 0ï¼Œå¯èƒ½éœ€è¦å¯¹é½
                                        if (STATE.currentTime > 0) {
                                            DOM.audio.currentTime = Math.max(0, STATE.currentTime - clip.startTime);
                                        }
                                    }

                                    // 2. å¼‚æ­¥è§£ç éŸ³é¢‘æ•°æ® (ç”¨äºç»˜åˆ¶æ³¢å½¢)
                                    if (clipData.sourceData) {
                                        if (!sharedAudioCtx) sharedAudioCtx = new (window.AudioContext || window.webkitAudioContext)();

                                        fetch(clipData.sourceData)
                                            .then(res => res.arrayBuffer())
                                            .then(ab => sharedAudioCtx.decodeAudioData(ab))
                                            .then(buffer => {
                                                clip.data = buffer;

                                                // åˆ·æ–°è§†å›¾
                                                clip.drawThumbnail();
                                                clip.build3D();
                                                clip.updateDOMPosition();
                                            })
                                            .catch(e => console.error("Audio Undo Restore Failed:", e));
                                    }
                                } else {
                                    // MIDI é€»è¾‘
                                    const clip = track.addClip(clipData.start, clipData.duration, { notes: clipData.notes }, clipData.name, clipData.sourceData);
                                    cmd.restoredClips.push(clip);
                                }
                            }
                        });

                        // å¼ºåˆ¶åˆ·æ–° UI (è§£å†³ç»†æ¡é—®é¢˜)
                        setTimeout(() => {
                            if (cmd.restoredClips) {
                                cmd.restoredClips.forEach(c => {
                                    c.updateDOMPosition();
                                    if(c.track.type === 'midi') c.build3D();
                                });
                                STATE.selectedClips.clear();
                                cmd.restoredClips.forEach(c => selectClip(c, true));
                            }
                        }, 0);

                    } else {
                        // Redo é€»è¾‘ (ä¿æŒä¸å˜)
                        const targets = cmd.restoredClips || cmd.originalClips;
                        targets.forEach(clip => {
                            const track = clip.track;
                            const idx = track.clips.indexOf(clip);
                            if (idx > -1) track.clips.splice(idx, 1);
                            clip.destroy();
                            const gIdx = STATE.clips.indexOf(clip);
                            if (gIdx > -1) STATE.clips.splice(gIdx, 1);
                        });
                        STATE.selectedClips.clear();
                    }
                    break;

                // ğŸ”¥ æ–°å¢ Case 2: éŸ³é¢‘å¯¼å…¥æ’¤å›/é‡åš
                case 'import_audio':
                    const targetData = isUndo ? cmd.oldData : cmd.newData;

                    // 1. å…ˆå½»åº•åˆ é™¤å½“å‰çš„éŸ³é¢‘è½¨é“ (å¦‚æœæœ‰)
                    const currentAudio = STATE.tracks.find(t => t.type === 'audio');
                    if (currentAudio) {
                        deleteTrackContext(currentAudio);
                    }

                    // 2. å¦‚æœç›®æ ‡çŠ¶æ€æœ‰æ•°æ®ï¼Œåˆ™æ¢å¤å®ƒ
                    if (targetData) {
                        // Audio è½¨é“é€šå¸¸æ”¾åœ¨æœ€ä¸Šé¢ (index 0)
                        ProjectMgr.restoreSingleTrack(targetData, 0).then(() => {
                            if (typeof reorderTracks === 'function') reorderTracks();
                        });
                    }
                    break;

                case 'delete_track':
                    // é€»è¾‘ï¼šUndo = æ¢å¤; Redo = åˆ é™¤
                    if (isUndo) {
                        // ä½¿ç”¨ await ç¡®ä¿å¼‚æ­¥æ¢å¤å®Œæˆåå†é‡æ’ (restoreSingleTrack æ˜¯ async çš„)
                        ProjectMgr.restoreSingleTrack(cmd.trackData, cmd.index).then(() => {
                            if (typeof reorderTracks === 'function') reorderTracks();
                        });
                    } else {
                        // é‡æ–°è·å–å¯¹è±¡ï¼ˆå› ä¸ºä¹‹å‰è¢«é”€æ¯äº†ï¼Œå¼•ç”¨å¯èƒ½å¤±æ•ˆï¼Œæˆ–è€… id æ²¡å˜ä½†å¯¹è±¡å˜äº†ï¼‰
                        // ä½†å¦‚æœæ˜¯ restoreSingleTrack æ¢å¤çš„ï¼Œid åº”è¯¥æ˜¯ä¸€è‡´çš„
                        const t = STATE.tracks.find(tr => tr.id === cmd.trackData.id);
                        if(t) deleteTrackContext(t);
                    }
                    break;

                case 'clear_visuals':
                    if (isUndo) {
                        // === æ’¤å›æ¸…é™¤ (æ¢å¤ä»¥å‰çš„æ ·å­) ===
                        console.log("Undo Clear: Restoring visuals...");

                        // currentNoteTexture = cmd.oldTexture;
                        refreshAllMidiMeshes();

                        if (cmd.oldBgData) {
                            // æ¢å¤ä»¥å‰çš„èƒŒæ™¯å›¾
                            applyBackgroundSource(cmd.oldBgData, cmd.oldBgType);
                            currentBgBase64 = cmd.oldBgData;
                            currentBgType = cmd.oldBgType;
                            setStarfieldState(false); // æœ‰å›¾å°±å…³æ˜Ÿæ˜Ÿ
                        } else {
                            // ä»¥å‰å°±æ˜¯æ˜Ÿç©ºï¼Œæ¢å¤æ˜Ÿç©º
                            currentBgBase64 = null;
                            currentBgType = null;
                            setStarfieldState(true);
                            // ğŸ”¥ å¼ºåˆ¶åˆ·æ–°ï¼Œç¡®ä¿é“ºæ»¡å±å¹•
                            requestAnimationFrame(() => onResize());
                        }

                        if (cmd.oldView) {
                            ViewMgr.restore(cmd.oldView);
                        }
                    } else {
                        // === é‡åšæ¸…é™¤ (å†æ¬¡æ‰§è¡Œæ¸…é™¤) ===
                        console.log("Redo Clear: Clearing visuals again...");

                        refreshAllMidiMeshes();

                        if (bgMesh) bgMesh.visible = false;
                        if (bgMaterial && bgMaterial.uniforms.tMap) bgMaterial.uniforms.tMap.value = null;
                        if (bgVideoElement) {
                            bgVideoElement.pause();
                            bgVideoElement.src = "";
                            bgVideoElement = null;
                        }

                        // æ¸…ç©ºæ ‡è®°
                        currentBgBase64 = null;
                        currentBgType = null;

                        ViewMgr.reset();
                        setStarfieldState(true);

                        // ğŸ”¥ å¼ºåˆ¶åˆ·æ–°ï¼Œç¡®ä¿é“ºæ»¡å±å¹•
                        requestAnimationFrame(() => onResize());
                    }
                    break;

                case 'import_tracks':
                    // é€»è¾‘ï¼šUndo = åˆ é™¤è¿™äº›è½¨é“ (ä½†åœ¨åˆ é™¤å‰è¦ä¿å­˜æ•°æ®ä»¥ä¾¿ Redo); Redo = æ¢å¤è¿™äº›è½¨é“
                    if (isUndo) {
                        // ğŸ”¥ ä¿®å¤ï¼šé˜²æ­¢å¤šæ¬¡æ’¤é”€å¯¼è‡´ tracksData æ— é™é‡å¤å †å 
                        // åªæœ‰å½“ tracksData ä¸ºç©ºæ—¶ï¼ˆç¬¬ä¸€æ¬¡æ’¤é”€ï¼‰ï¼Œæ‰æ‰§è¡Œåºåˆ—åŒ–ä¿å­˜
                        if (!cmd.tracksData || cmd.tracksData.length === 0) {
                            if (!cmd.tracksData) cmd.tracksData = [];
                            cmd.trackIds.forEach(id => {
                                const t = STATE.tracks.find(tr => tr.id === id);
                                if (t) {
                                    const data = serializeTrack(t);
                                    cmd.tracksData.push({ data: data, index: STATE.tracks.indexOf(t) });
                                }
                            });
                        }

                        // æ‰§è¡Œåˆ é™¤æ“ä½œ
                        cmd.trackIds.forEach(id => {
                            const t = STATE.tracks.find(tr => tr.id === id);
                            if (t) deleteTrackContext(t);
                        });
                    } else {
                        // Redo: æ¢å¤
                        if (cmd.tracksData && cmd.tracksData.length > 0) {
                            cmd.tracksData.sort((a,b) => a.index - b.index).forEach(item => {
                                ProjectMgr.restoreSingleTrack(item.data, item.index);
                            });
                            if (typeof reorderTracks === 'function') reorderTracks();
                        }
                    }
                    break;

                case 'change_color':
                    const track = STATE.tracks.find(t => t.id === cmd.trackId);
                    if (track) {
                        const color = isUndo ? cmd.oldColor : cmd.newColor;
                        track.ownColor = color;
                        const input = track.headerEl.querySelector('.track-color-picker');
                        if(input) input.value = color;
                        track.refreshColor();
                    }
                    break;

                case 'change_group_color':
                    const changes = cmd.changes; // è¿™æ˜¯ä¸€ä¸ªæ•°ç»„ï¼ŒåŒ…å«æ‰€æœ‰å—å½±å“çš„ç»„ä¿¡æ¯
                    changes.forEach(item => {
                        const group = STATE.groups[item.groupId];
                        if (group) {
                            // æ¢å¤æ—§é¢œè‰² æˆ– åº”ç”¨æ–°é¢œè‰²
                            group.color = isUndo ? item.oldColor : item.newColor;

                            // åˆ·æ–°è¯¥ç»„ä¸‹æ‰€æœ‰è½¨é“çš„é¢œè‰²
                            group.trackIds.forEach(tid => {
                                const t = STATE.tracks.find(trk => trk.id === tid);
                                if (t) t.refreshColor();
                            });
                        }
                    });
                    break;
            }
        }
    };

    const ColorPickerPreview3D = {
        canvas: null, renderer: null, scene: null, camera: null, material: null,
        initialized: false,
        scanTime: 0,

        init() {
            if (this.initialized) return;
            this.canvas = document.getElementById('cp-3d-preview-canvas');

            const width = 360;
            const height = 80;

            this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, alpha: true, antialias: true });
            this.renderer.setSize(width, height);
            this.renderer.setPixelRatio(window.devicePixelRatio);

            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x000000);

            const aspect = width / height;
            const viewSize = 10;
            this.camera = new THREE.OrthographicCamera(
                -viewSize * aspect / 2, viewSize * aspect / 2,
                viewSize / 2, -viewSize / 2,
                0.1, 100
            );
            this.camera.position.set(0, 0, 10);
            this.camera.lookAt(0, 0, 0);

            // --- ç»Ÿä¸€åçš„ Shader ---
            this.material = new THREE.ShaderMaterial({
                uniforms: {
                    uBaseColor: { value: new THREE.Color(0x222222) },
                    uHighlightColor: { value: new THREE.Color(0xffffff) },
                    uHighlightWidth: { value: 50.0 },
                    uHighlightBrightness: { value: 1.0 }, // ğŸ”¥ æ–°å¢
                    uPlayheadX: { value: 0.0 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * instanceMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * viewMatrix * worldPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vWorldPosition;
                    uniform vec3 uBaseColor;
                    uniform vec3 uHighlightColor;
                    uniform float uHighlightWidth;
                    uniform float uHighlightBrightness; // ğŸ”¥ æ–°å¢
                    uniform float uPlayheadX;

                    void main() {
                        float dist = abs(vWorldPosition.x - uPlayheadX);
                        float intensity = exp(-dist * 2.0 / max(0.1, uHighlightWidth));

                        // ğŸ”¥ ä¿®æ”¹ï¼šä¹˜ä¸Šäº®åº¦
                        vec3 brightHighlight = uHighlightColor * uHighlightBrightness;
                        vec3 finalColor = mix(uBaseColor, brightHighlight, intensity);
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
            });


            // åˆ›å»ºé”™è½çš„éŸ³ç¬¦å¸ƒå±€
            const geometry = new THREE.PlaneGeometry(1, 0.6);
            const count = 20;
            const mesh = new THREE.InstancedMesh(geometry, this.material, count);

            const dummy = new THREE.Object3D();
            let index = 0;
            const rows = [1.5, 0.5, -0.5, -1.5];

            rows.forEach((y) => {
                let currentX = -8 + Math.random() * 2;
                while (currentX < 8 && index < count) {
                    const length = 1.5 + Math.random() * 2.5;
                    const gap = 0.5 + Math.random() * 1.0;
                    dummy.position.set(currentX + length / 2, y, 0);
                    dummy.scale.set(length, 1, 1);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(index++, dummy.matrix);
                    currentX += length + gap;
                }
            });

            this.scene.add(mesh);
            this.initialized = true;
            this.animate();
        },

        update(colorHex, widthVal, brightVal) {
            if (!this.initialized || !this.material) return;

            const floatWidth = parseFloat(widthVal);
            const floatBright = parseFloat(brightVal || 1.0); // é»˜è®¤ 1.0

            this.material.uniforms.uHighlightColor.value.set(colorHex);
            this.material.uniforms.uHighlightWidth.value = floatWidth;
            this.material.uniforms.uHighlightBrightness.value = floatBright; // ğŸ”¥ æ›´æ–°äº®åº¦
        },

        animate() {
            requestAnimationFrame(() => this.animate());
            const modal = document.getElementById('color-picker-modal');
            if (modal && modal.style.display !== 'none' && this.material) {
                this.scanTime += 0.02;
                const limit = 6.0;
                this.material.uniforms.uPlayheadX.value = Math.sin(this.scanTime) * limit;
                this.renderer.render(this.scene, this.camera);
            }
        }
    };

    // ==========================================
    // ğŸ¨ é€šç”¨é¢œè‰²ç›˜ç®¡ç†å™¨
    // ==========================================
    // ==========================================
    // ğŸ¨ é€šç”¨é¢œè‰²ç›˜ç®¡ç†å™¨ (å·²æ›´æ–°æ”¯æŒæ‰©å±•æ§ä»¶)
    // ==========================================
    const ColorPickerMgr = {
        modal: document.getElementById('color-picker-modal'),
        grid: document.getElementById('cp-grid'),
        input: document.getElementById('cp-hex-input'),
        preview: document.getElementById('cp-preview'),
        title: document.getElementById('cp-target-name'),

        // æ‰©å±•æ§ä»¶å¼•ç”¨
        extraControls: document.getElementById('cp-extra-controls'),
        widthSlider: document.getElementById('cp-width-slider'),
        widthValDisplay: document.getElementById('cp-width-val'),

        brightSlider: document.getElementById('cp-bright-slider'),
        brightValDisplay: document.getElementById('cp-bright-val'),


        // è‡ªå®šä¹‰è°ƒè‰²ç›˜ DOM å¼•ç”¨ (å°†åœ¨ init ä¸­åˆ›å»º)
        customPanel: null,
        sbBox: null,
        sbHandle: null,
        hueSlider: null,
        hueHandle: null,

        // å†…éƒ¨çŠ¶æ€
        hsv: { h: 0, s: 1, v: 1 }, // h:0-360, s:0-1, v:0-1
        isCustomMode: false,
        isDraggingSB: false,
        isDraggingHue: false,

        onChange: null,
        onConfirm: null,
        onWidthChange: null,
        onBrightChange: null, // ğŸ”¥ æ–°å¢å›è°ƒ
        tempColor: '#ffffff',
        isHighlightMode: false,

        // æ³¨æ„ï¼šè¿™é‡Œå»æ‰äº†æœ€åä¸€ä¸ªé¢œè‰²ï¼Œç•™ç»™â€œå½©è™¹æŒ‰é’®â€
        presets: [
            '#ff453a', '#ff9f0a', '#ffd60a', '#30d158', '#64d2ff', '#0a84ff',
            '#5e5ce6', '#bf5af2', '#ff375f', '#ac8e68', '#98989d', '#86868b',
            '#ffffff', '#888888', '#555555', '#2a2a2a', '#1c1c1e', '#000000',
            '#e0aaff', '#9d4edd', '#240046', '#a2d2ff', '#bde0fe' // åˆ é™¤äº†æœ€åä¸€ä¸ªï¼Œæ€»æ•°23ä¸ª
        ],

        init() {
            ColorPickerPreview3D.init();

            // 1. æ„å»ºåŸºç¡€ DOMï¼šGrid ä¸­æ’å…¥ Swatches
            this.grid.innerHTML = '';
            this.presets.forEach(color => {
                const el = document.createElement('div');
                el.className = 'color-swatch';
                el.style.backgroundColor = color;
                el.onclick = () => {
                    this.selectColor(color);
                    // é€‰ä¸­é¢„è®¾æ—¶ï¼Œæ›´æ–° HSV çŠ¶æ€ä»¥ä¾¿åˆ‡æ¢æ¨¡å¼æ—¶åŒæ­¥
                    const [h, s, v] = this.hexToHsv(color);
                    this.hsv = { h, s, v };
                };
                this.grid.appendChild(el);
            });

            // 2. æ’å…¥â€œå½©è™¹æŒ‰é’®â€åˆ°æœ€åä¸€ä¸ªä½ç½®
            const rainbowBtn = document.createElement('div');
            rainbowBtn.className = 'color-swatch rainbow-entry';
            rainbowBtn.title = "è‡ªå®šä¹‰é¢œè‰²";
            rainbowBtn.onclick = () => this.toggleCustomMode(true);
            this.grid.appendChild(rainbowBtn);

            // 3. æ„å»ºè‡ªå®šä¹‰è°ƒè‰²ç›˜ UI (æ’å…¥åˆ° Grid ä¸Šæ–¹)
            // å¦‚æœè¿˜æ²¡åˆ›å»ºè¿‡å®¹å™¨
            if (!document.getElementById('cp-custom-panel')) {
                const panel = document.createElement('div');
                panel.id = 'cp-custom-panel';
                panel.innerHTML = `
                    <button class="btn btn-back-grid">â† è¿”å›é¢„è®¾ç½‘æ ¼</button>
                    <div class="cp-sb-box">
                        <div class="cp-handle"></div>
                    </div>
                    <div class="cp-hue-slider">
                        <div class="cp-hue-handle"></div>
                    </div>
                `;
                // æ’å…¥åˆ° grid ä¹‹å‰
                this.grid.parentNode.insertBefore(panel, this.grid);

                // ç»‘å®šå¼•ç”¨
                this.customPanel = panel;
                this.sbBox = panel.querySelector('.cp-sb-box');
                this.sbHandle = panel.querySelector('.cp-handle');
                this.hueSlider = panel.querySelector('.cp-hue-slider');
                this.hueHandle = panel.querySelector('.cp-hue-handle');

                // ç»‘å®šäº‹ä»¶
                panel.querySelector('.btn-back-grid').onclick = () => this.toggleCustomMode(false);
                this.initCustomEvents();
            }

            // 4. ç»‘å®šåº•éƒ¨åŸæœ‰äº‹ä»¶
            document.getElementById('cp-cancel-btn').addEventListener('click', () => this.close());
            document.getElementById('cp-confirm-btn').addEventListener('click', () => this.confirm());

            // Hex è¾“å…¥æ¡†åŒæ­¥
            this.input.addEventListener('input', (e) => {
                const val = e.target.value;
                if (/^#[0-9A-F]{6}$/i.test(val)) {
                    this.selectColor(val, false);
                    // åŒæ­¥ HSV
                    const [h, s, v] = this.hexToHsv(val);
                    this.hsv = { h, s, v };
                    if (this.isCustomMode) this.updateCustomUI();
                }
            });
            this.input.addEventListener('blur', () => {
                // ç¦»ç„¦æ—¶å¼ºåˆ¶æ ¼å¼åŒ–ï¼Œé˜²æ­¢è¾“å…¥ä¸å®Œæ•´
                this.input.value = this.tempColor;
            });

            this.modal.addEventListener('click', (e) => {
                if (e.target === this.modal) this.close();
            });

            // æ‰©å±•æ§ä»¶é€»è¾‘
            this.widthSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                this.widthValDisplay.innerText = val.toFixed(1);
                // ğŸ”¥ ä¿®æ”¹ï¼šä¼ å‚å¢åŠ äº®åº¦å€¼
                if (this.isHighlightMode) ColorPickerPreview3D.update(this.tempColor, val, this.brightSlider.value);
                if (this.onWidthChange) this.onWidthChange(val);
            });

            // ğŸ”¥ æ–°å¢ï¼šæ‰©å±•æ§ä»¶é€»è¾‘ - äº®åº¦
            this.brightSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                this.brightValDisplay.innerText = val.toFixed(1);
                if (this.isHighlightMode) ColorPickerPreview3D.update(this.tempColor, this.widthSlider.value, val);
                if (this.onBrightChange) this.onBrightChange(val);
            });
        },

        initCustomEvents() {
            // --- é¥±å’Œåº¦/æ˜åº¦ (SB Box) æ‹–æ‹½ ---
            const updateSB = (e) => {
                const rect = this.sbBox.getBoundingClientRect();
                let x = e.clientX - rect.left;
                let y = e.clientY - rect.top;

                // é™åˆ¶èŒƒå›´
                x = Math.max(0, Math.min(x, rect.width));
                y = Math.max(0, Math.min(y, rect.height));

                // è®¡ç®— S å’Œ V
                this.hsv.s = x / rect.width;
                this.hsv.v = 1 - (y / rect.height);

                this.applyHsvToColor();
                this.updateHandlePos();
            };

            this.sbBox.addEventListener('mousedown', (e) => {
                this.isDraggingSB = true;
                updateSB(e);
            });

            // --- è‰²ç›¸ (Hue Slider) æ‹–æ‹½ ---
            const updateHue = (e) => {
                const rect = this.hueSlider.getBoundingClientRect();
                let x = e.clientX - rect.left;
                x = Math.max(0, Math.min(x, rect.width));

                // è®¡ç®— Hue (0-360)
                this.hsv.h = (x / rect.width) * 360;

                this.applyHsvToColor();
                this.updateHandlePos();
                // ä¹Ÿè¦æ›´æ–° SB Box çš„åº•è‰²
                this.sbBox.style.backgroundColor = `hsl(${this.hsv.h}, 100%, 50%)`;
            };

            this.hueSlider.addEventListener('mousedown', (e) => {
                this.isDraggingHue = true;
                updateHue(e);
            });

            // å…¨å±€é¼ æ ‡ç›‘å¬ (é˜²æ­¢æ‹–å‡ºåŒºåŸŸå¤±æ•ˆ)
            window.addEventListener('mousemove', (e) => {
                if (this.isDraggingSB) { e.preventDefault(); updateSB(e); }
                if (this.isDraggingHue) { e.preventDefault(); updateHue(e); }
            });

            window.addEventListener('mouseup', () => {
                this.isDraggingSB = false;
                this.isDraggingHue = false;
            });
        },

        toggleCustomMode(showCustom) {
            this.isCustomMode = showCustom;
            if (showCustom) {
                this.grid.style.display = 'none';
                this.customPanel.style.display = 'flex';
                // è¿›å…¥æ—¶ï¼Œæ ¹æ®å½“å‰é¢œè‰²æ›´æ–° UI
                this.updateCustomUI();
            } else {
                this.grid.style.display = 'grid';
                this.customPanel.style.display = 'none';
            }
        },

        // ä» HSV è®¡ç®— Hex å¹¶åº”ç”¨
        applyHsvToColor() {
            const hex = this.hsvToHex(this.hsv.h, this.hsv.s, this.hsv.v);
            this.selectColor(hex, true);
        },

        // æ›´æ–°æ‰‹æŸ„ä½ç½®
        updateHandlePos() {
            // Hue
            const huePercent = (this.hsv.h / 360) * 100;
            this.hueHandle.style.left = `${huePercent}%`;

            // SB
            const sPercent = this.hsv.s * 100;
            const vPercent = (1 - this.hsv.v) * 100;
            this.sbHandle.style.left = `${sPercent}%`;
            this.sbHandle.style.top = `${vPercent}%`;

            this.sbBox.style.backgroundColor = `hsl(${this.hsv.h}, 100%, 50%)`;
        },

        // å½“å¤–éƒ¨ä¼ å…¥ Hex æ—¶ï¼Œåå‘æ›´æ–° UI
        updateCustomUI() {
            if (this.customPanel && this.customPanel.style.display !== 'none') {
                this.updateHandlePos();
            }
        },

        // --- æ ¸å¿ƒé€»è¾‘ ---

        open(initialColor, title, onConfirm, onChange = null, extraConfig = null) {
            this.tempColor = initialColor;
            this.onConfirm = onConfirm;
            this.onChange = onChange;
            this.title.innerText = title || "";

            // åˆå§‹åŒ– HSV
            const [h, s, v] = this.hexToHsv(initialColor);
            this.hsv = { h, s, v };

            // æ‰©å±•æ§ä»¶é€»è¾‘
            if (extraConfig && extraConfig.isHighlight) {
                this.isHighlightMode = true;
                this.extraControls.style.display = 'block';
                const initWidth = extraConfig.initialWidth || 1.0;
                this.widthSlider.value = initWidth;
                this.widthValDisplay.innerText = initWidth.toFixed(1);
                this.onWidthChange = extraConfig.onWidthChange;
                const initBright = extraConfig.initialBrightness || 1.0;
                this.brightSlider.value = initBright;
                this.brightValDisplay.innerText = initBright.toFixed(1);
                this.onBrightChange = extraConfig.onBrightChange;
                ColorPickerPreview3D.update(this.tempColor, initWidth);
                ColorPickerPreview3D.renderer.setSize(360, 80);
            } else {
                this.isHighlightMode = false;
                this.extraControls.style.display = 'none';
                this.onWidthChange = null;
            }

            // é»˜è®¤æ˜¾ç¤ºç½‘æ ¼
            this.toggleCustomMode(false);
            this.modal.style.display = 'flex';
            this.selectColor(initialColor);
        },

        selectColor(color, updateInput = true) {
            this.tempColor = color;
            this.preview.style.backgroundColor = color;
            if (updateInput) this.input.value = color.toUpperCase();

            // ç§»é™¤ç½‘æ ¼é€‰ä¸­æ€
            Array.from(this.grid.children).forEach(child => child.classList.remove('active'));

            // å®æ—¶é¢„è§ˆå›è°ƒ
            if (this.isHighlightMode) {
                ColorPickerPreview3D.update(this.tempColor, this.widthSlider.value, this.brightSlider.value);
            }
            if (this.onChange) {
                this.onChange(this.tempColor);
            }
        },

        confirm() {
            if (this.onConfirm) this.onConfirm(this.tempColor);
            this.close();
        },

        close() {
            this.modal.style.display = 'none';
            this.onConfirm = null;
            this.onChange = null;
            this.onWidthChange = null;
            this.onBrightChange = null;
            this.isHighlightMode = false;
        },

        // --- é¢œè‰²ç®—æ³•å·¥å…· ---

        // Hex -> HSV
        hexToHsv(hex) {
            let r = parseInt(hex.substring(1, 3), 16) / 255;
            let g = parseInt(hex.substring(3, 5), 16) / 255;
            let b = parseInt(hex.substring(5, 7), 16) / 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, v = max;
            let d = max - min;
            s = max === 0 ? 0 : d / max;
            if (max === min) { h = 0; }
            else {
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h * 360, s, v];
        },

        // HSV -> Hex
        hsvToHex(h, s, v) {
            let r, g, b;
            let i = Math.floor(h / 60);
            let f = h / 60 - i;
            let p = v * (1 - s);
            let q = v * (1 - f * s);
            let t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            const toHex = x => {
                const val = Math.round(x * 255).toString(16);
                return val.length === 1 ? '0' + val : val;
            };
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
        }
    };

    // åœ¨æœ€åº•éƒ¨çš„ initController() ä¸­è°ƒç”¨åˆå§‹åŒ–
    // ColorPickerMgr.init();

    const BG_STATE = {
        opacity: 1.0,
        blur: 0,
        brightness: 100,
        contrast: 100,
        fit: 'cover'
    };

    let currentBgBase64 = null;
    let currentBgType = null;
    let storedBgBase64ForSave = null;

    // è¾…åŠ©å‡½æ•°ï¼šåº”ç”¨æ ·å¼åˆ°å½“å‰èƒŒæ™¯å…ƒç´ 
    function applyBackgroundStyles() {
        const layer = document.getElementById('bg-layer');
        // è·å– layer ä¸‹çš„ img æˆ– video
        const el = layer.querySelector('img, video');
        if (!el) return;

        // 1. åº”ç”¨ CSS æ»¤é•œ
        el.style.opacity = BG_STATE.opacity;
        el.style.filter = `blur(${BG_STATE.blur}px) brightness(${BG_STATE.brightness}%) contrast(${BG_STATE.contrast}%)`;

        // 2. åº”ç”¨å¡«å……æ¨¡å¼
        el.style.objectFit = BG_STATE.fit;
    }

    function initMidiAccess() {
        if (navigator.requestMIDIAccess) {
            navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
        } else {
            console.warn("æµè§ˆå™¨ä¸æ”¯æŒ Web MIDI API");
        }
    }

    function onMIDISuccess(midiAccess) {
        for (const input of midiAccess.inputs.values()) {
            input.onmidimessage = onMidiMessage;
        }
        midiAccess.onstatechange = (e) => {
            console.log("MIDI è®¾å¤‡çŠ¶æ€æ”¹å˜:", e.port.name, e.port.state);
        };
    }

    function onMIDIFailure() {
        console.warn("æ— æ³•è®¿é—® MIDI è®¾å¤‡");
    }

    function onMidiMessage(event) {
        // åªæœ‰åœ¨å½•åˆ¶çŠ¶æ€ï¼Œæˆ–è€…ä¸ºäº†è¯•å¬ï¼ˆå¯é€‰ï¼‰ï¼Œæ‰å“åº”
        if (!STATE.isRecording) return;

        const [command, note, velocity] = event.data;
        const cmd = command >> 4;

        // 144 = Note On, 128 = Note Off
        if (cmd === 9 && velocity > 0) {
            startRecordingNote(note, velocity);
        } else if (cmd === 8 || (cmd === 9 && velocity === 0)) {
            stopRecordingNote(note);
        }
    }

    function startRecordingNote(midiPitch, velocity) {
        if (!STATE.isPlaying) togglePlay();

        // ğŸ”¥ æ‰¾å‡ºæ‰€æœ‰å·² Arm çš„ MIDI è½¨é“
        const targets = STATE.tracks.filter(t => t.type === 'midi' && t.isArmed);
        if (targets.length === 0) return;

        const activeNoteInstances = [];

        // å¯¹æ¯ä¸€ä¸ª Armed è½¨é“ç”ŸæˆéŸ³ç¬¦
        targets.forEach(track => {
            // --- å‡ ä½•ä½“ç”Ÿæˆé€»è¾‘ (å¤ç”¨ä¿®å¤åçš„ä»£ç ) ---
            let geometry;
            switch (STATE.noteShape) {
                case 'box': geometry = new THREE.BoxGeometry(1, 1, 1); break;
                case 'box-line': geometry = new THREE.BoxGeometry(1, 1, 1); break;
                case 'cylinder': geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16); geometry.rotateZ(Math.PI / 2); break;
                case 'hexagon': geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 6); geometry.rotateZ(Math.PI / 2); break;
                case 'diamond': geometry = new THREE.OctahedronGeometry(0.5); break;
                case 'torus': geometry = new THREE.TorusGeometry(0.4, 0.15, 8, 20); break;
                case 'knot': geometry = new THREE.TorusKnotGeometry(0.35, 0.1, 32, 8); break;
                case 'cone': geometry = new THREE.ConeGeometry(0.5, 1, 16); geometry.rotateZ(Math.PI / 2); break;
                case 'custom': geometry = customGeometry ? customGeometry.clone() : new THREE.SphereGeometry(0.5, 16, 16); break;
                case 'capsule': default: geometry = new THREE.SphereGeometry(0.5, 16, 16); break;
            }

            // æè´¨
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uBaseColor: { value: new THREE.Color(track.color).multiplyScalar(0.8) },
                    uOpacity: { value: 0.0 },
                    uExtraLength: { value: 0.0 },
                    uPlayheadX: { value: 0.0 },
                    uHighlightColor: { value: currentHighlightColor },
                    uHighlightWidth: { value: currentHighlightWidth },
                    uHighlightBrightness: { value: currentHighlightBrightness }, // ğŸ”¥ æ–°å¢
                    uEnableFade: { value: STATE.enableMidiFade ? 1.0 : 0.0 },
                },
                vertexShader: document.getElementById('vertexShader').textContent, // å¤ç”¨ HTML é‡Œçš„ shader å†…å®¹
                fragmentShader: document.getElementById('fragmentShader').textContent,
                transparent: true,
                depthTest: true,
                depthWrite: true
            });
            activeShaderMaterials.push(material);

            const mesh = new THREE.Mesh(geometry, material);

            // ä½ç½®è®¡ç®—
            const minPitch = 21;
            const pitchRange = 88;
            const heightStep = (60 / pitchRange) * STATE.noteHeightScale;
            const centerOffset = 30 * STATE.noteHeightScale;
            const y = (midiPitch - minPitch) * heightStep - centerOffset;
            const zStep = STATE.zSeparation;
            const zOffset = (track.zRank || 0) * zStep; // ä½¿ç”¨è¯¥è½¨é“çš„ ZRank
            const startX = STATE.currentTime * STATE.playbackSpeed;

            mesh.position.set(startX, y, zOffset);
            mesh.scale.set(1, 1, 1);
            scene.add(mesh);

            activeNoteInstances.push({
                track: track,
                mesh: mesh,
                startTime: STATE.currentTime,
                velocity: velocity,
                startY: y,
                startZ: zOffset
            });
        });

        // ğŸ”¥ å°†éŸ³ç¬¦å®ä¾‹æ•°ç»„å­˜å…¥ Map (Pitch -> Array)
        STATE.activeMidiNotes.set(midiPitch, activeNoteInstances);

        // ä¸éœ€è¦åœ¨è¿™é‡Œè°ƒç”¨ updateRecordingVisualsï¼Œanimate å¾ªç¯ä¼šè‡ªåŠ¨è°ƒç”¨
    }

    function stopRecordingNote(midiPitch) {
        // è·å–è¯¥éŸ³é«˜å¯¹åº”çš„æ‰€æœ‰å®ä¾‹ï¼ˆå¯èƒ½æ­£åœ¨åŒæ—¶å½•åˆ¶åˆ°å¤šä¸ªè½¨é“ï¼‰
        const instances = STATE.activeMidiNotes.get(midiPitch);
        if (!instances) return;

        instances.forEach(inst => {
            const track = inst.track;
            const duration = STATE.currentTime - inst.startTime;

            // 1. è·å–æˆ–åˆ›å»º Clip (å¦‚æœæ²¡æœ‰ Clip å°±æ–°å»ºä¸€ä¸ª)
            let targetClip = track.clips[0];
            if (!targetClip) {
                // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šä½¿ç”¨å½•åˆ¶å¼€å§‹çš„æ—¶é—´ä½œä¸º Clip èµ·ç‚¹ï¼Œè€Œä¸æ˜¯ 0
                // è¿™æ · Clip å°±ä¼šå‡ºç°åœ¨ä½ ç‚¹å‡»å½•åˆ¶çš„åœ°æ–¹
                let clipStart = STATE.recordingStartTime;

                // å®¹é”™ï¼šä¸‡ä¸€éŸ³ç¬¦å¼€å§‹æ—¶é—´æ¯”å½•åˆ¶æ—¶é—´è¿˜æ—©(æå°‘è§)ï¼Œå–éŸ³ç¬¦æ—¶é—´ï¼Œé˜²æ­¢è´Ÿæ•°
                if (inst.startTime < clipStart) clipStart = inst.startTime;

                targetClip = track.addClip(clipStart, 0.1, { notes: [] }, "Recorded Clip");
            }
            if (!targetClip.data.notes) targetClip.data.notes = [];

            // 2. ç”Ÿæˆæ•°æ®
            const newNote = {
                midi: midiPitch,
                time: inst.startTime - targetClip.startTime,
                duration: Math.max(0.1, duration),
                velocity: inst.velocity / 127
            };

            // 3. å†™å…¥
            targetClip.data.notes.push(newNote);
            STATE.recordedSession.push({
                trackId: track.id,
                clipId: targetClip.id,
                note: newNote
            });

            // 4. æ¸…ç† 3D èµ„æº
            if (inst.mesh) {
                scene.remove(inst.mesh);
                if (inst.mesh.geometry) inst.mesh.geometry.dispose();
                if (inst.mesh.material) {
                    const idx = activeShaderMaterials.indexOf(inst.mesh.material);
                    if (idx > -1) activeShaderMaterials.splice(idx, 1);
                    inst.mesh.material.dispose();
                }
            }

            // 5. åˆ·æ–°è§†å›¾
            targetClip.build3D();
            targetClip.updateDOMPosition();
        });

        STATE.activeMidiNotes.delete(midiPitch);
    }

    function updateRecordingVisuals() {
        if (STATE.activeMidiNotes.size === 0) return;

        const currentX = STATE.currentTime * STATE.playbackSpeed;
        const heightStep = (60 / 88) * STATE.noteHeightScale;
        const thickness = 0.8 * heightStep * STATE.noteThickness;

        STATE.activeMidiNotes.forEach((instances, pitch) => {
            // éå†è¯¥éŸ³é«˜ä¸‹çš„æ‰€æœ‰å®ä¾‹ (æ¯ä¸ªè½¨é“ä¸€ä¸ª)
            instances.forEach(noteData => {
                const mesh = noteData.mesh;
                const startX = noteData.startTime * STATE.playbackSpeed;
                const width = Math.max(thickness, currentX - startX);

                let extraLength = (width / thickness) - 1.0;
                if (extraLength < 0) extraLength = 0;

                if (mesh.material.uniforms) {
                    mesh.material.uniforms.uExtraLength.value = extraLength;
                    if (mesh.material.uniforms.uOpacity.value < 1.0) {
                        mesh.material.uniforms.uOpacity.value += 0.1;
                    }
                }

                mesh.scale.set(thickness, thickness, thickness * 0.9);
                mesh.position.x = startX + width / 2;
            });
        });
    }

    function toggleRecord() {
        if (STATE.isRecording) {
            // === åœæ­¢å½•éŸ³ ===
            STATE.isRecording = false;
            DOM.recordBtn.classList.remove('active-record');
            DOM.recordBtn.style.background = "";

            // åœæ­¢æ‰€æœ‰æ­£åœ¨å“çš„éŸ³ç¬¦
            STATE.activeMidiNotes.forEach((_, pitch) => stopRecordingNote(pitch));

            if (STATE.isPlaying) togglePlay();

            // ç”Ÿæˆå†å²è®°å½•
            if (STATE.recordedSession.length > 0) {
                console.log(`å½•éŸ³ç»“æŸï¼Œæ•è· ${STATE.recordedSession.length} ä¸ªéŸ³ç¬¦`);
                HistoryMgr.add({
                    type: 'record_midi',
                    sessionData: [...STATE.recordedSession]
                });
            }

            updateTotalDuration();

            STATE.recordedSession = [];
        } else {
            // === å¼€å§‹å½•éŸ³ ===

            // ğŸ”¥ æ£€æŸ¥æ˜¯å¦æœ‰è½¨é“å¤„äº"å‡†å¤‡å½•éŸ³(Arm)"çŠ¶æ€
            const armedTracks = STATE.tracks.filter(t => t.type === 'midi' && t.isArmed);

            if (armedTracks.length === 0) {
                alert("è¯·å…ˆæ¿€æ´»è‡³å°‘ä¸€ä¸ª MIDI è½¨é“è¿›è¡Œå½•éŸ³ï¼");
                return;
            }

            // æ¸…ç©ºç¼“å­˜
            STATE.recordedSession = [];

            // å¼€å¯çŠ¶æ€
            STATE.isRecording = true;

            // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šè®°å½•ç‚¹å‡»å½•åˆ¶é‚£ä¸€åˆ»çš„æ—¶é—´ï¼Œä½œä¸ºæ–° Clip çš„èµ·ç‚¹
            STATE.recordingStartTime = STATE.currentTime;

            DOM.recordBtn.classList.add('active-record');
            DOM.recordBtn.style.background = "rgba(255, 69, 58, 0.3)";

            if (!STATE.isPlaying) togglePlay();
        }
    }

    // è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°å¼¹çª—é‡Œçš„æ•°å€¼æ˜¾ç¤º
    function updateBgUI() {
        document.getElementById('bg-opacity').value = BG_STATE.opacity;
        document.getElementById('val-opacity').innerText = BG_STATE.opacity;

        document.getElementById('bg-blur').value = BG_STATE.blur;
        document.getElementById('val-blur').innerText = BG_STATE.blur + 'px';

        document.getElementById('bg-brightness').value = BG_STATE.brightness;
        document.getElementById('val-bright').innerText = BG_STATE.brightness + '%';

        document.getElementById('bg-contrast').value = BG_STATE.contrast;
        document.getElementById('val-contrast').innerText = BG_STATE.contrast + '%';

        document.getElementById('bg-fit').value = BG_STATE.fit;
    }

    // âœ¨ æ–°å¢ï¼šåˆ›å»ºæ˜Ÿç©ºå‡½æ•° (å¸¦åœ†å½¢å…‰æ™•è´´å›¾)
    function initStarfield() {
        const starGeo = new THREE.BufferGeometry();
        const starCount = 80000; // æ˜Ÿæ˜Ÿæ•°é‡
        const posArray = new Float32Array(starCount * 3);
        const range = 4000;

        for(let i = 0; i < starCount; i++) {
            const i3 = i * 3;
            // ğŸ”¥ ä¿®å¤æ­¥éª¤ 2ï¼š
            // å¿…é¡»ç¡®ä¿ X è½´çš„éšæœºåˆ†å¸ƒå¡«æ»¡æ•´ä¸ª range (-2000 åˆ° +2000)
            // ä¹‹å‰çš„ä»£ç åªç”Ÿæˆäº† -1000 åˆ° +1000ï¼Œå¯¼è‡´äº†ç©ºéš™
            posArray[i3]     = (Math.random() - 0.5) * range;

            // Y å’Œ Z è½´ä¿æŒåŸæœ‰è§†é‡é«˜åº¦å³å¯ (è¿™é‡Œè®¾ä¸º 2500 ä»¥é˜²ç©¿å¸®)
            posArray[i3 + 1] = (Math.random() - 0.5) * 2500;
            posArray[i3 + 2] = (Math.random() - 0.5) * 1500; // Zè½´æ·±åº¦
        }

        starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

        // ğŸ¨ 1. ç”¨ä»£ç ç”»ä¸€ä¸ªåœ†å½¢çš„æ¸å˜è´´å›¾ (æ— éœ€å¤–éƒ¨å›¾ç‰‡)
        const canvas = document.createElement('canvas');
        canvas.width = 64; // ç¨å¾®å¤§ä¸€ç‚¹ï¼Œç”»è´¨æ›´å¥½
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        // åˆ›å»ºå¾„å‘æ¸å˜ï¼šä¸­é—´ç™½ -> è¾¹ç¼˜é€æ˜
        const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');   // ä¸­å¿ƒæœ€äº®
        gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)'); // æ ¸å¿ƒå…‰æ™•
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)'); // å¤–éƒ¨å…‰æ™•
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');          // è¾¹ç¼˜å®Œå…¨é€æ˜

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);

        const starTexture = new THREE.CanvasTexture(canvas);

        // ğŸ¨ 2. è®¾ç½®æè´¨
        const starMat = new THREE.ShaderMaterial({
            uniforms: {
                uCamX: { value: 0.0 },     // ç›¸æœºå½“å‰çš„ X ä½ç½®
                uRange: { value: range },  // æ˜Ÿç©ºç›’å­çš„æ€»å®½åº¦
                uMap: { value: starTexture },
                uSize: { value: 6.0 }      // æ˜Ÿæ˜Ÿå¤§å°
            },
            vertexShader: `
            uniform float uCamX;
            uniform float uRange;
            uniform float uSize;

            void main() {
                vec3 pos = position;

                // --- æ— é™æ˜Ÿç©ºæ ¸å¿ƒç®—æ³• ---
                // 1. è®¡ç®—æ˜Ÿæ˜Ÿç›¸å¯¹äºç›¸æœºçš„è·ç¦»
                float diff = pos.x - uCamX;

                // 2. ä½¿ç”¨æ¨¡è¿ç®— (mod) è®©æ˜Ÿæ˜Ÿåœ¨ç›¸æœºå‰åå¾ªç¯å‡ºç°
                // å½“æ˜Ÿæ˜Ÿè½åç›¸æœº range/2 æ—¶ï¼Œè‡ªåŠ¨åŠ  range ç¬ç§»åˆ°å‰æ–¹
                float wrappedDiff = mod(diff + uRange * 0.5, uRange) - uRange * 0.5;

                vec3 localOffset = vec3(wrappedDiff, pos.y, pos.z);

                vec4 rotatedOffset = modelMatrix * vec4(localOffset, 1.0);

                // 3. è®¡ç®—æœ€ç»ˆçš„ä¸–ç•Œåæ ‡ï¼šç›¸æœºä½ç½® + å¾ªç¯åçš„ç›¸å¯¹åç§»
                vec3 finalPos = rotatedOffset.xyz + vec3(uCamX, 0.0, 0.0);

                vec4 mvPosition = viewMatrix * vec4(finalPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // å¤§å°éšè·ç¦»è¡°å‡
                gl_PointSize = uSize * (300.0 / -mvPosition.z);
            }
        `,
            fragmentShader: `
            uniform sampler2D uMap;
            void main() {
                vec4 texColor = texture2D(uMap, gl_PointCoord);
                if (texColor.a < 0.1) discard; // é€æ˜å‰”é™¤
                gl_FragColor = texColor;
            }
        `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        starMesh = new THREE.Points(starGeo, starMat);
        starMesh.frustumCulled = false;
        scene.add(starMesh);

        const bgCanvas = document.createElement('canvas');
        bgCanvas.width = 512;
        bgCanvas.height = 512;
        const bgCtx = bgCanvas.getContext('2d');

        // æ¸å˜ (ä¹‹å‰çš„é¢œè‰²)
        const bgGrad = bgCtx.createRadialGradient(256, 256, 0, 256, 256, 480);
        bgGrad.addColorStop(0.0, '#586b85');
        bgGrad.addColorStop(0.4, '#253045');
        bgGrad.addColorStop(1.0, '#000000');

        bgCtx.fillStyle = bgGrad;
        bgCtx.fillRect(0, 0, 512, 512);

        // --- ğŸ”¥ å…³é”®ä¼˜åŒ–ï¼šæ·»åŠ æŠ–åŠ¨ (Dithering) å»é™¤è‰²é˜¶ ---
        const imageData = bgCtx.getImageData(0, 0, 512, 512);
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            // ç”Ÿæˆ -1.5 åˆ° +1.5 ä¹‹é—´çš„éšæœºå™ªéŸ³
            // è¿™ä¸ªæ•°å€¼å¾ˆå°ï¼Œä¸å½±å“è§‚æ„Ÿï¼Œä½†è¶³ä»¥æ‰“ç ´è‰²é˜¶
            const noise = (Math.random() - 0.5) * 3;

            data[i]     = Math.max(0, Math.min(255, data[i] + noise));     // R
            data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise)); // G
            data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise)); // B
            // Alpha ä¸åŠ¨
        }
        bgCtx.putImageData(imageData, 0, 0);
        // ------------------------------------------------

        window.starfieldBgTexture = new THREE.CanvasTexture(bgCanvas);
        window.starfieldBgTexture.encoding = THREE.sRGBEncoding;
        window.starfieldBgTexture.minFilter = THREE.LinearFilter;
        window.starfieldBgTexture.magFilter = THREE.LinearFilter;
    }

    function deleteTrackContext(track) {
        if (!track) return;

        // --- æ–°å¢ï¼šéŸ³é¢‘æ¸…ç†é€»è¾‘ ---
        // æ£€æŸ¥è¯¥è½¨é“æ˜¯å¦åŒ…å«å½“å‰çš„æ´»åŠ¨éŸ³é¢‘ Clip
        track.clips.forEach(c => {
            if (STATE.activeAudioClip === c) {
                console.log("æ­£åœ¨åˆ é™¤æ´»åŠ¨éŸ³é¢‘è½¨é“ï¼Œåœæ­¢æ’­æ”¾...");

                // 1. åœæ­¢æ’­æ”¾
                if (STATE.isPlaying) togglePlay();

                // 2. æš‚åœéŸ³é¢‘å…ƒç´ 
                DOM.audio.pause();

                // 3. ç§»é™¤æºï¼Œé˜²æ­¢ç»§ç»­å‘å£°
                DOM.audio.removeAttribute('src');
                DOM.audio.load(); // å¼ºåˆ¶åˆ·æ–°éŸ³é¢‘å…ƒç´ çŠ¶æ€

                // 4. æ¸…é™¤å…¨å±€å¼•ç”¨
                STATE.activeAudioClip = null;
            }
            c.destroy();
            const globalIdx = STATE.clips.indexOf(c);
            if (globalIdx > -1) {
                STATE.clips.splice(globalIdx, 1);
            }
        });
        // -------------------------

        // 2. æ¸…ç† DOM
        if (track.headerEl) track.headerEl.remove();
        if (track.laneEl) track.laneEl.remove();

        // 3. ä»å…¨å±€æ•°ç»„ç§»é™¤
        const idx = STATE.tracks.indexOf(track);
        if (idx > -1) {
            STATE.tracks.splice(idx, 1);
        }

        // 4. æ¸…ç†é€‰ä¸­çŠ¶æ€
        STATE.selectedTrackIds.delete(track.id);

        // 5. åˆ·æ–°
        updateTotalDuration();
    }

    class Track {
        constructor(name, type) {
            this.id = STATE.nextTrackId++;
            this.name = name;
            this.type = type;

            // ğŸ”¥ ä¿®æ”¹è¿™é‡Œï¼šæ ¹æ®ç±»å‹åˆ†é…ä¸åŒçš„ç°åº¦
            if (this.type === 'audio') {
                this.ownColor = '#888888'; // Audio: ä¸­ç°è‰² (é…åˆé€æ˜åº¦é€€å±…èƒŒæ™¯)
            } else {
                this.ownColor = '#86868b'; // MIDI: äº®é“¶è‰² (ä½œä¸ºè§†è§‰ä¸»ä½“)
            }
            this.isArmed = false;

            this.groupId = null;
            this.clips = [];

            this.headerEl = null;
            this.laneEl = null;
            this.isMuted = false;
            this.isSoloed = false;

            this.renderUI();
        }

        get color() {
            return this.getEffectiveColor();
        }

        // ğŸ”¥ æ ¸å¿ƒï¼šè·å–æœ‰æ•ˆé¢œè‰²ã€‚å¦‚æœæœ‰ç¼–ç»„ï¼Œä¼˜å…ˆç”¨ç¼–ç»„é¢œè‰²
        getEffectiveColor() {
            if (this.groupId && STATE.groups[this.groupId]) {
                return STATE.groups[this.groupId].color;
            }
            return this.ownColor;
        }

        setMute(state) {
            this.isMuted = state;
            const btn = this.headerEl.querySelector('.mute-btn');
            if (btn) btn.classList.toggle('active-mute', this.isMuted);

            // æ¯æ¬¡ Mute çŠ¶æ€æ”¹å˜ï¼Œåˆ·æ–°å¯è§æ€§å’ŒéŸ³é‡
            updateAllTracksVisibility();
        }

        setSolo(state) {
            // åªæœ‰å½“çŠ¶æ€çœŸæ­£å‘ç”Ÿæ”¹å˜æ—¶ï¼Œæ‰æ›´æ–°å…¨å±€è®¡æ•°
            if (this.isSoloed !== state) {
                this.isSoloed = state;
                // æ›´æ–°å…¨å±€è®¡æ•°ï¼šå¼€å¯åˆ™åŠ 1ï¼Œå…³é—­åˆ™å‡1
                STATE.soloCount += this.isSoloed ? 1 : -1;

                const btn = this.headerEl.querySelector('.solo-btn');
                if (btn) btn.classList.toggle('active-solo', this.isSoloed);
            }
        }

        renderUI() {
            // 1. åˆ›å»º Header å®¹å™¨
            const headerDiv = document.createElement('div');
            headerDiv.className = 'track-header';
            headerDiv.style.position = 'relative';

            // 2. åˆ›å»ºç¼–ç»„æŒ‡ç¤ºæ¡
            const groupIndicator = document.createElement('div');
            groupIndicator.className = 'group-indicator';
            groupIndicator.id = `group-ind-${this.id}`;
            headerDiv.appendChild(groupIndicator);

            // ============================================================
            // ğŸ”¥ ä¿®å¤ç‚¹ï¼šå¿…é¡»å…ˆå®šä¹‰ contentDivï¼Œæ‰èƒ½æ“ä½œå®ƒ
            // ============================================================
            const contentDiv = document.createElement('div');

            // 3. è®¾ç½® HTML ç»“æ„ (åŒ…å«é¢œè‰²æŒ‰é’®çš„å ä½ç¬¦ .track-color-slot)
            contentDiv.innerHTML = `
                <div class="track-name" title="${this.name}">${this.name}</div>
                <div class="track-controls">
                    <div class="track-color-slot"></div>
                    <button class="btn-sm mute-btn" title="Mute">M</button>
                    <button class="btn-sm solo-btn" title="Solo">S</button>
                    <button class="btn-sm record-arm-btn" title="Record Arm (å½•éŸ³å‡†å¤‡)">R</button>
                    <span style="font-size:10px; color:#888;">${this.type.toUpperCase()}</span>
                </div>
            `;

            // 4. å°†å†…å®¹åŠ å…¥ Header
            headerDiv.appendChild(contentDiv);
            DOM.headers.appendChild(headerDiv);

            this.headerEl = headerDiv;
            this.nameEl = headerDiv.querySelector('.track-name');
            this.nameEl.style.cursor = "text"; // é¼ æ ‡æ‚¬åœæ˜¾ç¤ºä¸ºæ–‡æœ¬è¾“å…¥çŠ¶
            this.nameEl.title = "åŒå‡»é‡å‘½å";   // æ·»åŠ æç¤º

            this.nameEl.addEventListener('dblclick', (e) => {
                e.stopPropagation(); // é˜»æ­¢å†’æ³¡ï¼Œé˜²æ­¢è§¦å‘è½¨é“é€‰ä¸­æˆ–å…¶ä»–åŒå‡»é€»è¾‘

                const currentName = this.name;

                // 1. åˆ›å»ºè¾“å…¥æ¡†
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentName;

                // 2. è®¾ç½®æ ·å¼ï¼šè®©è¾“å…¥æ¡†å®Œç¾è¦†ç›–åŸæ–‡ä½ç½®ï¼Œä¸”é£æ ¼ç»Ÿä¸€
                input.style.width = '100%';
                input.style.height = '100%'; // æ’‘æ»¡å®¹å™¨
                input.style.background = 'rgba(0, 0, 0, 0.6)';
                input.style.color = '#fff';
                input.style.border = '1px solid var(--accent-blue)'; // æ¿€æ´»æ€è“è‰²è¾¹æ¡†
                input.style.borderRadius = '4px';
                input.style.padding = '0 4px';
                input.style.fontSize = '12px';
                input.style.fontWeight = 'normal';
                input.style.boxSizing = 'border-box';
                input.style.outline = 'none';

                // 3. æ›¿æ¢æ˜¾ç¤º
                this.nameEl.innerHTML = '';
                this.nameEl.appendChild(input);
                input.focus();
                input.select(); // è‡ªåŠ¨å…¨é€‰æ–‡æœ¬ï¼Œæ–¹ä¾¿ç›´æ¥ä¿®æ”¹

                // 4. å…³é”®ï¼šé˜»æ­¢è¾“å…¥æ¡†è‡ªèº«çš„ç‚¹å‡»å†’æ³¡
                // å¦åˆ™ç‚¹å‡»è¾“å…¥æ¡†å†…éƒ¨å¯èƒ½ä¼šè¢« headerDiv æ•è·ï¼Œå¯¼è‡´è½¨é“è¢«é€‰ä¸­/æ‹–æ‹½
                input.addEventListener('mousedown', ev => ev.stopPropagation());
                input.addEventListener('click', ev => ev.stopPropagation());
                input.addEventListener('dblclick', ev => ev.stopPropagation());

                // 5. å®Œæˆé‡å‘½åå‡½æ•°
                const finishRename = (save) => {
                    if (save) {
                        const newName = input.value.trim();
                        // è°ƒç”¨å·²æœ‰çš„ setName æ–¹æ³• (å®ƒä¼šé‡ç½® innerTextï¼Œä»è€Œç§»é™¤ input)
                        this.setName(newName || currentName);
                    } else {
                        this.setName(currentName); // è¿˜åŸæ—§å
                    }
                };

                // 6. ç›‘å¬äº‹ä»¶ï¼šå¤±ç„¦æˆ–å›è½¦ä¿å­˜ï¼ŒESCå–æ¶ˆ
                input.addEventListener('blur', () => finishRename(true));
                input.addEventListener('keydown', (ev) => {
                    if (ev.key === 'Enter') {
                        input.blur(); // è§¦å‘ blur ä¿å­˜
                    } else if (ev.key === 'Escape') {
                        finishRename(false); // è¿˜åŸ
                        ev.stopPropagation(); // é˜²æ­¢è§¦å‘å…¨å±€ ESC å…³é—­å¼¹çª—
                    }
                });
            });

            // 5. åˆ›å»º Lane (è½¨é“æ¡)
            const laneDiv = document.createElement('div');
            laneDiv.className = 'track-lane';
            laneDiv.id = `lane-${this.id}`;
            DOM.lanes.appendChild(laneDiv);
            this.laneEl = laneDiv;

            // ============================================================
            // ğŸ”¥ é¢œè‰²æŒ‰é’®é€»è¾‘ (ColorPickerMgr)
            // ============================================================

            // åˆ›å»ºé¢œè‰²è§¦å‘å™¨æŒ‰é’®
            const colorTrigger = document.createElement('div');
            colorTrigger.className = 'color-trigger-btn';
            colorTrigger.style.backgroundColor = this.ownColor;
            colorTrigger.title = "æ›´æ”¹è½¨é“é¢œè‰²";

            // å…³é”®ï¼šæ‰¾åˆ°åˆšæ‰é¢„ç•™çš„æ’æ§½ï¼ŒæŠŠæŒ‰é’®æ’è¿›å»
            const slot = contentDiv.querySelector('.track-color-slot');
            if (slot) {
                slot.appendChild(colorTrigger);
            }

            // ç»‘å®šäº‹ä»¶
            colorTrigger.addEventListener('mousedown', (e) => e.stopPropagation());
            colorTrigger.addEventListener('click', (e) => {
                e.stopPropagation();

                const oldColor = this.ownColor;

                ColorPickerMgr.open(
                    this.ownColor,
                    ` - ${this.name}`,
                    (finalColor) => {
                        // Confirm å›è°ƒ
                        if (finalColor !== oldColor) {
                            HistoryMgr.add({
                                type: 'change_color',
                                trackId: this.id,
                                oldColor: oldColor,
                                newColor: finalColor
                            });
                        }
                    },
                    (previewColor) => {
                        // Preview å›è°ƒ
                        this.ownColor = previewColor;
                        colorTrigger.style.backgroundColor = previewColor;

                        // è”åŠ¨ï¼šå¦‚æœå·²ç¼–ç»„ï¼Œè‡ªåŠ¨è§£æ•£
                        if (this.groupId) {
                            if (STATE.groups[this.groupId]) {
                                STATE.groups[this.groupId].trackIds.delete(this.id);
                            }
                            this.groupId = null;
                        }
                        this.refreshColor();
                        if (!STATE.isPlaying) {
                            renderer.render(scene, camera);
                        }
                    }
                );
            });

            // ============================================================
            // ä¸‹é¢æ˜¯åŸæœ‰çš„é€‰ä¸­ã€Muteã€Solo äº‹ä»¶ç»‘å®š...
            // ============================================================

            // B. ç‚¹å‡»é€‰ä¸­é€»è¾‘ (Left Click)
            headerDiv.addEventListener('mousedown', (e) => {
                // ... (ä¿æŒä½ åŸæœ‰çš„é€‰ä¸­é€»è¾‘ä¸å˜) ...
                if (e.target.tagName === 'BUTTON' || e.target.classList.contains('color-trigger-btn')) {
                    return;
                }
                if (e.button !== 0) return;
                // é˜²æ­¢ç‚¹å‡»é¢œè‰²é€‰æ‹©å™¨æˆ–è¾“å…¥æ¡†æ—¶è§¦å‘è½¨é“é€‰ä¸­
                if (e.target.tagName === 'INPUT') return;

                e.preventDefault();

                if (e.shiftKey) {
                    if (STATE.lastSelectedTrackId !== null) {
                        selectTrackRange(STATE.lastSelectedTrackId, this.id);
                    } else {
                        selectSingleTrack(this.id);
                    }
                }
                else if (e.ctrlKey || e.metaKey) {
                    toggleTrackSelection(this.id);
                }
                else {
                    selectSingleTrack(this.id);
                }
            });

            // C. å³é”®èœå•
            headerDiv.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (!STATE.selectedTrackIds.has(this.id)) {
                    selectSingleTrack(this.id);
                }
                showContextMenu(e.clientX, e.clientY);
            });

            // Mute / Solo æŒ‰é’®é€»è¾‘
            const muteBtn = contentDiv.querySelector('.mute-btn');
            const soloBtn = contentDiv.querySelector('.solo-btn');

            const armBtn = contentDiv.querySelector('.record-arm-btn');
            // åªæœ‰ MIDI è½¨é“æ‰æ˜¾ç¤º R æŒ‰é’® (Audio æš‚ä¸æ”¯æŒå½•éŸ³)
            if (this.type !== 'midi') {
                armBtn.style.display = 'none';
            } else {
                armBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.isArmed = !this.isArmed;
                    armBtn.classList.toggle('active-arm', this.isArmed);
                });
            }

            soloBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (STATE.selectedTrackIds.has(this.id)) {
                    const targetSoloState = !this.isSoloed;
                    STATE.selectedTrackIds.forEach(id => {
                        const track = STATE.tracks.find(t => t.id === id);
                        if (track) track.setSolo(targetSoloState);
                    });
                } else {
                    this.setSolo(!this.isSoloed);
                }
                updateAllTracksVisibility();
            });

            muteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (STATE.selectedTrackIds.has(this.id)) {
                    const targetMuteState = !this.isMuted;
                    STATE.selectedTrackIds.forEach(id => {
                        const track = STATE.tracks.find(t => t.id === id);
                        if (track) track.setMute(targetMuteState);
                    });
                } else {
                    this.setMute(!this.isMuted);
                }
                updateAllTracksVisibility();
            });
        }

        // åˆ·æ–°é¢œè‰²æ˜¾ç¤ºï¼ˆClip å’Œ 3D å¯¹è±¡ï¼‰
        refreshColor() {
            const finalColor = this.getEffectiveColor();

            // 1. æ›´æ–°å·¦ä¾§æŒ‡ç¤ºæ¡ (å¦‚æœæœ‰ç¼–ç»„)
            const ind = this.headerEl.querySelector('.group-indicator');
            if (this.groupId) {
                ind.style.backgroundColor = finalColor;
            } else {
                ind.style.backgroundColor = 'transparent';
            }

            // 2. æ›´æ–°è¯¥è½¨é“ä¸‹æ‰€æœ‰ Clip çš„é¢œè‰²
            this.clips.forEach(clip => {
                clip.updateColor(finalColor);
            });
            if (typeof renderer !== 'undefined' && !STATE.isPlaying) {
                renderer.render(scene, camera);
            }
        }

        addClip(start, duration, data, name, sourceFile = null) {
            const clip = new Clip(this, start, duration, data, name, sourceFile);
            this.clips.push(clip);
            STATE.clips.push(clip);

            clip.updateColor(this.getEffectiveColor());
            return clip;
        }

        clearClips() {
            // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šæ¸…é™¤ Clip æ—¶ï¼Œå¿…é¡»åŒæ­¥ä»å…¨å±€ STATE.clips ä¸­ç§»é™¤ ğŸ”¥ğŸ”¥ğŸ”¥
            this.clips.forEach(c => {
                c.destroy(); // é”€æ¯ DOM å’Œ 3D èµ„æº

                // ä»å…¨å±€ç¼“å­˜ä¸­å‰”é™¤ï¼Œé˜²æ­¢æ»‘å—è°ƒèŠ‚æ—¶â€œåƒµå°¸å¤æ´»â€
                const globalIdx = STATE.clips.indexOf(c);
                if (globalIdx > -1) {
                    STATE.clips.splice(globalIdx, 1);
                }
            });

            // æ¸…ç©ºå½“å‰è½¨é“çš„å¼•ç”¨
            this.clips = [];
        }

        // ğŸ”¥ æ–°å¢ï¼šç”¨äºæ›´æ–°è½¨é“åç§°çš„æ–¹æ³•
        setName(newName) {
            if (!newName) return;
            this.name = newName;
            if (this.nameEl) {
                this.nameEl.innerText = newName;
                this.nameEl.title = newName;
            }
        }
    }

    class Clip {
        constructor(track, start, duration, data, name, sourceFile = null) {
            this.id = STATE.nextClipId++; // ğŸ”¥ æ–°å¢ï¼šåˆ†é…å”¯ä¸€ ID
            this.track = track;
            this.startTime = start;
            this.duration = duration;
            this.data = data;
            this.name = name;
            this.sourceFile = sourceFile;
            this.trimOffset = 0;
            this.dom = null;
            this.mesh = null;

            // ç¼©ç•¥å›¾ Canvas å¼•ç”¨
            this.canvas = null;

            this.renderDOM();
            this.build3D();
        }

        renderDOM() {
            const el = document.createElement('div');
            el.className = 'clip';
            // ç§»é™¤æ–‡å­—ç›´æ¥æ˜¾ç¤ºï¼Œæ”¹ä¸ºæ‚¬æµ®æ˜¾ç¤ºï¼Œæˆ–è€…æ”¾åœ¨ corner
            el.title = this.name;
            el.style.backgroundColor = hexToRgba(this.track.color, 0.3); // èƒŒæ™¯ç¨å¾®é€æ˜ä¸€ç‚¹ï¼Œä¸ºäº†çœ‹æ¸…æ³¢å½¢
            el.style.borderColor = this.track.color;

            // 1. åˆ›å»ºåå­—æ ‡ç­¾ (ç»å¯¹å®šä½åœ¨å·¦ä¸Šè§’)
            const nameLabel = document.createElement('span');
            nameLabel.className = 'clip-name';
            nameLabel.innerText = this.name;
            nameLabel.style.position = 'absolute';
            nameLabel.style.left = '5px';
            nameLabel.style.top = '2px';
            nameLabel.style.fontSize = '10px';
            nameLabel.style.color = '#fff';
            nameLabel.style.zIndex = '2';
            el.appendChild(nameLabel);

            // 2. åˆ›å»º Canvas ç”¨äºç»˜åˆ¶æ³¢å½¢/éŸ³ç¬¦
            const canvas = document.createElement('canvas');
            canvas.style.position = 'absolute';
            canvas.style.left = '0';
            canvas.style.top = '0';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.zIndex = '1';
            el.appendChild(canvas);
            this.canvas = canvas;

            this.updateDOMPosition();

            document.getElementById(`lane-${this.track.id}`).appendChild(el);
            this.dom = el;

            // æ¸²æŸ“å®Œ DOM åç«‹å³ç»˜åˆ¶ç¼©ç•¥å›¾
            // ä½¿ç”¨ setTimeout ç¡®ä¿ DOM å·²ç»æŒ‚è½½ï¼Œèƒ½è·å–åˆ°å®½é«˜
            setTimeout(() => this.drawThumbnail(), 0);

            el.addEventListener('mousedown', (e) => this.initDrag(e));
        }

        updateDOMPosition() {
            if (!this.dom) return;
            const width = this.duration * STATE.pxPerSec;
            const height = 60; // è½¨é“é«˜åº¦ï¼Œæˆ–è€…åŠ¨æ€è·å–

            this.dom.style.left = (this.startTime * STATE.pxPerSec) + 'px';
            this.dom.style.width = width + 'px';

            // åªæœ‰å½“å®½åº¦å‘ç”Ÿæ˜¾è‘—å˜åŒ–æ—¶æ‰é‡ç»˜ï¼ŒèŠ‚çœæ€§èƒ½
            // åœ¨è¿™é‡Œæˆ‘ä»¬ç®€å•å¤„ç†ï¼šæ¯æ¬¡ Zoom æ”¹å˜ä½ç½®æ—¶ï¼Œå¯èƒ½éœ€è¦é‡è®¾ canvas åˆ†è¾¨ç‡
            if (this.canvas) {
                // è®¾ç½® Canvas çš„ç‰©ç†åˆ†è¾¨ç‡ (é¿å…æ¨¡ç³Š)
                this.canvas.width = width;
                this.canvas.height = height;
                // é‡ç»˜å†…å®¹
                this.drawThumbnail();
            }
        }

        drawThumbnail() {
            if (!this.canvas) return;
            const ctx = this.canvas.getContext('2d');
            const width = this.canvas.width;
            const height = this.canvas.height;
            const color = this.track.color;

            ctx.clearRect(0, 0, width, height);

            if (this.track.type === 'midi') {
                this.drawMidiThumbnail(ctx, width, height, color);
            } else if (this.track.type === 'audio') {
                this.drawAudioThumbnail(ctx, width, height, color);
            }
        }

        drawMidiThumbnail(ctx, width, height, color) {
            if (!this.data.notes) return;

            // 1. è®¡ç®—éŸ³é«˜èŒƒå›´ï¼Œä»¥ä¾¿å°†éŸ³ç¬¦æ˜ å°„åˆ° Canvas é«˜åº¦
            let minPitch = 127, maxPitch = 0;
            // å¦‚æœæƒ³ç»Ÿä¸€æ‰€æœ‰ Clip çš„è§†é‡ï¼Œå¯ä»¥å†™æ­» minPitch=21 (A0), maxPitch=108 (C8)
            // è¿™é‡Œä½¿ç”¨"è‡ªé€‚åº” Clip å†…å®¹"çš„ç¼©æ”¾
            this.data.notes.forEach(n => {
                if (n.midi < minPitch) minPitch = n.midi;
                if (n.midi > maxPitch) maxPitch = n.midi;
            });
            // å¢åŠ ä¸€ç‚¹ padding
            const range = Math.max(12, maxPitch - minPitch); // è‡³å°‘ä¿ç•™ä¸€ä¸ªå…«åº¦çš„èŒƒå›´
            minPitch -= 2;

            ctx.fillStyle = color;

            // 2. ç»˜åˆ¶æ¯ä¸€ä¸ªéŸ³ç¬¦
            this.data.notes.forEach(note => {
                // Xè½´ï¼šç›¸å¯¹æ—¶é—´
                const x = (note.time / this.duration) * width;
                const w = (note.duration / this.duration) * width;

                // Yè½´ï¼šéŸ³é«˜ (é«˜éŸ³åœ¨ä¸Šï¼Œä½éŸ³åœ¨ä¸‹ï¼ŒCanvas 0 æ˜¯é¡¶éƒ¨ï¼Œæ‰€ä»¥è¦åè¿‡æ¥)
                // normalizedPitch: 0.0 ~ 1.0
                const normalizedPitch = (note.midi - minPitch) / range;
                const h = height / range * 2; // éŸ³ç¬¦å—é«˜åº¦ï¼Œç¨å¾®åŠ åšä¸€ç‚¹
                const y = height - (normalizedPitch * height) - h;

                // ç»˜åˆ¶çŸ©å½¢ (ç¡®ä¿æœ€å°å®½åº¦ä¸º 1px ä»¥ä¾¿å¯è§)
                ctx.fillRect(x, y, Math.max(1, w), Math.max(2, h));
            });
        }

        drawAudioThumbnail(ctx, width, height, color) {
            if (!this.data) return;
            // éŸ³é¢‘æ•°æ®é€šå¸¸å¾ˆå¤§ï¼Œéœ€è¦é™é‡‡æ ·
            const rawData = this.data.getChannelData(0); // è·å–å·¦å£°é“
            const step = Math.ceil(rawData.length / width); // æ¯ä¸ªåƒç´ ä»£è¡¨å¤šå°‘ä¸ªé‡‡æ ·ç‚¹
            const amp = height / 2;

            ctx.fillStyle = color;
            ctx.beginPath();

            // ç»˜åˆ¶æ³¢å½¢ï¼šç®€æ˜“ç‰ˆ (ç»˜åˆ¶å‡æ–¹æ ¹æˆ–å³°å€¼)
            for (let i = 0; i < width; i++) {
                let min = 1.0;
                let max = -1.0;

                // æ‰¾å‡ºå½“å‰åƒç´ å¯¹åº”çš„æ—¶é—´çª—å£å†…çš„æœ€å¤§æœ€å°å€¼
                let startIndex = i * step;
                for (let j = 0; j < step; j++) {
                    const datum = rawData[startIndex + j];
                    if (datum < min) min = datum;
                    if (datum > max) max = datum;
                }

                // å°† -1~1 æ˜ å°„åˆ° Canvas é«˜åº¦
                const yLow = (1 + min) * amp;
                const yHigh = (1 + max) * amp;

                // ç»˜åˆ¶ä¸€æ¡ç«–çº¿ä»£è¡¨æ³¢å³°æ³¢è°·
                ctx.fillRect(i, height - yHigh, 1, yHigh - yLow);
            }
        }

        updateColor(color) {
            if(this.dom) {
                this.dom.style.backgroundColor = hexToRgba(color, 0.5);
                this.dom.style.borderColor = color;
            }
            this.drawThumbnail();

            if (this.mesh) {
                // å¦‚æœæ˜¯ MIDI (ShaderMaterial)
                if (this.track.type === 'midi') {
                    // æ³¨æ„ï¼šInstancedMesh çš„æè´¨åœ¨ mesh.material
                    const mat = this.mesh.material;
                    if (mat && mat.uniforms) {
                        // ç›´æ¥ä½¿ç”¨ .set() æ–¹æ³•æ›´æ–°ï¼Œè¿™æ ·ä¸ä¼šä¸¢å¤±å¼•ç”¨
                        mat.uniforms.uBaseColor.value.set(color).multiplyScalar(0.8);
                        mat.uniforms.uActiveColor.value.set(color).multiplyScalar(1.5).addScalar(0.3);
                    }
                }
                // å¦‚æœæ˜¯ Audio (ç°åœ¨ä¹Ÿæ˜¯ ShaderMaterial äº†)
                else {
                    const child = this.mesh.children[0]; // Audio æ˜¯ Group -> InstancedMesh
                    if (child && child.material) {
                        const mat = child.material;

                        // ğŸ”¥ ä¿®å¤ï¼šåˆ¤æ–­æ˜¯å¦ä¸º ShaderMaterial (æ£€æŸ¥ uniforms)
                        if (mat.uniforms && mat.uniforms.uBaseColor) {
                            mat.uniforms.uBaseColor.value.set(color);
                        }
                        // å…¼å®¹æ—§é€»è¾‘ (é˜²å®ˆæ€§ç¼–ç¨‹)
                        else if (mat.color) {
                            mat.color.set(color);
                        }
                    }
                }
            }
        }

        initDrag(e) {
            e.preventDefault();
            e.stopPropagation(); // é˜²æ­¢å†’æ³¡åˆ° timeline è§¦å‘ scrubbing

            if (!STATE.selectedClips.has(this)) {
                if (!e.shiftKey) {
                    selectClip(this); // å®ƒæ˜¯å”¯ä¸€çš„
                } else {
                    selectClip(this, true); // åŠ é€‰
                }
            }

            const startX = e.clientX;
            const startLeft = parseFloat(this.dom.style.left) || 0;

            const initialStates = [];
            STATE.selectedClips.forEach(clip => {
                initialStates.push({
                    clip: clip,
                    originalStart: clip.startTime,
                    dom: clip.dom
                });
            });

            // ğŸ”¥ è®°å½•å¼€å§‹æ—¶çš„çŠ¶æ€ (ç”¨äº Undo)
            const originalStartTime = this.startTime;

            const onMove = (mv) => {
                autoScroll(mv.clientY);
                const deltaPx = mv.clientX - startX;
                const deltaTime = deltaPx / STATE.pxPerSec;

                // ğŸ”¥ 3. æ‰¹é‡æ›´æ–°æ‰€æœ‰é€‰ä¸­çš„ Clip
                initialStates.forEach(state => {
                    let newStart = state.originalStart + deltaTime;
                    if (newStart < 0) newStart = 0; // è¾¹ç•Œæ£€æŸ¥

                    state.clip.startTime = newStart;
                    state.clip.updateDOMPosition();
                    state.clip.update3DPosition();
                });

                updateTotalDuration();
            };

            const onUp = () => {
                window.removeEventListener('mousemove', onMove);
                window.removeEventListener('mouseup', onUp);

                if (initialStates.length > 0) {
                    const first = initialStates[0];
                    if (Math.abs(first.clip.startTime - first.originalStart) > 0.01) {
                        // å¯ä»¥åœ¨è¿™é‡Œè§¦å‘ä¸€æ¬¡ä¿å­˜æˆ–æ—¥å¿—
                        console.log(`ç§»åŠ¨äº† ${initialStates.length} ä¸ª Clip`);
                    }
                }
            };

            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onUp);
        }

        // --- 3D æ„å»ºé€»è¾‘ ---
        build3D() {
            if (this.track.type === 'midi') {
                this.buildMidiMesh();
            } else if (this.track.type === 'audio') {
                this.buildAudioMesh();
            }
            if (this.mesh) {
                // æˆ‘ä»¬éœ€è¦é‡æ–°è®¡ç®—å½“å‰ Clip æ˜¯å¦åº”è¯¥å¯è§
                const hasSolo = STATE.tracks.some(t => t.isSoloed);
                let shouldBeVisible = true;
                if (hasSolo) {
                    shouldBeVisible = this.track.isSoloed && !this.track.isMuted;
                } else {
                    shouldBeVisible = !this.track.isMuted;
                }
                this.mesh.visible = shouldBeVisible;
            }
        }

        buildMidiMesh() {
            // æ¸…ç†æ—§çš„
            if (this.mesh) { scene.remove(this.mesh); }

            const notes = this.data.notes;
            if (!notes || notes.length === 0) return;

            let geometry;

            // ... (ä¿æŒåŸæœ¬çš„å½¢çŠ¶åˆ¤æ–­ switch case ä»£ç ä¸å˜) ...
            switch (STATE.noteShape) {
                case 'box': geometry = new THREE.BoxGeometry(1, 1, 1); break;
                case 'box-line': geometry = new THREE.BoxGeometry(1, 1, 1); break;
                case 'cylinder': geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16); geometry.rotateZ(Math.PI / 2); break;
                case 'hexagon': geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 6); geometry.rotateZ(Math.PI / 2); break;
                case 'diamond': geometry = new THREE.OctahedronGeometry(0.5); break;
                case 'torus': geometry = new THREE.TorusGeometry(0.4, 0.15, 8, 20); break;
                case 'knot': geometry = new THREE.TorusKnotGeometry(0.35, 0.1, 32, 8); break;
                case 'cone': geometry = new THREE.ConeGeometry(0.5, 1, 16); geometry.rotateZ(Math.PI / 2); break;
                case 'custom':
                    geometry = customGeometry ? customGeometry.clone() : new THREE.SphereGeometry(0.5, 16, 16);
                    break;
                case 'capsule':
                default: geometry = new THREE.SphereGeometry(0.5, 16, 16); break;
            }

            geometry.boundingSphere = new THREE.Sphere(new THREE.Vector3(), 10000000);

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uPlayheadX: { value: 0 },
                    uGlowRadius: { value: 35.0 },
                    uBaseColor: { value: new THREE.Color(this.track.color).multiplyScalar(0.8) },
                    uActiveColor: { value: new THREE.Color(this.track.color).multiplyScalar(1.5).addScalar(0.3) },
                    uHighlightColor: { value: currentHighlightColor },
                    uHighlightWidth: { value: currentHighlightWidth },
                    uHighlightBrightness: { value: currentHighlightBrightness }, // ğŸ”¥ æ–°å¢
                    uShowEdges: { value: STATE.noteShape === 'box-line' ? 1.0 : 0.0 },
                    uEnableFade: { value: STATE.enableMidiFade ? 1.0 : 0.0 }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                transparent: true,
                side: THREE.DoubleSide,
                depthTest: true,
                depthWrite: true
            });
            activeShaderMaterials.push(material);

            const mesh = new THREE.InstancedMesh(geometry, material, notes.length);
            mesh.frustumCulled = false;
            const extraLengths = new Float32Array(notes.length);
            const dummy = new THREE.Object3D();

            const minPitch = 21;
            const pitchRange = 88;
            const heightStep = (60 / pitchRange) * STATE.noteHeightScale;

            // ğŸ”¥ ä¼˜åŒ–ï¼šç›´æ¥è¯»å–ç¼“å­˜çš„æ’åï¼Œä¸å†é‡å¤è®¡ç®—
            const myRank = this.track.zRank || 0;
            const zStep = STATE.zSeparation;
            const zOffset = myRank * zStep;

            notes.forEach((note, i) => {
                const noteTime = note.time;
                const duration = note.duration;

                const x = (noteTime * STATE.playbackSpeed) + (duration * STATE.playbackSpeed / 2);
                const centerOffset = 30 * STATE.noteHeightScale;
                const y = (note.midi - minPitch) * heightStep - centerOffset;

                const width3D = duration * STATE.playbackSpeed;
                const thickness = 0.8 * heightStep * STATE.noteThickness;

                // åº”ç”¨ä½ç½® (ç›´æ¥ä½¿ç”¨ zOffset)
                dummy.position.set(x, y, zOffset);
                dummy.scale.set(thickness, thickness, thickness * 0.9);

                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);

                let extraLen = (width3D / thickness) - 1.0;
                extraLengths[i] = Math.max(0, extraLen);
            });

            geometry.setAttribute('aExtraLength', new THREE.InstancedBufferAttribute(extraLengths, 1));

            // ğŸ”¥ è®¡ç®—åŒ…å›´çƒï¼Œå¼€å¯å‰”é™¤
            mesh.geometry.computeBoundingSphere();
            // ç”±äºæ˜¯ InstancedMeshï¼Œæˆ‘ä»¬éœ€è¦æ‰‹åŠ¨æ‰©å¤§åŒ…å›´çƒä»¥è¦†ç›–æ‰€æœ‰å®ä¾‹
            // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„ä¼°ç®—æ–¹æ³•ï¼Œè¦†ç›–æ•´é¦–æ­Œçš„é•¿åº¦
            const durationX = this.duration * STATE.playbackSpeed;
            const centerX = this.startTime * STATE.playbackSpeed + durationX / 2;
            const radius = Math.max(durationX, 2000); // ä¼°ç®—åŠå¾„

            mesh.boundingSphere = new THREE.Sphere(new THREE.Vector3(centerX, 0, 0), radius);
            mesh.frustumCulled = true; // âœ… å¼€å¯å‰”é™¤

            this.mesh = mesh; // ç›´æ¥èµ‹å€¼
            scene.add(this.mesh);
            this.update3DPosition();
        }

        buildAudioMesh() {
            if (!this.data) return;
            // 1. æ¸…ç†æ—§æ¨¡å‹
            if (this.mesh) {
                this.mesh.traverse((child) => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            // ğŸ”¥ å…³é”®ï¼šä»å…¨å±€æ›´æ–°åˆ—è¡¨ä¸­ç§»é™¤æ—§æè´¨
                            const idx = activeShaderMaterials.indexOf(child.material);
                            if (idx > -1) activeShaderMaterials.splice(idx, 1);

                            child.material.dispose();
                        }
                    }
                });
                scene.remove(this.mesh);
            }

            const rawData = this.data.getChannelData(0);
            const visualWidth = this.duration * STATE.playbackSpeed;

            const density = 0.4;
            let samples = Math.floor(visualWidth * density);
            samples = Math.max(10, Math.min(50000, samples));
            const step = Math.floor(rawData.length / samples);

            const baseMidiHeight = 60 * STATE.noteHeightScale;
            const maxAmp = baseMidiHeight / 2;
            const finalScale = maxAmp * STATE.audioGain;
            const lineWidth = 0.2;

            const geometry = new THREE.BoxGeometry(1, 1, 1);

            // ğŸ”¥ 2. ä½¿ç”¨ ShaderMaterial æ›¿æ¢åŸæœ‰çš„ MeshBasicMaterial
            // è¿™æ ·æˆ‘ä»¬æ‰èƒ½æ§åˆ¶åƒç´ çº§çš„æ˜¾ç¤º/éšè—
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uBaseColor: { value: new THREE.Color(this.track.color) },
                    uOpacity: { value: 0.25 }, // é»˜è®¤æ³¢å½¢é€æ˜åº¦
                    uPlayheadX: { value: 0.0 }, // æ’­æ”¾å¤´ä½ç½®
                    uEnableFade: { value: STATE.enableMidiFade ? 1.0 : 0.0 } // åŒæ­¥æ¸æ˜¾å¼€å…³
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        // å¤„ç† InstancedMesh çš„çŸ©é˜µå˜æ¢
                        vec4 worldPosition = modelMatrix * instanceMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * viewMatrix * worldPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 uBaseColor;
                    uniform float uOpacity;
                    uniform float uPlayheadX;
                    uniform float uEnableFade;
                    varying vec3 vWorldPosition;

                    void main() {
                        float alpha = uOpacity;

                        // --- å®æ—¶æ¸æ˜¾é€»è¾‘ ---
                        if (uEnableFade > 0.5) {
                            float dist = uPlayheadX - vWorldPosition.x;

                            if (dist < 0.0) {
                                // æœªæ¥çš„æ³¢å½¢ï¼šç›´æ¥éšè—
                                discard;
                            } else {
                                // å·²æ’­æ”¾çš„æ³¢å½¢ï¼šå¹³æ»‘æ·¡å…¥ (0 -> 1)
                                alpha *= smoothstep(0.0, 15.0, dist);
                            }
                        }

                        gl_FragColor = vec4(uBaseColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false, // ä¿æŒä¸å†™å…¥æ·±åº¦ï¼Œé˜²æ­¢æ³¢å½¢é®æŒ¡å…¶ä»–ç‰©ä½“
                side: THREE.DoubleSide
            });

            // ğŸ”¥ 3. åŠ å…¥åˆ°å…¨å±€æ›´æ–°åˆ—è¡¨
            // è¿™æ · animate() å¾ªç¯é‡Œçš„ uPlayheadX æ›´æ–°é€»è¾‘å°±èƒ½ä½œç”¨äºéŸ³é¢‘äº†
            activeShaderMaterials.push(material);

            const mesh = new THREE.InstancedMesh(geometry, material, samples);
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            const dummy = new THREE.Object3D();

            for (let i = 0; i < samples; i++) {
                const index = Math.min(i * step, rawData.length - 1);
                let val = rawData[index];
                if (isNaN(val) || !isFinite(val)) val = 0;

                val = val * finalScale;
                const limit = baseMidiHeight * 0.5;
                val = Math.max(-limit, Math.min(limit, val));

                const x = (i / samples) * (this.duration * STATE.playbackSpeed);
                const totalHeight = Math.max(0.2, Math.abs(val * 2));

                dummy.position.set(x, 0, -15);
                dummy.scale.set(lineWidth, totalHeight, 0.5);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            }

            mesh.instanceMatrix.needsUpdate = true;
            mesh.frustumCulled = false;

            this.mesh = new THREE.Group();
            this.mesh.add(mesh);

            scene.add(this.mesh);
            this.update3DPosition();
        }

        update3DPosition() {
            if (this.mesh) {
                // 3D åœºæ™¯é‡Œçš„ä½ç½® = Clip å¼€å§‹æ—¶é—´ * æ’­æ”¾é€Ÿåº¦
                this.mesh.position.x = this.startTime * STATE.playbackSpeed;
            }
        }

        rebuildMesh() {
            // é¢œè‰²æ”¹å˜æ—¶è°ƒç”¨
            this.build3D();
        }

        // åœ¨ class Clip ä¸­
        destroy() {
            // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šåˆ é™¤ Audio Clip æ—¶ï¼ŒåŒæ­¥åœæ­¢å¹¶æ¸…ç†åå°æ’­æ”¾å™¨
            if (STATE.activeAudioClip === this) {
                // 1. å¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œåœæ­¢å…¨å±€æ’­æ”¾çŠ¶æ€
                if (STATE.isPlaying) {
                    STATE.isPlaying = false;
                    DOM.playBtn.innerText = "PLAY (Space)";
                    DOM.playBtn.classList.remove('btn-primary');
                }

                // 2. æ¸…ç† DOM Audio å…ƒç´  (åœæ­¢å‘å£°)
                DOM.audio.pause();
                DOM.audio.removeAttribute('src');
                DOM.audio.load(); // å¿…é¡»è°ƒç”¨ load æ‰ä¼šçœŸæ­£é‡Šæ”¾èµ„æºå’Œé‡ç½®çŠ¶æ€

                // 3. æ¸…ç©ºå…¨å±€å¼•ç”¨
                STATE.activeAudioClip = null;
            }

            // --- ä»¥ä¸‹æ˜¯åŸæœ‰çš„èµ„æºæ¸…ç†é€»è¾‘ ---

            if (this.dom) this.dom.remove();

            if (this.mesh) {
                // é€’å½’éå†æ‰€æœ‰å­å¯¹è±¡
                this.mesh.traverse((child) => {
                    if (child.isMesh || child.isLine || child.isLineSegments) {
                        // 1. é‡Šæ”¾å‡ ä½•ä½“ (æ˜¾å­˜å¤§å¤´)
                        if (child.geometry) {
                            child.geometry.dispose();
                        }

                        // 2. é‡Šæ”¾æè´¨å’Œè´´å›¾
                        if (child.material) {
                            // å¤„ç†æè´¨æ•°ç»„
                            const mats = Array.isArray(child.material) ? child.material : [child.material];

                            mats.forEach(m => {
                                const idx = activeShaderMaterials.indexOf(m);
                                if (idx > -1) activeShaderMaterials.splice(idx, 1);
                                // é‡Šæ”¾æè´¨æœ¬èº«
                                m.dispose();

                                // é‡Šæ”¾æè´¨ä¸Šçš„è´´å›¾ (Texture)
                                for (const key of Object.keys(m)) {
                                    const val = m[key];
                                    if (val && val.isTexture) {
                                        val.dispose();
                                    }
                                }

                                // é‡Šæ”¾ ShaderMaterial çš„ uniforms é‡Œçš„è´´å›¾
                                if (m.uniforms) {
                                    for (const key of Object.keys(m.uniforms)) {
                                        const val = m.uniforms[key].value;
                                        if (val && val.isTexture) {
                                            val.dispose();
                                        }
                                    }
                                }
                            });
                        }
                    }
                });

                // ä»åœºæ™¯ç§»é™¤
                scene.remove(this.mesh);
            }

            // é‡Šæ”¾ç¼©ç•¥å›¾ Canvas å†…å­˜
            if (this.canvas) {
                this.canvas.width = 0;
                this.canvas.height = 0;
                this.canvas = null;
            }

            // æ–­å¼€å¼•ç”¨
            this.mesh = null;
            this.dom = null;
            this.data = null; // é‡Šæ”¾éŸ³é¢‘/MIDIæ•°æ®å¼•ç”¨
        }
    }

    function serializeClip(clip) {
        return {
            id: clip.id,
            start: clip.startTime,
            duration: clip.duration, // ç¡®ä¿ duration è¢«ä¿å­˜
            name: clip.name,
            sourceData: clip.sourceFile,
            // åªæœ‰ MIDI æ‰æœ‰ notesï¼ŒéŸ³é¢‘åˆ™æ˜¯ undefined
            notes: clip.track.type === 'midi' && clip.data.notes
                ? JSON.parse(JSON.stringify(clip.data.notes))
                : null
        };
    }

    function selectSingleTrack(id) {
        STATE.selectedTrackIds.clear();
        STATE.selectedTrackIds.add(id);

        STATE.lastSelectedTrackId = id;

        updateSelectionUI();

        // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šè°ƒç”¨åŒæ­¥å‡½æ•°
        syncArmWithSelection();
    }

    // ğŸ”¥ æ–°å¢ï¼šå°†å½•éŸ³å‡†å¤‡çŠ¶æ€(R)ä¸é€‰ä¸­çŠ¶æ€(Selection) å¼ºåˆ¶åŒæ­¥
    function syncArmWithSelection() {
        STATE.tracks.forEach(track => {
            // åªå¤„ç† MIDI è½¨é“
            if (track.type === 'midi') {
                // åˆ¤æ–­è¯¥è½¨é“å½“å‰æ˜¯å¦è¢«é€‰ä¸­
                const isSelected = STATE.selectedTrackIds.has(track.id);

                // å¦‚æœçŠ¶æ€ä¸ä¸€è‡´ï¼Œåˆ™æ›´æ–°
                if (track.isArmed !== isSelected) {
                    track.isArmed = isSelected;

                    // æ›´æ–° UI æŒ‰é’®æ ·å¼
                    const btn = track.headerEl.querySelector('.record-arm-btn');
                    if (btn) {
                        if (isSelected) btn.classList.add('active-arm');
                        else btn.classList.remove('active-arm');
                    }
                }
            }
        });
    }

    function bindToggle(headerId, contentId, defaultDisplay, storageKey) {
        const header = document.getElementById(headerId);
        const content = document.getElementById(contentId);

        if (header && content) {
            // 1. Check LocalStorage on Load
            // If user previously closed it, 'none' will be returned.
            // If it's the first visit, savedState is null, so we use defaultDisplay.
            const savedState = localStorage.getItem(storageKey);
            const initialState = savedState !== null ? savedState : defaultDisplay;

            // Apply initial state
            content.style.display = initialState;
            header.style.opacity = initialState === 'none' ? '0.7' : '1';

            // 2. Click Event
            header.addEventListener('click', () => {
                if (content.style.display === 'none') {
                    // Expand
                    content.style.display = defaultDisplay;
                    header.style.opacity = '1';
                } else {
                    // Collapse
                    content.style.display = 'none';
                    header.style.opacity = '0.7';
                }

                // 3. Save new state to LocalStorage
                localStorage.setItem(storageKey, content.style.display);
            });
        }
    }

    // Bind Top-Right Panel (View Parameters)
    // Key: 'mv_viz_panel_state'
    bindToggle('viz-header', 'viz-content', 'block', 'mv_viz_panel_state');

    // Bind Top-Left Panel (Shortcuts)
    // Key: 'mv_shortcut_panel_state'
    bindToggle('shortcut-header', 'shortcut-content', 'grid', 'mv_shortcut_panel_state');

    function selectTrackRange(startId, endId) {
        // 1. æ‰¾åˆ°ä¸¤ä¸ªè½¨é“åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•ä½ç½®
        const startIndex = STATE.tracks.findIndex(t => t.id === startId);
        const endIndex = STATE.tracks.findIndex(t => t.id === endId);

        if (startIndex === -1 || endIndex === -1) return;

        // 2. ç¡®å®šèŒƒå›´
        const min = Math.min(startIndex, endIndex);
        const max = Math.max(startIndex, endIndex);

        // 3. é‡ç½®é€‰æ‹© (Shifté€‰æ‹©é€šå¸¸æ˜¯é‡æ–°å®šä¹‰é€‰åŒº)
        STATE.selectedTrackIds.clear();

        // 4. å¾ªç¯é€‰ä¸­èŒƒå›´å†…æ‰€æœ‰è½¨é“
        for (let i = min; i <= max; i++) {
            STATE.selectedTrackIds.add(STATE.tracks[i].id);
        }

        updateSelectionUI();

        // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šè°ƒç”¨åŒæ­¥å‡½æ•° (æ”¯æŒè¿é€‰æ¿€æ´»)
        syncArmWithSelection();
    }

    document.getElementById('clearTextureBtn').addEventListener('click', () => {
        // ğŸ”¥ ä¿®æ­£ç‚¹ 1ï¼šæŠŠ getCurrentWorldParams() æ”¹ä¸º getCurrentSpherical()
        // æ£€æŸ¥æ˜¯å¦æœ‰ä¸œè¥¿å¯ä»¥æ¸…é™¤ (åŒ…æ‹¬æ£€æŸ¥è§†è§’æ˜¯å¦æ˜¯é»˜è®¤å€¼)
        const currentView = ViewMgr.getCurrentSpherical();
        const isViewDefault = JSON.stringify(currentView) === JSON.stringify(ViewMgr.defaults);

        const hasVisuals = currentBgBase64 || !isViewDefault;

        if (hasVisuals) {
            // ğŸ”¥ 1. è®°å½•å†å²
            HistoryMgr.add({
                type: 'clear_visuals',
                // ä¿å­˜æ—§çš„è§†è§‰æ•°æ®
                oldBgData: currentBgBase64,
                oldBgType: currentBgType,
                // ğŸ”¥ ä¿®æ­£ç‚¹ 2ï¼šè¿™é‡Œä¹Ÿè¦æ”¹ä¸º getCurrentSpherical()
                oldView: currentView
            });

            // ... (ä¸­é—´çš„æ¸…é™¤ä»£ç ä¿æŒä¸å˜) ...
            currentHighlightColor.setHex(0xffffff);
            currentHighlightBrightness = 1.0; // ğŸ”¥ é‡ç½®äº®åº¦
            const hlInput = document.getElementById('highlightColorInput');
            if(hlInput) hlInput.value = "#ffffff";

            STATE.clips.forEach(clip => {
                if (clip.mesh && clip.track.type === 'midi') {
                    // ... éå† children æˆ– materials
                    child.material.uniforms.uHighlightColor.value.setHex(0xffffff);
                    // ğŸ”¥ é‡ç½® uniforms
                    if(child.material.uniforms.uHighlightBrightness) {
                        child.material.uniforms.uHighlightBrightness.value = 1.0;
                    }
                }
            });
            refreshAllMidiMeshes();

            // --- æ¸…é™¤èƒŒæ™¯ ---
            if (bgMesh) bgMesh.visible = false;
            if (bgMaterial && bgMaterial.uniforms.tMap) bgMaterial.uniforms.tMap.value = null;
            if (bgVideoElement) {
                bgVideoElement.pause();
                bgVideoElement.src = "";
                bgVideoElement.load();
                bgVideoElement = null;
            }
            currentBgBase64 = null;
            currentBgType = null;
            bgTexture = null;

            // --- 3. é‡ç½®è§†è§’ ---
            ViewMgr.reset();

            const starToggle = document.getElementById('starfieldToggle');
            if (starToggle) {
                // åˆå§‹åŒ–ï¼šé»˜è®¤å¼€å¯
                setStarfieldState(true);

                starToggle.addEventListener('change', (e) => {
                    setStarfieldState(e.target.checked);
                });
            }

            setStarfieldState(true);

            requestAnimationFrame(() => {
                onResize();
            });

            console.log("å·²æ¸…é™¤è§†è§‰æ•ˆæœåŠè§†è§’ (å¯æŒ‰ Ctrl+Z æ’¤å›)");
        }
    });

    function initPreviewSystem() {
        const container = document.getElementById('preview-canvas-container');
        const width = container.clientWidth || 800;
        const height = container.clientHeight || 600;

        // 1. åˆå§‹åŒ–ç‹¬ç«‹åœºæ™¯
        previewScene = new THREE.Scene();
        previewScene.background = new THREE.Color(0x111111);

        // æ·»åŠ è¾…åŠ©ç½‘æ ¼ (Grid)
        const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
        previewScene.add(gridHelper);

        // æ·»åŠ åæ ‡è½´è¾…åŠ© (çº¢X ç»¿Y è“Z)
        const axesHelper = new THREE.AxesHelper(3);
        previewScene.add(axesHelper);

        // 2. ç›¸æœº
        previewCamera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
        previewCamera.position.set(0, 5, 10);
        previewCamera.lookAt(0, 0, 0);

        // 3. ç¯å…‰ (ä¸ºäº†çœ‹æ¸…æ¨¡å‹ç»“æ„)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        previewScene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        previewScene.add(dirLight);

        // 4. æ¸²æŸ“å™¨
        previewRenderer = new THREE.WebGLRenderer({ antialias: true });
        previewRenderer.setSize(width, height);
        container.appendChild(previewRenderer.domElement);

        // 5. ç®€å•çš„è½¨é“æ§åˆ¶
        previewControls = new OrbitControls(previewCamera, previewRenderer.domElement);
        previewControls.enableDamping = false;

        // 6. ç»‘å®šæ»‘å—äº‹ä»¶
        ['rot-x', 'rot-y', 'rot-z'].forEach(id => {
            document.getElementById(id).addEventListener('input', updatePreviewRotation);
        });

        // 7. ç»‘å®šæŒ‰é’®
        document.getElementById('cancelPreviewBtn').addEventListener('click', closePreviewModal);
        document.getElementById('confirmImportBtn').addEventListener('click', confirmImportModel);

        // çª—å£å¤§å°å˜åŒ–ç›‘å¬
        const resizeObserver = new ResizeObserver(() => {
            if(container.clientWidth > 0) {
                previewCamera.aspect = container.clientWidth / container.clientHeight;
                previewCamera.updateProjectionMatrix();
                previewRenderer.setSize(container.clientWidth, container.clientHeight);
            }
        });
        resizeObserver.observe(container);
    }

    function openPreviewModal(geometry, material) {
        document.getElementById('model-preview-modal').style.display = 'flex';
        if (!previewRenderer) initPreviewSystem();

        tempLoadedGeometry = geometry.clone();
        tempLoadedMaterial = material; // ğŸ”¥ ä¿å­˜æè´¨

        // ... é‡ç½®æ»‘å— ...

        createPreviewMeshes(geometry, material); // ä¼ é€’ä¸‹å»
        animatePreview();
    }

    function closePreviewModal() {
        document.getElementById('model-preview-modal').style.display = 'none';
        cancelAnimationFrame(previewAnimationId);
        // æ¸…ç†å†…å­˜
        if(previewMeshOriginal) {
            previewScene.remove(previewMeshOriginal);
            previewMeshOriginal = null;
        }
        if(previewMeshStretched) {
            previewScene.remove(previewMeshStretched);
            previewMeshStretched = null;
        }
    }

    function createPreviewMeshes(geometry, material) {
        // ... æ¸…ç†æ—§ Mesh ...
        if (previewMeshOriginal) previewScene.remove(previewMeshOriginal);
        if (previewMeshStretched) previewScene.remove(previewMeshStretched);

        // --- 1. å·¦ä¾§ï¼šä½¿ç”¨åŸå§‹æè´¨ (å¦‚æœæœ‰) ---
        let matOriginal;
        let mapTexture = null;

        if (material) {
            matOriginal = material; // ç›´æ¥ç”¨åŸå§‹æè´¨
            if (material.map) mapTexture = material.map; // æå–è´´å›¾
        } else {
            matOriginal = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
        }

        previewMeshOriginal = new THREE.Mesh(geometry, matOriginal);
        previewMeshOriginal.position.set(-2, 0, 0);
        previewScene.add(previewMeshOriginal);

        // --- 2. å³ä¾§ï¼šæ¨¡æ‹Ÿæ‹‰ä¼¸ ---
        const useTextureChecked = document.getElementById('preview-use-texture').checked;

        // åªæœ‰å½“æœ‰è´´å›¾ ä¸” å‹¾é€‰äº†ä¿ç•™æè´¨æ—¶ï¼Œæ‰å¯ç”¨
        const enableTexture = useTextureChecked && (mapTexture !== null);

        // å¯ç”¨å¤é€‰æ¡†çŠ¶æ€æ›´æ–°
        const checkbox = document.getElementById('preview-use-texture');
        checkbox.disabled = !mapTexture; // å¦‚æœæ²¡è´´å›¾ï¼Œç¦ç”¨å¤é€‰æ¡†
        if (!mapTexture) checkbox.checked = false;

        const matStretched = new THREE.ShaderMaterial({
            uniforms: {
                uPlayheadX: { value: 0 },
                uGlowRadius: { value: 10.0 },
                uBaseColor: { value: new THREE.Color(0xff00ff).multiplyScalar(0.5) }, // é»˜è®¤ç´«
                uActiveColor: { value: new THREE.Color(0xff00ff).addScalar(0.2) },
                // ğŸ”¥ ä¼ å…¥è´´å›¾
                uUseTexture: { value: enableTexture },
                uMap: { value: mapTexture || null }
            },
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            side: THREE.DoubleSide
        });

        previewMeshStretched = new THREE.Mesh(geometry.clone(), matStretched);
        previewMeshStretched.position.set(2, 0, 0);

        const count = previewMeshStretched.geometry.attributes.position.count;
        const extraLengths = new Float32Array(count).fill(4.0);
        previewMeshStretched.geometry.setAttribute('aExtraLength', new THREE.BufferAttribute(extraLengths, 1));

        previewScene.add(previewMeshStretched);
    }

    function updatePreviewRotation() {
        if (!tempLoadedGeometry) return;

        const rx = THREE.MathUtils.degToRad(document.getElementById('rot-x').value);
        const ry = THREE.MathUtils.degToRad(document.getElementById('rot-y').value);
        const rz = THREE.MathUtils.degToRad(document.getElementById('rot-z').value);

        // é‡æ–°ä»åŸå§‹æ•°æ®å…‹éš†ï¼Œé¿å…æ—‹è½¬ç´¯ç§¯
        const newGeo = tempLoadedGeometry.clone();

        // åº”ç”¨æ—‹è½¬çŸ©é˜µåˆ°å‡ ä½•ä½“ (Bake Rotation)
        newGeo.rotateX(rx);
        newGeo.rotateY(ry);
        newGeo.rotateZ(rz);

        // æ›´æ–°å·¦è¾¹é¢„è§ˆ
        previewMeshOriginal.geometry.dispose();
        previewMeshOriginal.geometry = newGeo;

        // æ›´æ–°å³è¾¹
        const stretchedGeo = newGeo.clone();
        // ... é‡æ–°ç»‘å®š aExtraLength ...
        const count = stretchedGeo.attributes.position.count;
        const extraLengths = new Float32Array(count).fill(4.0);
        stretchedGeo.setAttribute('aExtraLength', new THREE.BufferAttribute(extraLengths, 1));

        previewMeshStretched.geometry.dispose();
        previewMeshStretched.geometry = stretchedGeo;

        // ğŸ”¥ ç¡®ä¿å³ä¾§æè´¨çš„ uniform çŠ¶æ€æ˜¯æœ€æ–°çš„
        const useTexture = document.getElementById('preview-use-texture').checked;
        const map = tempLoadedMaterial ? tempLoadedMaterial.map : null;

        previewMeshStretched.material.uniforms.uUseTexture.value = useTexture && !!map;
        previewMeshStretched.material.uniforms.uMap.value = map;
    }

    function animatePreview() {
        previewAnimationId = requestAnimationFrame(animatePreview);
        previewControls.update();
        previewRenderer.render(previewScene, previewCamera);

        // è®©å³è¾¹çš„æ‹‰ä¼¸ä½“ç¼“æ…¢æ—‹è½¬å±•ç¤º
        if(previewMeshStretched) {
            // previewMeshStretched.rotation.y += 0.01;
        }
    }

    function confirmImportModel() {
        // è·å–å½“å‰ geometry (å·²ç»åŒ…å«äº†æ—‹è½¬)
        const finalGeometry = previewMeshOriginal.geometry.clone();

        // åº”ç”¨åˆ°å…¨å±€
        customGeometry = finalGeometry;
        STATE.noteShape = 'custom';

        // æ›´æ–° UI
        const shapeSelect = document.getElementById('noteShapeSelect');
        if (shapeSelect) shapeSelect.value = 'custom';

        // åˆ·æ–°ä¸»åœºæ™¯
        STATE.clips.forEach(c => {
            if (c.track.type === 'midi') c.build3D();
        });
        updateAllTracksVisibility();

        closePreviewModal();
        alert("æ¨¡å‹å·²åº”ç”¨ï¼");
    }

    function toggleTrackSelection(id) {
        if (STATE.selectedTrackIds.has(id)) {
            STATE.selectedTrackIds.delete(id);
            // å–æ¶ˆé€‰ä¸­æ—¶ï¼Œé€šå¸¸ä¿ç•™é”šç‚¹æˆ–ä¸å¤„ç†
        } else {
            STATE.selectedTrackIds.add(id);
            STATE.lastSelectedTrackId = id; // æ›´æ–°é”šç‚¹
        }

        updateSelectionUI();

        // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šè°ƒç”¨åŒæ­¥å‡½æ•° (æ”¯æŒå¤šé€‰æ¿€æ´»)
        syncArmWithSelection();
    }

    function updateSelectionUI() {
        STATE.tracks.forEach(t => {
            if (STATE.selectedTrackIds.has(t.id)) {
                t.headerEl.classList.add('selected');
            } else {
                t.headerEl.classList.remove('selected');
            }
        });
    }

    // --- ç¼–ç»„æ“ä½œ ---
    function createGroupForSelection() {
        if (STATE.selectedTrackIds.size === 0) return;

        // 1. åˆ›å»ºæ–°ç¼–ç»„ (é»˜è®¤é¢œè‰²éšæœºæˆ–å›ºå®š)
        const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16);
        const newGroup = new Group("Group " + STATE.nextGroupId, randomColor);
        STATE.groups[newGroup.id] = newGroup;

        // 2. å°†é€‰ä¸­çš„è½¨é“åŠ å…¥ç¼–ç»„
        STATE.selectedTrackIds.forEach(trackId => {
            const track = STATE.tracks.find(t => t.id === trackId);
            if (track) {
                // å¦‚æœå·²ç»åœ¨åˆ«çš„ç»„ï¼Œå…ˆé€€ç»„ï¼ˆç®€åŒ–é€»è¾‘ï¼šä¸æ”¯æŒåµŒå¥—ï¼‰
                if (track.groupId) {
                    const oldGroup = STATE.groups[track.groupId];
                    if(oldGroup) oldGroup.trackIds.delete(trackId);
                }

                track.groupId = newGroup.id;
                newGroup.trackIds.add(trackId);
                track.refreshColor(); // ğŸ”¥ ç«‹å³å˜è‰²
            }
        });

        console.log("Created Group:", newGroup);
    }

    function ungroupSelection() {
        STATE.selectedTrackIds.forEach(trackId => {
            const track = STATE.tracks.find(t => t.id === trackId);
            if (track && track.groupId) {
                const group = STATE.groups[track.groupId];
                if (group) group.trackIds.delete(trackId);

                track.groupId = null;
                track.refreshColor(); // ğŸ”¥ æ¢å¤å›è‡ªå·±çš„é¢œè‰²
            }
        });
    }

    function setGroupColor(color) {
        // æ‰¾åˆ°æ‰€æœ‰æ¶‰åŠçš„ç¼–ç»„ ID
        const affectedGroupIds = new Set();
        STATE.selectedTrackIds.forEach(tid => {
            const t = STATE.tracks.find(trk => trk.id === tid);
            if (t && t.groupId) affectedGroupIds.add(t.groupId);
        });

        // æ›´æ–°è¿™äº›ç¼–ç»„çš„é¢œè‰²
        affectedGroupIds.forEach(gid => {
            const group = STATE.groups[gid];
            if (group) {
                group.color = color;
                // åˆ·æ–°è¯¥ç»„ä¸‹æ‰€æœ‰è½¨é“
                group.trackIds.forEach(tid => {
                    const t = STATE.tracks.find(trk => trk.id === tid);
                    if (t) t.refreshColor();
                });
            }
        });
    }

    // è¾…åŠ©: Hex to Rgba
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // ==========================================
    // 3. 3D åœºæ™¯åˆå§‹åŒ– (Visualizer)
    // ==========================================
    let scene, camera, renderer, controls;
    let cameraTargetX = 0;

    function init3D() {
        const wrapper = document.getElementById('canvas-wrapper');
        let width = Math.max(2, wrapper.clientWidth);
        let height = Math.max(2, wrapper.clientHeight);

        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 50, 1000);

        camera = new THREE.PerspectiveCamera(45, width / height, 1, 5000);
        camera.position.set(0, 0, 200);

        scene.add(camera);

        renderer = new THREE.WebGLRenderer({
            antialias: true,
            powerPreference: "high-performance",
            alpha: true
        });

        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.setClearColor(0x000000, 0);
        renderer.setSize(width, height);
        renderer.setPixelRatio(1);
        wrapper.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = false;
        // controls.dampingFactor = 0.05;
        controls.target.set(0, 0, 0);

        wrapper.addEventListener('dblclick', (e) => {
            // æ£€æµ‹ Command (Mac) æˆ– Ctrl (Win)
            if (e.metaKey || e.ctrlKey) {
                e.preventDefault();

                // 1. è·å–å½“å‰çŠ¶æ€ (ä½œä¸ºæ—§çŠ¶æ€)
                const oldParams = ViewMgr.getCurrentSpherical();

                // 2. è·å–é»˜è®¤çŠ¶æ€ (ä½œä¸ºæ–°çŠ¶æ€)
                const newParams = ViewMgr.defaults; // { radius: 80, theta: 0, phi: -30, targetX: 0, targetY: 0 }

                // 3. æ‰§è¡Œé‡ç½®
                ViewMgr.reset();

                // 4. ğŸ”¥ è®°å½•å†å² (å…è®¸ Ctrl+Z æ’¤å›)
                // åªæœ‰å½“å½“å‰çŠ¶æ€å’Œé»˜è®¤çŠ¶æ€ä¸ä¸€æ ·æ—¶æ‰è®°å½•ï¼Œé¿å…é‡å¤è®°å½•æ— æ•ˆå†å²
                if (JSON.stringify(oldParams) !== JSON.stringify(newParams)) {
                    HistoryMgr.add({
                        type: 'change_view',
                        oldView: oldParams,
                        newView: newParams
                    });
                    console.log("è§†è§’å·²é‡ç½® (å¯æ’¤å›)");
                }
            }
        });

        initBlurSystem(width, height);

        // ==========================================
        // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šShader æ”¯æŒæ¨¡ç³Šå’Œé€æ˜
        // ==========================================
        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform sampler2D tMap; // è¿™é‡Œæ¥æ”¶çš„å°†æ˜¯å·²ç»æ¨¡ç³Šå¥½çš„çº¹ç†
            uniform float uOpacity;
            uniform float uBrightness;
            uniform float uContrast;
            uniform vec2 uUvScale;
            uniform vec2 uUvOffset;

            varying vec2 vUv;

            void main() {
                // UV å˜æ¢ (Cover/Contain)
                vec2 centerUv = (vUv - 0.5) * uUvScale + 0.5 + uUvOffset;

                // è¾¹ç•Œæ£€æŸ¥
                if (centerUv.x < 0.0 || centerUv.x > 1.0 || centerUv.y < 0.0 || centerUv.y > 1.0) {
    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); // ğŸ”¥ æ”¹ä¸º 0.0ï¼Œå˜æˆå®Œå…¨é€æ˜
    return;
}

                // ç›´æ¥é‡‡æ · (å› ä¸ºæ¨¡ç³Šå·²ç»åœ¨ç¦»å±æ¸²æŸ“é‡Œåšå®Œäº†)
                vec4 color = texture2D(tMap, centerUv);

                // åº”ç”¨å¯¹æ¯”åº¦
                color.rgb = (color.rgb - 0.5) * uContrast + 0.5;
                // åº”ç”¨äº®åº¦
                color.rgb += uBrightness;
                // åº”ç”¨é€æ˜åº¦
                gl_FragColor = vec4(color.rgb, uOpacity);
            }
        `;

        bgMaterial = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                tMap: { value: null },
                uOpacity: { value: 1.0 },
                uBrightness: { value: 0.0 },
                uContrast: { value: 1.0 },
                uUvScale: { value: new THREE.Vector2(1, 1) },
                uUvOffset: { value: new THREE.Vector2(0, 0) }
            },
            depthTest: false,
            depthWrite: false,
            side: THREE.DoubleSide,
            transparent: true
        });

        const geometry = new THREE.PlaneGeometry(1, 1);
        bgMesh = new THREE.Mesh(geometry, bgMaterial);
        bgMesh.position.z = -1000;
        bgMesh.visible = false;

        bgMesh.renderOrder = -999;

        camera.add(bgMesh);

        initStarfield();

        updateBackgroundSize();

        window.addEventListener('resize', onResize);
        animate();
    }

    function normalizeGeometry(geometry) {
        // 1. è®¡ç®—åŒ…å›´ç›’
        geometry.computeBoundingBox();
        const box = geometry.boundingBox;

        // 2. è®¡ç®—ä¸­å¿ƒç‚¹å¹¶åç§»ï¼Œä½¿å…¶å±…ä¸­åˆ° (0,0,0)
        const center = new THREE.Vector3();
        box.getCenter(center);
        geometry.translate(-center.x, -center.y, -center.z);

        // 3. è®¡ç®—æœ€å¤§å°ºå¯¸ï¼Œå°†å…¶ç¼©æ”¾åˆ° 1.0 å¤§å°
        // è¿™æ ·æ‰èƒ½é€‚é…æˆ‘ä»¬çš„ noteThickness å’Œ Shader
        const size = new THREE.Vector3();
        box.getSize(size);
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 1.0 / (maxDim || 1); // é˜²æ­¢é™¤ä»¥0

        geometry.scale(scale, scale, scale);

        // 4. æ—‹è½¬ä¿®æ­£ (å¯é€‰)ï¼šæœ‰äº›æ¨¡å‹å¯¼å…¥æ—¶æ˜¯è¶´ç€çš„ï¼Œè¿™é‡Œç»Ÿä¸€è®©å®ƒæœå‘ X è½´
        // å¦‚æœä½ çš„æ¨¡å‹é•¿å¾—å¥‡æ€ªï¼Œå¯èƒ½éœ€è¦è°ƒæ•´è¿™é‡Œï¼Œæˆ–è€…è®©ç”¨æˆ·è‡ªå·±å¤„ç†
        // geometry.rotateY(Math.PI / 2);

        return geometry;
    }

    const BLUR_SCALE = 0.5;

    function initBlurSystem(width, height) {
        width = Math.max(1, Math.floor(width * BLUR_SCALE));  // ğŸ”¥ å¼ºåˆ¶ç¼©å°
        height = Math.max(1, Math.floor(height * BLUR_SCALE));
        // 1. åˆ›å»ºç‹¬ç«‹çš„åœºæ™¯å’Œç›¸æœºï¼Œç”¨äºå¹•åå¤„ç†
        blurScene = new THREE.Scene();
        blurCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // 2. åˆ›å»ºä¸¤ä¸ªæ¸²æŸ“ç›®æ ‡ (Ping-Pong Buffer)
        // ä½¿ç”¨ Half Float ä»¥æ”¯æŒæ›´å¥½çš„è‰²å½©ç²¾åº¦ (é˜²è‰²å¸¦)ï¼Œå¦‚æœä¸æ”¯æŒä¼šè‡ªåŠ¨é™çº§
        const rtPars = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
            type: THREE.HalfFloatType // å…³é”®ï¼šé«˜ç²¾åº¦é˜²æ–­å±‚
        };

        // ä¸ºäº†æ€§èƒ½ï¼Œæ¨¡ç³Šç¼“å†²åŒºå¯ä»¥æ˜¯å±å¹•åˆ†è¾¨ç‡çš„ 1/2ï¼Œè‚‰çœ¼å‡ ä¹çœ‹ä¸å‡ºåŒºåˆ«ä½†å¿«4å€
        // è¿™é‡Œæš‚æ—¶ç”¨å…¨åˆ†è¾¨ç‡ä»¥ä¿è¯æœ€é«˜ç”»è´¨
        blurRtX = new THREE.WebGLRenderTarget(width, height, rtPars);
        blurRtY = new THREE.WebGLRenderTarget(width, height, rtPars);

        // 3. é€šç”¨çš„ 1D é«˜æ–¯æ¨¡ç³Š Shader
        const blurVertex = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1.0);
            }
        `;

        const blurFragment = `
            uniform sampler2D tMap;
            uniform vec2 uResolution;
            uniform vec2 uDirection; // (1,0) æ˜¯æ¨ªå‘, (0,1) æ˜¯çºµå‘
            uniform float uBlur;     // æ¨¡ç³ŠåŠå¾„
            varying vec2 vUv;

            // æ ‡å‡†é«˜æ–¯æƒé‡å…¬å¼
            float gaussian(float x, float sigma) {
                return 0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;
            }

            void main() {
                vec4 sum = vec4(0.0);
                float totalWeight = 0.0;

                // åŠ¨æ€ Sigma: æ¨¡ç³ŠåŠå¾„çš„ 1/2
                float sigma = max(uBlur * 0.5, 0.01);

                // é‡‡æ ·èŒƒå›´ï¼šæ ¹æ®æ¨¡ç³Šç¨‹åº¦åŠ¨æ€å†³å®šï¼Œè¿™é‡Œé™åˆ¶æœ€å¤§å¾ªç¯æ¬¡æ•°ä¿è¯æ€§èƒ½
                // èŒƒå›´ -20 åˆ° +20 (41æ¬¡é‡‡æ ·)ï¼Œé…åˆåŒé€šé“ç­‰æ•ˆäº 41x41 = 1681æ¬¡é‡‡æ ·ï¼
                float range = min(uBlur, 40.0);

                for(float i = -10.0; i <= 10.0; i++) {
                    if (abs(i) > range) continue; // è¶…å‡ºåŠå¾„è·³è¿‡

                    // æ ¸å¿ƒï¼šæ²¿ç€ uDirection æ–¹å‘åç§»
                    vec2 offset = vec2(i) * uDirection;
                    vec2 uvOffset = offset / uResolution;

                    float weight = gaussian(i, sigma);

                    sum += texture2D(tMap, vUv + uvOffset) * weight;
                    totalWeight += weight;
                }

                gl_FragColor = sum / totalWeight;
            }
        `;

        // 4. åˆ›å»ºæ¨ªå‘æè´¨
        blurMatX = new THREE.ShaderMaterial({
            vertexShader: blurVertex,
            fragmentShader: blurFragment,
            uniforms: {
                tMap: { value: null },
                uResolution: { value: new THREE.Vector2(width, height) },
                uDirection: { value: new THREE.Vector2(1, 0) }, // æ¨ªå‘
                uBlur: { value: 0 }
            },
            depthTest: false,
            depthWrite: false
        });

        // 5. åˆ›å»ºçºµå‘æè´¨
        blurMatY = blurMatX.clone();
        blurMatY.uniforms.uDirection.value.set(0, 1); // çºµå‘

        // 6. åˆ›å»ºä¸€ä¸ªå…¨å±å››è¾¹å½¢ç”¨äºæ¸²æŸ“
        blurMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), blurMatX);
        blurScene.add(blurMesh);
    }

    function updateBackgroundSize() {
        if (!bgMesh || !camera) return;

        // 1. è®¡ç®—ç›¸æœºåœ¨ z=-1000 å¤„çš„è§†é”¥ä½“å°ºå¯¸
        // å…¬å¼ï¼šheight = 2 * tan(fov / 2) * distance
        const distance = 1000;
        const vFOV = THREE.MathUtils.degToRad(camera.fov); // è½¬å¼§åº¦
        const height = 2 * Math.tan(vFOV / 2) * distance;
        const width = height * camera.aspect;

        // 2. è°ƒæ•´æ¿å­å¤§å°ä»¥å¡«æ»¡å±å¹•
        bgMesh.scale.set(width, height, 1);

        // 3. é¡ºä¾¿æ›´æ–°ä¸€ä¸‹è´´å›¾çš„ UV ç¼©æ”¾ (å¤„ç† Cover/Contain)
        updateBackgroundUV();
    }

    function onResize(source, overrideW, overrideH) {
        // 1. å½•åˆ¶æ—¶ç¦æ­¢è°ƒæ•´
        if (ExportMgr && ExportMgr.isRecording) return;

        const isDrag = (source === 'drag');
        const container = document.getElementById('visualizer-section');
        const wrapper = document.getElementById('canvas-wrapper');

        if (container) {
            // ä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„é¢„è®¡ç®—å®½é«˜
            const availW = overrideW || container.clientWidth;
            const availH = overrideH || container.clientHeight;

            if (availW > 0 && availH > 0) {
                let finalW, finalH;
                const hasImportedBg = currentBgType !== null;

                if (hasImportedBg) {
                    // === æ¨¡å¼ A: é€‚åº”èƒŒæ™¯æ¯”ä¾‹ ===
                    const targetRatio = bgImageAspect;
                    const containerRatio = availW / availH;
                    if (containerRatio > targetRatio) {
                        finalH = availH;
                        finalW = availH * targetRatio;
                    } else {
                        finalW = availW;
                        finalH = availW / targetRatio;
                    }
                } else {
                    // === æ¨¡å¼ B: é“ºæ»¡æ•´ä¸ªåŒºåŸŸ (æ˜Ÿç©ºæ¨¡å¼) ===
                    finalW = availW;
                    finalH = availH;
                }

                finalW = Math.max(2, Math.floor(finalW));
                finalH = Math.max(2, Math.floor(finalH));

                wrapper.style.width = finalW + 'px';
                wrapper.style.height = finalH + 'px';

                if (camera && renderer) {
                    // 1. æ›´æ–°ç›¸æœºå’Œæ¸²æŸ“å™¨å°ºå¯¸
                    camera.aspect = finalW / finalH;
                    camera.updateProjectionMatrix();

                    renderer.setSize(finalW, finalH);
                    renderer.domElement.style.width = finalW + 'px';
                    renderer.domElement.style.height = finalH + 'px';

                    // 2. åŒæ­¥æ¨¡ç³Šå’ŒèƒŒæ™¯
                    if (!isDrag) {
                        if (blurRtX) blurRtX.setSize(finalW * BLUR_SCALE, finalH * BLUR_SCALE);
                        if (blurRtY) blurRtY.setSize(finalW * BLUR_SCALE, finalH * BLUR_SCALE);
                        if (blurMatX) blurMatX.uniforms.uResolution.value.set(finalW * BLUR_SCALE, finalH * BLUR_SCALE);
                        if (blurMatY) blurMatY.uniforms.uResolution.value.set(finalW * BLUR_SCALE, finalH * BLUR_SCALE);
                    }

                    updateBackgroundSize();

                    // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šç«‹åˆ»æ¸²æŸ“ä¸€å¸§ï¼ğŸ”¥ğŸ”¥ğŸ”¥
                    // è¿™èƒ½é˜²æ­¢ setSize æ¸…ç©ºç”»å¸ƒåå‡ºç°â€œé—ªé»‘â€æˆ–â€œæ¶ˆå¤±â€çš„æƒ…å†µ
                    renderer.render(scene, camera);
                }
                updateGridBackground();
            }
        }

        if (!isDrag && STATE.totalDuration > 0) {
            autoFitZoom(STATE.totalDuration);
            updatePlayhead();
        }
    }

    function updateBackgroundUV() {
        if (!bgMaterial || !bgMaterial.uniforms.tMap.value) return;

        const screenAspect = camera.aspect;
        const imageAspect = bgImageAspect;
        const fitMode = BG_STATE.fit; // 'cover', 'contain', 'fill'

        let scaleX = 1;
        let scaleY = 1;

        if (fitMode === 'fill') {
            scaleX = 1;
            scaleY = 1;
        }
        else if (fitMode === 'contain') {
            // å®Œæ•´æ˜¾ç¤ºï¼šä»¥é•¿è¾¹ä¸ºå‡†
            if (screenAspect > imageAspect) {
                // å±å¹•æ›´å®½ï¼Œå·¦å³ç•™é»‘ï¼Œå›¾ç‰‡ X è½´éœ€è¦ç¼©å°æ˜¾ç¤ºï¼ˆå³ UV X è½´èŒƒå›´å˜å¤§ï¼‰
                scaleX = screenAspect / imageAspect;
            } else {
                scaleY = imageAspect / screenAspect;
            }
        }
        else { // 'cover' (é»˜è®¤)
            // é“ºæ»¡è£å‰ªï¼šä»¥çŸ­è¾¹ä¸ºå‡†
            if (screenAspect > imageAspect) {
                // å±å¹•æ›´å®½ï¼Œä¸ºäº†é“ºæ»¡ï¼Œéœ€è¦æˆªæ‰ä¸Šä¸‹ï¼ˆå³ UV Y è½´èŒƒå›´å˜å°ï¼‰
                scaleY = imageAspect / screenAspect;
            } else {
                scaleX = screenAspect / imageAspect;
            }
        }

        bgMaterial.uniforms.uUvScale.value.set(scaleX, scaleY);
    }

    // ==========================================
    // 4. ä¸»é€»è¾‘æ§åˆ¶
    // ==========================================

    function initScrubbing() {
        // å®šä¹‰æ ¸å¿ƒå®šä½é€»è¾‘ï¼šè¾“å…¥é¼ æ ‡äº‹ä»¶ï¼Œè®¡ç®—æ—¶é—´å¹¶è·³è½¬
        const updateScrub = (e) => {
            // ä»¥ timelineLanes ä¸ºåŸºå‡†è®¡ç®— X åæ ‡
            const rect = DOM.timelineLanes.getBoundingClientRect();

            // è®¡ç®—é¼ æ ‡ç›¸å¯¹äºå®¹å™¨å·¦ä¾§çš„åç§» + å®¹å™¨å½“å‰çš„æ»šåŠ¨è·ç¦»
            const offsetX = e.clientX - rect.left + DOM.timelineLanes.scrollLeft;

            // è½¬æ¢ä¸ºæ—¶é—´ (é˜²æ­¢è´Ÿæ•°)
            const time = Math.max(0, offsetX / STATE.pxPerSec);

            // æ‰§è¡Œè·³è½¬
            seekTo(time);
        };

        // é€šç”¨çš„æŒ‰ä¸‹å¤„ç†å‡½æ•°
        const onMouseDown = (e) => {
            // 1. å¦‚æœç‚¹å‡»çš„æ˜¯ Clip (äº‹ä»¶å—)ï¼Œåˆ™å¿½ç•¥ï¼Œè®© Clip è‡ªå·±çš„æ‹–æ‹½é€»è¾‘å¤„ç†
            if (e.target.closest('.clip')) return;

            // 2. ğŸ”¥ å…³é”®ï¼šç¦æ­¢æµè§ˆå™¨é»˜è®¤è¡Œä¸ºï¼ˆé˜²æ­¢æ‹–å‡ºæ®‹å½±ã€é€‰ä¸­æ–‡å­—ï¼‰
            e.preventDefault();

            // 3. ç«‹å³è·³è½¬ä¸€æ¬¡ï¼ˆç‚¹å‡»å³å®šä½ï¼‰
            updateScrub(e);

            // 4. å®šä¹‰æ‹–åŠ¨è¿‡ç¨‹
            const onMouseMove = (moveEvent) => {
                // åœ¨ window ä¸Šç›‘å¬ï¼Œè¿™æ ·é¼ æ ‡æ‹–å‡ºæµè§ˆå™¨å¤–ä¹Ÿèƒ½å“åº”
                updateScrub(moveEvent);
            };

            // 5. å®šä¹‰æŠ¬èµ·è¿‡ç¨‹
            const onMouseUp = () => {
                window.removeEventListener('mousemove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);
            };

            // æŒ‚è½½å…¨å±€ç›‘å¬
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
        };
// ğŸ”¥ ä¿®æ”¹ï¼šåªåœ¨æ ‡å°ºåŒºåŸŸç›‘å¬ Scrubbing (æ’­æ”¾è·³è½¬)
        // DOM.timelineLanes.addEventListener('mousedown', onMouseDown); // <--- åˆ é™¤è¿™è¡Œ
        DOM.rulerContent.addEventListener('mousedown', onMouseDown);
    }

    // ğŸ”¥ ä¿®å¤ç‰ˆï¼šè¾¹ç¼˜è‡ªåŠ¨æ»šåŠ¨é€»è¾‘ (å¸¦ä¸¥æ ¼è¾¹ç•Œé™åˆ¶)
    function autoScroll(clientY) {
        const container = DOM.timelineLanes;
        const rect = container.getBoundingClientRect();

        const edgeSize = 50; // è¾¹ç¼˜æ„Ÿåº”åŒº
        const speed = 15;    // æ»šåŠ¨é€Ÿåº¦

        // ============================================================
        // ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šåŸºäºè½¨é“æ•°é‡è®¡ç®—çœŸå®å†…å®¹é«˜åº¦ï¼Œè€Œä¸æ˜¯ä¾èµ– DOM scrollHeight
        // ============================================================
        // 1. è·å–è½¨é“å•è¡Œé«˜åº¦ (CSS .track-lane å®šä¹‰ä¸º 64px)
        const trackHeight = 64;

        // 2. è®¡ç®—æ‰€æœ‰è½¨é“å åŠ çš„æ€»é«˜åº¦
        const totalTrackHeight = STATE.tracks.length * trackHeight;

        // 3. åŠ ä¸Šåº•éƒ¨ç¼“å†²åŒºåŸŸ (ä¾‹å¦‚ 100px)ï¼Œè®©ç”¨æˆ·èƒ½ç¨å¾®å¤šæ»šä¸€ç‚¹ç‚¹ä»¥ä¾¿æ“ä½œåº•éƒ¨
        const paddingBottom = 100;

        // 4. è®¡ç®—â€œé€»è¾‘ä¸Šâ€å…è®¸çš„æœ€å¤§æ»šåŠ¨è·ç¦»
        // å†…å®¹æ€»é«˜ - è§†å£é«˜åº¦ã€‚å¦‚æœå†…å®¹æ¯”è§†å£å°ï¼Œåˆ™ç»“æœä¸º 0 (ç¦æ­¢æ»šåŠ¨)
        const contentMaxScroll = Math.max(0, totalTrackHeight + paddingBottom - container.clientHeight);

        // 5. è·å–â€œç‰©ç†ä¸Šâ€çš„æœ€å¤§æ»šåŠ¨è·ç¦» (DOM å®é™…çŠ¶æ€)
        const physicalMaxScroll = container.scrollHeight - container.clientHeight;

        // 6. å–ä¸¤è€…ä¸­è¾ƒå°çš„é‚£ä¸ªä½œä¸ºæœ€ç»ˆé™åˆ¶
        // è¿™æ ·æ—¢é˜²æ­¢æ»šåˆ°æ²¡æœ‰è½¨é“çš„åœ°æ–¹ï¼Œä¹Ÿé˜²æ­¢ç‰©ç† DOM æ²¡æ¸²æŸ“å‡ºæ¥æ—¶æŠ¥é”™
        const finalMaxScrollTop = Math.min(physicalMaxScroll, contentMaxScroll);


        // --- å‘ä¸‹æ»šåŠ¨é€»è¾‘ ---
        // (é¼ æ ‡æ¥è¿‘åº•éƒ¨ ä¸” å½“å‰æ»šåŠ¨ä½ç½®è¿˜æ²¡è¶…è¿‡é™åˆ¶)
        if (clientY > rect.bottom - edgeSize) {
            if (container.scrollTop < finalMaxScrollTop) {
                container.scrollTop += speed;
                return true;
            }
        }
            // --- å‘ä¸Šæ»šåŠ¨é€»è¾‘ ---
        // (é¼ æ ‡æ¥è¿‘é¡¶éƒ¨ ä¸” è¿˜æ²¡æ»šåˆ°é¡¶)
        else if (clientY < rect.top + edgeSize) {
            if (container.scrollTop > 0) {
                container.scrollTop -= speed;
                return true;
            }
        }
        return false;
    }

    function initBoxSelection() {
        const container = DOM.timelineLanes;

        // åˆ›å»ºæ¡†é€‰ DOM
        const box = document.createElement('div');
        box.className = 'selection-box';
        container.appendChild(box);

        container.addEventListener('mousedown', (e) => {
            // 1. å¦‚æœç‚¹å‡»çš„æ˜¯ Clipï¼Œæˆ–è€…æ˜¯åœ¨æ»šåŠ¨æ¡ä¸Šï¼Œåˆ™å¿½ç•¥
            if (e.target.closest('.clip') || e.target === container) {
                // æ³¨æ„ï¼še.target === container æ˜¯ä¸ºäº†é˜²æ­¢ç‚¹å‡»æ»šåŠ¨æ¡æ—¶è§¦å‘ï¼Œ
                // ä½†é€šå¸¸ timeline-lanes å®¹å™¨æœ¬èº«å¾ˆå¤§ï¼Œè¿™é‡Œä¸»è¦é  closest('.clip') è¿‡æ»¤
            }
            if (e.target.closest('.clip')) return;

            e.preventDefault();

            // 2. å¦‚æœä¸æ˜¯å·¦é”®ï¼Œå¿½ç•¥
            if (e.button !== 0) return;

            // 3. æ ¸å¿ƒï¼šç‚¹å‡»ç©ºç™½å¤„ï¼Œå…ˆæ¸…ç©ºä¹‹å‰çš„é€‰æ‹© (é™¤éæŒ‰ä½ Shift/Ctrl)
            if (!e.shiftKey && !e.ctrlKey && !e.metaKey) {
                clearClipSelection();
            }

            // è®°å½•èµ·ç‚¹ (ç›¸å¯¹äºå®¹å™¨å†…å®¹)
            const rect = container.getBoundingClientRect();
            const startX = e.clientX - rect.left + container.scrollLeft;
            const startY = e.clientY - rect.top + container.scrollTop;

            box.style.left = startX + 'px';
            box.style.top = startY + 'px';
            box.style.width = '0px';
            box.style.height = '0px';
            box.style.display = 'block';

            let isDragging = false;

            const onMouseMove = (ev) => {
                isDragging = true;
                autoScroll(ev.clientY);
                const currentX = ev.clientX - rect.left + container.scrollLeft;
                const currentY = ev.clientY - rect.top + container.scrollTop;

                const width = Math.abs(currentX - startX);
                const height = Math.abs(currentY - startY);
                const left = Math.min(currentX, startX);
                const top = Math.min(currentY, startY);

                box.style.width = width + 'px';
                box.style.height = height + 'px';
                box.style.left = left + 'px';
                box.style.top = top + 'px';

                // --- å®æ—¶ç¢°æ’æ£€æµ‹ ---
                // è·å–æ¡†é€‰åŒºåŸŸçš„çŸ©å½¢ (ç›¸å¯¹äºè§†å£ï¼Œæ–¹ä¾¿å¯¹æ¯”)
                const selectRect = box.getBoundingClientRect();

                STATE.clips.forEach(clip => {
                    if (!clip.dom) return;
                    const clipRect = clip.dom.getBoundingClientRect();

                    // ç®€å•çš„çŸ©å½¢ç¢°æ’æ£€æµ‹
                    const isOverlapping = !(selectRect.right < clipRect.left ||
                        selectRect.left > clipRect.right ||
                        selectRect.bottom < clipRect.top ||
                        selectRect.top > clipRect.bottom);

                    if (isOverlapping) {
                        selectClip(clip, true); // true = add to selection
                    } else {
                        // å¦‚æœæ²¡æœ‰æŒ‰ä¸‹ Shiftï¼Œç§»å‡ºæ¡†å¤–å°±å–æ¶ˆé€‰ä¸­
                        if (!ev.shiftKey) {
                            // è¿™é‡Œç¨å¾®å¤æ‚ï¼Œæš‚ä¸”åªåšå¢é‡é€‰æ‹©ï¼Œæ¾æ‰‹åå¤„ç†åé€‰é€»è¾‘ä¼šæ›´å¥½
                            // ä¸ºç®€å•èµ·è§ï¼Œè¿™é‡Œæ¯æ¬¡é‡ç»˜éƒ½ä¾èµ– "ç‚¹å‡»ç©ºç™½æ¸…ç† + å¢é‡æ·»åŠ "
                        }
                    }
                });
            };

            const onMouseUp = () => {
                box.style.display = 'none';
                box.style.width = 0;
                box.style.height = 0;
                window.removeEventListener('mousemove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);
            };

            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
        });
    }

    // è¾…åŠ©ï¼šæ¸…ç©ºæ‰€æœ‰ Clip é€‰ä¸­
    function clearClipSelection() {
        STATE.selectedClips.forEach(clip => {
            if (clip.dom) clip.dom.classList.remove('selected-clip');
        });
        STATE.selectedClips.clear();
    }

    // è¾…åŠ©ï¼šé€‰ä¸­æŸä¸ª Clip
    function selectClip(clip, addToExisting = false) {
        if (!addToExisting) clearClipSelection();
        STATE.selectedClips.add(clip);
        if (clip.dom) clip.dom.classList.add('selected-clip');
    }

    function updateAllTracksVisibility() {
        const hasSolo = STATE.soloCount > 0;

        STATE.tracks.forEach(track => {
            let visible = true;

            if (hasSolo) {
                // å¦‚æœæœ‰ Soloï¼Œåªæœ‰æ ‡è®°äº† Solo ä¸”æ²¡è¢« Mute çš„æ‰æ˜¾ç¤ºå›¾æ¡ˆ
                visible = track.isSoloed && !track.isMuted;
            } else {
                // å¦‚æœæ²¡æœ‰ Soloï¼Œåªè¦æ²¡è¢« Mute å°±æ˜¾ç¤ºå›¾æ¡ˆ
                visible = !track.isMuted;
            }

            // 1. æ›´æ–° 3D åœºæ™¯å¯è§æ€§ï¼ˆåªå½±å“è§†è§‰å›¾æ¡ˆï¼‰
            track.clips.forEach(clip => {
                if (clip.mesh) {
                    clip.mesh.visible = visible;
                }
            });

            // 2. æ›´æ–°æ—¶é—´è½´ UI ç°åº¦ï¼ˆè§†è§‰æç¤ºï¼‰
            if (track.laneEl) {
                track.laneEl.style.opacity = visible ? "1" : "0.3";
            }

            // ğŸ”¥ é‡è¦ï¼šåˆ æ‰æˆ–æ³¨é‡Šæ‰åŸæœ¬åœ¨è¿™é‡Œçš„ DOM.audio.muted = !visible é€»è¾‘
            // è¿™æ ·éŸ³é¢‘å°±ä¼šå§‹ç»ˆæ’­æ”¾ï¼Œä¸å— Mute/Solo æŒ‰é’®çš„è§†è§‰éšè—å½±å“
        });
    }

    // ğŸ”¥ æ–°å¢ï¼šè‡ªåŠ¨è®¡ç®—å¹¶åº”ç”¨åˆé€‚çš„ Zoom å€¼
    function autoFitZoom(duration) {
        if (!duration || duration <= 0) return;

        // è·å–æ—¶é—´è½´å¯è§†åŒºåŸŸçš„å®½åº¦
        const containerWidth = DOM.timelineLanes.clientWidth;

        // è®¡ç®—ç†æƒ³æ¯”ä¾‹ï¼šè®©å†…å®¹å æ®çº¦ 90% çš„å®½åº¦ (ç•™ä¸€ç‚¹ä½™åœ°)
        let idealPxPerSec = (containerWidth * 0.9) / duration;

        // é™åˆ¶èŒƒå›´åœ¨ Slider çš„æœ€å°å€¼(1)å’Œæœ€å¤§å€¼(200)ä¹‹é—´
        // ä½ å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´è¿™é‡Œçš„ min/max
        idealPxPerSec = Math.max(1, Math.min(200, idealPxPerSec));

        // åº”ç”¨æ•°å€¼
        STATE.pxPerSec = idealPxPerSec;

        // åŒæ­¥æ›´æ–° Slider UI
        if (DOM.timelineZoom) {
            DOM.timelineZoom.value = idealPxPerSec;
        }

        // è§¦å‘è§†å›¾åˆ·æ–°
        updateGridBackground();
        updateTotalDuration(); // è¿™ä¸€æ­¥å¾ˆé‡è¦ï¼Œå®ƒä¼šé‡ç®—å®¹å™¨æ€»å®½
        STATE.clips.forEach(c => c.updateDOMPosition()); // è¿™ä¸€æ­¥é‡ç»˜ Clip
        updatePlayhead();
    }

    // å…¨å±€å˜é‡å­˜å‚¨è§†é¢‘å…ƒç´ ï¼Œæ–¹ä¾¿åœ¨ animate ä¸­æ›´æ–°
    // å…¨å±€å˜é‡ç”¨äºæ§åˆ¶è§†é¢‘æ’­æ”¾
    let bgVideoElement = null;

    function processBackgroundFile(file) {
        if (!file) return;

        // æ˜¾ç¤º Loadingï¼Œå› ä¸ºè½¬æ¢ Base64 å¯èƒ½éœ€è¦ä¸€ç‚¹æ—¶é—´ï¼ˆç‰¹åˆ«æ˜¯å¤§å›¾ç‰‡ï¼‰
        if(DOM.loading) DOM.loading.style.display = 'flex';

        const reader = new FileReader();

        reader.onload = (e) => {
            const base64Data = e.target.result; // è¿™é‡Œæ‹¿åˆ°äº† Base64

            // --- 1. å‡†å¤‡å†å²è®°å½•æ—§æ•°æ® ---
            const oldBgBlob = currentBgBase64;
            const oldBgType = currentBgType;
            const oldBgBase64 = storedBgBase64ForSave; // è®°å½•æ—§çš„ Base64

            // --- 2. æ³¨å†Œ Blob ç”¨äºæ¸²æŸ“ (æ€§èƒ½ä¼˜åŒ–) ---
            const newBgUrl = ResourceMgr.register(file);
            const newBgType = file.type.startsWith('video/') ? 'video' : 'image';

            // --- 3. æ›´æ–°å…¨å±€çŠ¶æ€ ---
            currentBgBase64 = newBgUrl;       // è¿è¡Œæ—¶ç”¨ Blob
            currentBgType = newBgType;
            storedBgBase64ForSave = base64Data; // ä¿å­˜æ—¶ç”¨ Base64

            // --- 4. åº”ç”¨èƒŒæ™¯ ---
            applyBackgroundSource(newBgUrl, newBgType);

            // --- 5. è®°å½•å†å² ---
            HistoryMgr.add({
                type: 'change_background',
                // æ¸²æŸ“ç”¨çš„ Blob
                oldData: oldBgBlob,
                oldType: oldBgType,
                newData: newBgUrl,
                newType: newBgType,
                // ä¿å­˜ç”¨çš„ Base64 ğŸ”¥
                oldBase64: oldBgBase64,
                newBase64: base64Data
            });

            if(DOM.loading) DOM.loading.style.display = 'none';
        };

        // å¼€å§‹è¯»å–æ–‡ä»¶
        reader.readAsDataURL(file);
    }

    // ğŸ”¥ ä¿®å¤ï¼šå°† onResize ç§»å…¥åŠ è½½å›è°ƒä¸­ï¼Œç¡®ä¿è·å¾—æ­£ç¡®çš„å›¾ç‰‡é•¿å®½æ¯”
    function applyBackgroundSource(url, type) {
        const loader = new THREE.TextureLoader();

        // å†…éƒ¨è¾…åŠ©ï¼šåº”ç”¨çº¹ç†
        const applyTexture = (texture, aspect) => {
            texture.encoding = THREE.sRGBEncoding;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;

            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;

            bgTexture = texture;
            bgImageAspect = aspect;

            if (bgMaterial) {
                bgMaterial.uniforms.tMap.value = texture;
                bgMesh.visible = true;
                updateBackgroundUV();
            }

            // âœ¨ å…³é”®ä¿®å¤ï¼šå›¾ç‰‡åŠ è½½å®Œã€é•¿å®½æ¯”æ›´æ–°åï¼Œå†è§¦å‘ä¸€æ¬¡ Resize
            requestAnimationFrame(() => {
                onResize();
            });
        };

        if (type === 'image') {
            const img = new Image();
            img.src = url;
            img.onload = () => {
                const aspect = img.width / img.height;
                loader.load(url, (tex) => applyTexture(tex, aspect));
            };
        }
        else if (type === 'video') {
            // æ¸…ç†æ—§è§†é¢‘
            if (bgVideoElement) {
                bgVideoElement.pause();
                bgVideoElement.src = "";
            }

            const video = document.createElement('video');
            video.src = url;
            video.loop = true;
            video.muted = true;
            video.playsInline = true;
            video.crossOrigin = "anonymous"; // é¿å…è·¨åŸŸè´´å›¾é»‘å±

            // ğŸ”¥ ä¿®æ”¹ï¼šä¸è¦ç«‹å³ Playï¼Œè€Œæ˜¯ç­‰å¾…å…ƒæ•°æ®åŠ è½½å®Œæ¯•ååŒæ­¥çŠ¶æ€
            video.onloadeddata = () => {
                const aspect = video.videoWidth / video.videoHeight;
                bgVideoElement = video;

                // 1. åˆ›å»ºçº¹ç†
                const tex = new THREE.VideoTexture(video);
                applyTexture(tex, aspect);

                // 2. åŒæ­¥æ—¶é—´ (å–ä½™å¾ªç¯)
                if (video.duration > 0) {
                    video.currentTime = STATE.currentTime % video.duration;
                }

                // 3. å¦‚æœå½“å‰æ˜¯æ’­æ”¾çŠ¶æ€ï¼Œåˆ™æ’­æ”¾è§†é¢‘
                if (STATE.isPlaying) {
                    video.play().catch(e => console.error("Video autoplay blocked:", e));
                }
            };

            // è§¦å‘åŠ è½½
            video.load();
        }
    }



    function initController() {
        ColorPickerMgr.init();

        const versionModal = document.getElementById('version-modal');
        const logoBtn = document.getElementById('app-logo');
        const closeVerBtn = document.getElementById('closeVersionBtn');

        if (logoBtn && versionModal) {
            logoBtn.addEventListener('click', () => {
                versionModal.style.display = 'flex';
            });
        }

        if (closeVerBtn) {
            closeVerBtn.addEventListener('click', () => {
                versionModal.style.display = 'none';
            });
        }

        // ç‚¹å‡»å¼¹çª—èƒŒæ™¯å…³é—­
        if (versionModal) {
            versionModal.addEventListener('click', (e) => {
                if (e.target === versionModal) {
                    versionModal.style.display = 'none';
                }
            });
        }

        const CURRENT_VERSION = '2.2.0'; // ğŸ‘ˆ è¯·ç¡®ä¿è¿™é‡Œä¸ HTML æ ‡é¢˜ä¸€è‡´
        const STORAGE_KEY = 'mv_last_seen_version';

        // è¯»å–æœ¬åœ°å­˜å‚¨çš„æ—§ç‰ˆæœ¬å·
        const lastSeenVersion = localStorage.getItem(STORAGE_KEY);

        // å¦‚æœä»æ²¡å­˜è¿‡(æ–°ç”¨æˆ·) æˆ–è€… å­˜çš„ç‰ˆæœ¬ä¸ç­‰äºå½“å‰ç‰ˆæœ¬(æ›´æ–°äº†)
        if (lastSeenVersion !== CURRENT_VERSION) {
            if (versionModal) {
                // 1. å¼¹å‡ºçª—å£
                versionModal.style.display = 'flex';

                // 2. ç«‹å³å†™å…¥æ–°ç‰ˆæœ¬å·ï¼Œé˜²æ­¢åˆ·æ–°åé‡å¤å¼¹å‡º
                localStorage.setItem(STORAGE_KEY, CURRENT_VERSION);

                console.log(`æ£€æµ‹åˆ°æ–°ç‰ˆæœ¬/é¦–æ¬¡è®¿é—®: ${CURRENT_VERSION} (æ—§è®°å½•: ${lastSeenVersion})`);
            }
        }

        const starToggle = document.getElementById('starfieldToggle');
        if (starToggle) {
            starToggle.addEventListener('change', (e) => {
                // ğŸ”¥ ä¿®å¤ï¼šè°ƒç”¨å°è£…å¥½çš„å‡½æ•°ï¼Œè¿™æ ·æ‰èƒ½åŒæ—¶åˆ‡æ¢ 3D æ˜Ÿæ˜Ÿå’Œ DOM èƒŒæ™¯è‰²
                setStarfieldState(e.target.checked);
            });
        }

        // åˆ›å»ºé»˜è®¤è½¨é“
        const defaultAudioTrack = new Track("Audio", "audio");
        STATE.tracks.push(defaultAudioTrack);

        const defaultMidiTrack = new Track("MIDI", "midi");
        STATE.tracks.push(defaultMidiTrack);

        const alignBtn = document.getElementById('autoAlignBtn');
        if (alignBtn) {
            alignBtn.addEventListener('click', autoAlignAudioToMidi);
        }

        const bgModal = document.getElementById('bg-settings-modal');

        // 1. MIDI
        const btnMidi = document.getElementById('btn-midi');
        const inputMidi = document.getElementById('midiInput');
        if (btnMidi && inputMidi) {
            btnMidi.addEventListener('click', () => inputMidi.click());
        }

        // 2. Audio
        const btnAudio = document.getElementById('btn-audio');
        const inputAudio = document.getElementById('audioInput');
        if (btnAudio && inputAudio) {
            btnAudio.addEventListener('click', () => inputAudio.click());
        }

        // 3. èƒŒæ™¯
        const btnBg = document.getElementById('btn-bg');
        const inputBg = document.getElementById('bgInput');
        if (btnBg && inputBg) {
            btnBg.addEventListener('click', () => inputBg.click());
        }

        const addTrackBtn = document.getElementById('addTrackBtn');
        if (addTrackBtn) {
            addTrackBtn.addEventListener('click', () => {
                const newTrack = new Track(`MIDI ${STATE.nextTrackId}`, 'midi');
                STATE.tracks.push(newTrack);

                // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
                setTimeout(() => {
                    newTrack.headerEl.scrollIntoView({ behavior: 'smooth' });
                    // å¯é€‰ï¼šæ–°å»ºå®Œè‡ªåŠ¨æ¿€æ´» R æŒ‰é’®
                    // newTrack.isArmed = true;
                    // newTrack.headerEl.querySelector('.record-arm-btn').classList.add('active-arm');
                }, 100);

                updateTotalDuration();
                updateTrackZRanks();
            });
        }

        const btnHl = document.getElementById('btn-highlight-color');
        const hlPreview = document.getElementById('hl-color-preview');

        if (btnHl) {
            btnHl.addEventListener('click', () => {
                const curHex = '#' + currentHighlightColor.getHexString();

                ColorPickerMgr.open(
                    curHex,
                    " - Playback Highlight",
                    (finalColor) => { }, // ç¡®è®¤å›è°ƒ
                    (previewColor) => {
                        // é¢œè‰²å›è°ƒ
                        currentHighlightColor.set(previewColor);
                        hlPreview.style.backgroundColor = previewColor;

                        // æ›´æ–°æ‰€æœ‰ Clip
                        STATE.clips.forEach(clip => {
                            if (clip.mesh && clip.track.type === 'midi') {
                                if (clip.mesh.material && clip.mesh.material.uniforms) {
                                    clip.mesh.material.uniforms.uHighlightColor.value.copy(currentHighlightColor);
                                }
                                // (ä¿ç•™åŸæœ‰çš„å…¼å®¹æ€§ä»£ç ...)
                            }
                        });
                    },
                    {
                        isHighlight: true,
                        initialWidth: currentHighlightWidth,
                        initialBrightness: currentHighlightBrightness, // ğŸ”¥ ä¼ å…¥å½“å‰äº®åº¦

                        onWidthChange: (newWidth) => {
                            currentHighlightWidth = newWidth;
                            STATE.clips.forEach(clip => {
                                if (clip.mesh && clip.track.type === 'midi') {
                                    if (clip.mesh.material && clip.mesh.material.uniforms) {
                                        clip.mesh.material.uniforms.uHighlightWidth.value = currentHighlightWidth;
                                    }
                                }
                            });
                        },

                        // ğŸ”¥ æ–°å¢ï¼šäº®åº¦è°ƒèŠ‚å›è°ƒ
                        onBrightChange: (newBright) => {
                            currentHighlightBrightness = newBright;
                            STATE.clips.forEach(clip => {
                                if (clip.mesh && clip.track.type === 'midi') {
                                    if (clip.mesh.material && clip.mesh.material.uniforms) {
                                        clip.mesh.material.uniforms.uHighlightBrightness.value = currentHighlightBrightness;
                                    }
                                }
                            });
                        }
                    }
                );
            });
        }

        const menuColorBtn = document.getElementById('menu-color');

        menuColorBtn.addEventListener('click', () => {
            // éšè—èœå•
            document.getElementById('context-menu').style.display = 'none';

            // --- 1. é¢„å…ˆè®¡ç®—å—å½±å“çš„ç¼–ç»„ï¼Œå¹¶ä¿å­˜å®ƒä»¬çš„â€œæ—§é¢œè‰²â€ ---
            // è¿™ä¸€æ­¥å¿…é¡»åœ¨æ‰“å¼€è°ƒè‰²ç›˜ä¹‹å‰åšï¼Œå› ä¸ºå®æ—¶é¢„è§ˆä¼šæ”¹å˜å½“å‰é¢œè‰²
            const affectedGroupsState = [];
            const affectedGroupIds = new Set();

            STATE.selectedTrackIds.forEach(tid => {
                const t = STATE.tracks.find(trk => trk.id === tid);
                if (t && t.groupId) affectedGroupIds.add(t.groupId);
            });

            affectedGroupIds.forEach(gid => {
                const group = STATE.groups[gid];
                if (group) {
                    affectedGroupsState.push({
                        groupId: gid,
                        oldColor: group.color // ğŸ”¥ è®°å½•æ­¤åˆ»çš„æ—§é¢œè‰²
                    });
                }
            });

            // --- 2. å†³å®šè°ƒè‰²ç›˜æ‰“å¼€æ—¶çš„é»˜è®¤é¢œè‰² ---
            let initialColor = '#ffffff';
            // å¦‚æœæœ‰å—å½±å“çš„ç»„ï¼Œå°±ç”¨ç¬¬ä¸€ä¸ªç»„çš„é¢œè‰²ä½œä¸ºé»˜è®¤å€¼ (è§£å†³é‡ç½®å›ç™½è‰²çš„é—®é¢˜)
            if (affectedGroupsState.length > 0) {
                initialColor = affectedGroupsState[0].oldColor;
            }

            // --- 3. æ‰“å¼€è°ƒè‰²ç›˜ ---
            ColorPickerMgr.open(
                initialColor,
                " - Group Color",
                (finalColor) => {
                    // === A. ç¡®è®¤å›è°ƒ ===

                    // 1. å†æ¬¡ç¡®ä¿åº”ç”¨æœ€ç»ˆé¢œè‰² (é˜²æ­¢é¢„è§ˆæ²¡è·‘å®Œ)
                    setGroupColor(finalColor);

                    // 2. ğŸ”¥ ç”Ÿæˆå†å²è®°å½• (Issue #2)
                    // æˆ‘ä»¬å°†ä¹‹å‰å­˜å¥½çš„ affectedGroupsState ä¸æ–°çš„ finalColor ç»“åˆ
                    const changes = affectedGroupsState.map(state => ({
                        groupId: state.groupId,
                        oldColor: state.oldColor,
                        newColor: finalColor
                    }));

                    if (changes.length > 0) {
                        HistoryMgr.add({
                            type: 'change_group_color',
                            changes: changes
                        });
                        console.log("ç¼–ç»„é¢œè‰²ä¿®æ”¹å·²è®°å½•ï¼Œå¯æ’¤å›ã€‚");
                    }
                },
                (previewColor) => {
                    // === B. å®æ—¶é¢„è§ˆå›è°ƒ ===
                    // æ­¤æ—¶ STATE.groups é‡Œçš„é¢œè‰²å·²ç»è¢«ä¿®æ”¹äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨ä¸Šé¢å¿…é¡»æå‰ä¿å­˜ oldColor
                    setGroupColor(previewColor);
                }
            );
        });

        // 1. æ‰“å¼€å¼¹çª—
        document.getElementById('bgSettingsBtn').addEventListener('click', () => {
            bgModal.style.display = 'flex';
            updateBgUI(); // æ‰“å¼€æ—¶åŒæ­¥ UI
        });

        // 2. å…³é—­å¼¹çª—
        document.getElementById('closeBgSettingsBtn').addEventListener('click', () => {
            bgModal.style.display = 'none';
        });

        // --- èƒŒæ™¯æ¨¡å¼åˆ‡æ¢é€»è¾‘ ---
        // --- èƒŒæ™¯æ¨¡å¼åˆ‡æ¢é€»è¾‘ (å¸¦è®°å¿†åŠŸèƒ½) ---
        const btnDark = document.getElementById('bg-mode-dark');
        const btnWhite = document.getElementById('bg-mode-white');
        const vizSection = document.getElementById('visualizer-section');
        const STORAGE_KEY_THEME = 'mv_bg_theme_mode'; // æœ¬åœ°å­˜å‚¨çš„ Key

        if (btnDark && btnWhite) {

            function applyThemeMode(mode) {
                const starToggle = document.getElementById('starfieldToggle');
                const vizSection = document.getElementById('visualizer-section');
                const bgMesh = window.bgMesh || (scene && scene.children.find(c => c.isMesh && c.geometry.type === 'PlaneGeometry'));

                // 1. å­˜å…¥è®°å¿†
                localStorage.setItem('mv_bg_theme_mode', mode);

                if (mode === 'white') {
                    // === åˆ‡æ¢åˆ°çº¯ç™½æ¨¡å¼ (Light Mode) ===

                    // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šç»™ Body æ·»åŠ  light-mode ç±»ï¼Œè§¦å‘ CSS å˜é‡åè½¬
                    document.body.classList.add('light-mode');

                    // è®°å¿†æ˜Ÿæ˜ŸçŠ¶æ€
                    if (!document.getElementById('bg-mode-white').classList.contains('btn-primary')) {
                        if (starToggle) {
                            localStorage.setItem('mv_restore_stars', starToggle.checked);
                        }
                    }

                    // æ›´æ–°æŒ‰é’®æ ·å¼
                    document.getElementById('bg-mode-white').classList.add('btn-primary');
                    // æµ…è‰²æ¨¡å¼ä¸‹ï¼Œé€‰ä¸­è¾¹æ¡†ç”¨æ·±ä¸€ç‚¹çš„é¢œè‰²
                    document.getElementById('bg-mode-white').style.border = "2px solid var(--accent-blue)";
                    document.getElementById('bg-mode-dark').classList.remove('btn-primary');

                    // å…³æ˜Ÿæ˜Ÿ
                    if (starToggle && starToggle.checked) {
                        starToggle.checked = false;
                        setStarfieldState(false);
                    }

                    // æ›´æ–° 3D å®¹å™¨èƒŒæ™¯
                    if (vizSection) {
                        vizSection.style.background = "#ffffff";
                        vizSection.style.boxShadow = "none";
                        vizSection.style.borderTop = "1px solid #e0e0e0";
                    }

                    // é›¾æ”¹ä¸ºç™½è‰²
                    if (scene && scene.fog) {
                        scene.fog.color.set(0xffffff);
                    }

                    // éšè—èƒŒæ™¯å›¾
                    if (bgMesh) bgMesh.visible = false;

                } else {
                    // === åˆ‡æ¢åˆ°æ·±è‰²æ¨¡å¼ (Dark Mode) ===

                    // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šç§»é™¤ light-mode ç±»
                    document.body.classList.remove('light-mode');

                    document.getElementById('bg-mode-dark').classList.add('btn-primary');
                    document.getElementById('bg-mode-white').classList.remove('btn-primary');
                    document.getElementById('bg-mode-white').style.border = "none";

                    // æ¢å¤æ·±è‰²èƒŒæ™¯
                    if (vizSection) {
                        vizSection.style.background = "#000000";
                        vizSection.style.boxShadow = "inset 0 20px 50px -10px rgba(0,0,0,0.9)";
                        vizSection.style.borderTop = "1px solid rgba(255, 255, 255, 0.05)";
                    }

                    // æ¢å¤é»‘è‰²é›¾
                    if (scene && scene.fog) {
                        scene.fog.color.set(0x000000);
                    }

                    // æ¢å¤èƒŒæ™¯å†…å®¹
                    if (currentBgType && bgMesh) {
                        bgMesh.visible = true;
                    } else {
                        const shouldRestore = localStorage.getItem('mv_restore_stars') === 'true';
                        if (shouldRestore && starToggle) {
                            starToggle.checked = true;
                            setStarfieldState(true);
                        }
                    }
                }
            }

            // ç»‘å®šç‚¹å‡»äº‹ä»¶ï¼Œå¹¶ä¿å­˜åˆ° localStorage
            btnDark.addEventListener('click', () => {
                applyThemeMode('dark');
                localStorage.setItem(STORAGE_KEY_THEME, 'dark');
            });

            btnWhite.addEventListener('click', () => {
                applyThemeMode('white');
                localStorage.setItem(STORAGE_KEY_THEME, 'white');
            });

            // --- ğŸ”¥ åˆå§‹åŒ–ï¼šè¯»å–è®°å¿†å¹¶æ¢å¤ ---
            const savedMode = localStorage.getItem(STORAGE_KEY_THEME);
            if (savedMode === 'white') {
                // ä½¿ç”¨ setTimeout å»¶æ—¶æ‰§è¡Œï¼Œä»¥è¦†ç›–é¡µé¢åº•éƒ¨é»˜è®¤çš„æ˜Ÿæ˜Ÿåˆå§‹åŒ–é€»è¾‘(100ms)
                setTimeout(() => {
                    applyThemeMode('white');
                }, 200);
            }
        }

        // ... åœ¨ initController å†… ...

        const bgInputs = [
            { id: 'bg-opacity',    labelId: 'val-opacity',  key: 'opacity',    suffix: '' },
            { id: 'bg-blur',       labelId: 'val-blur',     key: 'blur',       suffix: 'px' }, // ç¡®ä¿ Blur åœ¨è¿™é‡Œ
            { id: 'bg-brightness', labelId: 'val-bright',   key: 'brightness', suffix: '%' },
            { id: 'bg-contrast',   labelId: 'val-contrast', key: 'contrast',   suffix: '%' }
        ];

        bgInputs.forEach(item => {
            const inputEl = document.getElementById(item.id);
            const labelEl = document.getElementById(item.labelId);

            if (inputEl) {
                inputEl.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    BG_STATE[item.key] = val;
                    if (labelEl) labelEl.innerText = val + item.suffix;

                    // ğŸ”¥ æ›´æ–° Shader Uniforms
                    if (bgMaterial) {
                        if (item.key === 'opacity') {
                            bgMaterial.uniforms.uOpacity.value = val;
                        }
                        else if (item.key === 'blur') {
                            // bgMaterial.uniforms.uBlur.value = val;
                        }
                        else if (item.key === 'brightness') {
                            // UI æ˜¯ 0% ~ 200%ï¼Œé»˜è®¤ 100%ã€‚ Shader éœ€è¦åç§»é‡ã€‚
                            bgMaterial.uniforms.uBrightness.value = (val - 100) / 100;
                        }
                        else if (item.key === 'contrast') {
                            // UI æ˜¯ 0% ~ 200%ï¼Œé»˜è®¤ 100%ã€‚ Shader ä¹˜æ•°ã€‚
                            bgMaterial.uniforms.uContrast.value = val / 100;
                        }
                    }

                    // å¡«å……æ¨¡å¼å˜åŒ–ä¹Ÿéœ€è¦æ›´æ–°
                    if (item.key === 'fit') updateBackgroundUV();
                });
            }
        });

        // å¡«å……æ¨¡å¼ç›‘å¬
        document.getElementById('bg-fit').addEventListener('change', (e) => {
            BG_STATE.fit = e.target.value;
            updateBackgroundUV();
        });

        updateGridBackground();

        // ğŸ”¥ 1. åˆå§‹åŒ–æ—¶æ¸²æŸ“æ ‡å°º
        renderRulers();

        let isSyncing = false;

        // 1. å³ä¾§ä¸»åŠ¨æ»šåŠ¨ -> å¸¦åŠ¨å·¦ä¾§å’Œä¸Šæ–¹
        DOM.timelineLanes.addEventListener('scroll', () => {
            if (!isSyncing) {
                window.requestAnimationFrame(() => {
                    // å‚ç›´åŒæ­¥å·¦ä¾§
                    DOM.headers.scrollTop = DOM.timelineLanes.scrollTop;
                    // æ°´å¹³åŒæ­¥ä¸Šæ–¹æ ‡å°º
                    DOM.rulerContent.scrollLeft = DOM.timelineLanes.scrollLeft;
                    isSyncing = false;
                });
                isSyncing = true;
            }
        }, { passive: true }); // passive: true æå‡æ»šåŠ¨æ€§èƒ½

        // 2. å·¦ä¾§è¢«åŠ¨åŒºåŸŸ -> ç›‘å¬æ»šè½®äº‹ä»¶ï¼Œæ‰‹åŠ¨é©±åŠ¨å³ä¾§æ»šåŠ¨
        DOM.headers.addEventListener('wheel', (e) => {
            e.preventDefault(); // é˜»æ­¢æµè§ˆå™¨é»˜è®¤è¡Œä¸º

            // å°†å·¦ä¾§çš„æ»šè½®åŠ¨ä½œâ€œè½¬å‘â€ç»™å³ä¾§
            DOM.timelineLanes.scrollTop += e.deltaY;
            DOM.timelineLanes.scrollLeft += e.deltaX; // å¦‚æœä½ æœ‰æ¨ªå‘è§¦æ‘¸æ¿ï¼Œè¿™ä¹Ÿæ”¯æŒ
        }, { passive: false });

        const fadeToggle = document.getElementById('midiFadeToggle');
        if (fadeToggle) {
            fadeToggle.addEventListener('change', (e) => {
                STATE.enableMidiFade = e.target.checked;
            });
        }

        // ============================================================
        // ğŸ”¥ å¢å¼ºç‰ˆ Scrubbingï¼šæ”¯æŒ æ—¶é—´è½´ + 3Dè§†å›¾ (Shift + æ»šè½®)
        // ============================================================

        // å®šä¹‰ä¸€ä¸ªé€šç”¨çš„æ»šè½®å¤„ç†å‡½æ•°
        const handleShiftScrub = (e) => {
            // åªæœ‰æŒ‰ä½ Shift æ—¶æ‰è§¦å‘
            if (e.shiftKey) {
                // 1. é˜»æ­¢é»˜è®¤è¡Œä¸º (é˜²æ­¢é¡µé¢æ»šåŠ¨)
                e.preventDefault();
                // 2. é˜»æ­¢å†’æ³¡ (é˜²æ­¢ 3D åœºæ™¯ç¼©æ”¾ / é˜²æ­¢äº‹ä»¶å†²çª)
                e.stopPropagation();

                // --- çµæ•åº¦è®¾ç½® ---
                // å»ºè®®ï¼šå¯ä»¥æ ¹æ® STATE.pxPerSec åŠ¨æ€è°ƒæ•´ï¼Œè¿™é‡Œæš‚æ—¶å›ºå®š
                const sensitivity = 0.01;

                // --- æ»šè½®æ•°å€¼è¯»å– ---
                // æµè§ˆå™¨ç‰¹æ€§ä¿®å¤ï¼šæŒ‰ä½ Shift æ—¶ï¼Œå¾ˆå¤šæµè§ˆå™¨ä¼šæŠŠå‚ç›´æ»šåŠ¨(Y)æ˜ å°„ä¸ºæ°´å¹³æ»šåŠ¨(X)
                // æ‰€ä»¥æˆ‘ä»¬å–ç»å¯¹å€¼è¾ƒå¤§çš„é‚£ä¸ªè½´ä½œä¸ºè¾“å…¥
                const rawDelta = (Math.abs(e.deltaX) > Math.abs(e.deltaY)) ? e.deltaX : e.deltaY;

                // --- ğŸ”¥ æ–¹å‘æ§åˆ¶ (å…³é”®ä¿®æ”¹) ---
                // 1 = å‘ä¸‹æ»šåŠ¨æ˜¯å‰è¿› (Time +)
                // -1 = å‘ä¸‹æ»šåŠ¨æ˜¯åé€€ (Time -)
                // ä½ è¦æ±‚ï¼šå‘ä¸‹æ»šåŠ¨(æ­£æ•°) -> æ’­æ”¾çº¿å¾€å‰(æ—¶é—´å¢åŠ ) -> æ‰€ä»¥ç”¨ 1
                const direction = -1;

                // --- è®¡ç®—æ–°æ—¶é—´ ---
                let newTime = STATE.currentTime + (rawDelta * sensitivity * direction);

                // --- è¾¹ç•Œé™åˆ¶ ---
                if (newTime < 0) newTime = 0;
                if (newTime > STATE.totalDuration) newTime = STATE.totalDuration;

                // --- æ‰§è¡Œè·³è½¬ ---
                seekTo(newTime);
            }
        };

        // 1. ç»‘å®šåˆ°æ—¶é—´è½´åŒºåŸŸ (ä¿æŒåŸæœ‰åŠŸèƒ½)
        DOM.timelineLanes.addEventListener('wheel', handleShiftScrub, { passive: false });

        // 2. ğŸ”¥ ç»‘å®šåˆ° 3D å¯è§†åŒ–åŒºåŸŸ (æ–°å¢åŠŸèƒ½)
        // å…³é”®ç‚¹ï¼šä½¿ç”¨ { capture: true } å¼€å¯æ•è·æ¨¡å¼
        // è¿™èƒ½è®©æˆ‘ä»¬åœ¨ OrbitControls (ç¼©æ”¾åŠŸèƒ½) æ”¶åˆ°äº‹ä»¶ä¹‹å‰ï¼Œå…ˆæ‹¦æˆªä¸‹æ¥
        const vizContainer = document.getElementById('visualizer-section');
        if (vizContainer) {
            vizContainer.addEventListener('wheel', handleShiftScrub, { passive: false, capture: true });
        }

        // ğŸ”¥ æ–°å¢ï¼šç‚¹å‡»æ ‡å°ºåŒºåŸŸä¹Ÿèƒ½è·³è½¬æ—¶é—´ (Seek)
        DOM.rulerContent.addEventListener('mousedown', (e) => {
            // è®¡ç®—ç‚¹å‡»ä½ç½®ç›¸å¯¹äºæ ‡å°ºå†…å®¹çš„ X åæ ‡
            const rect = DOM.rulerContent.getBoundingClientRect();
            // å¿…é¡»åŠ ä¸Š scrollLeftï¼Œå› ä¸ºæ ‡å°ºæ˜¯å¯ä»¥æ»šåŠ¨çš„
            const offsetX = e.clientX - rect.left + DOM.rulerContent.scrollLeft;

            const time = offsetX / STATE.pxPerSec;
            seekTo(time);

            // (å¯é€‰) å¦‚æœä½ æƒ³æ”¯æŒâ€œåœ¨æ ‡å°ºä¸Šæ‹–åŠ¨ scrubbingâ€
            // å¯ä»¥å¤ç”¨ç±»ä¼¼äº Clip æ‹–æ‹½çš„é€»è¾‘ï¼Œç›‘å¬ mousemove
        });

        // äº‹ä»¶ç›‘å¬
        DOM.playBtn.addEventListener('click', togglePlay);
        DOM.stopBtn.addEventListener('click', stopPlay);

        // âœ… ç»‘å®šæ–°çš„ Input é€»è¾‘
        document.getElementById('midiInput').addEventListener('change', (e) => processMidiFile(e.target.files[0]));
        document.getElementById('audioInput').addEventListener('change', (e) => processAudioFile(e.target.files[0]));

        // 2. ç»‘å®šæŒ‰é’®ç‚¹å‡»äº‹ä»¶ (è°ƒç”¨ä¸Šé¢çš„å‡½æ•°)
        document.getElementById('bgInput').addEventListener('change', (e) => {
            processBackgroundFile(e.target.files[0]);
        });

        // 1. Thickness æ»‘å—
        document.getElementById('thicknessSlider').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            STATE.noteThickness = val / 100;

            // ğŸ”¥ æ–°å¢ï¼šæ›´æ–°æ˜¾ç¤ºçš„æ•°å€¼
            const displayVal = STATE.noteThickness.toFixed(1);
            const textEl = document.getElementById('val-thickness');
            if(textEl) textEl.innerText = displayVal;

            STATE.clips.forEach(c => c.build3D());
            updateAllTracksVisibility();
        });

        // 2. Height Scale æ»‘å—
        document.getElementById('heightSlider').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            STATE.noteHeightScale = val / 100;

            // ğŸ”¥ æ–°å¢ï¼šæ›´æ–°æ˜¾ç¤ºçš„æ•°å€¼
            const displayVal = STATE.noteHeightScale.toFixed(1);
            const textEl = document.getElementById('val-height');
            if(textEl) textEl.innerText = displayVal;

            STATE.clips.forEach(c => c.build3D());
            updateAllTracksVisibility();
        });

        // 3. Z-Space æ»‘å—
        document.getElementById('zSpaceSlider').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            STATE.zSeparation = val / 10;

            // ğŸ”¥ æ–°å¢ï¼šæ›´æ–°æ˜¾ç¤ºçš„æ•°å€¼
            const displayVal = STATE.zSeparation.toFixed(1);
            const textEl = document.getElementById('val-zSpace');
            if(textEl) textEl.innerText = displayVal;

            updateTrackZRanks();
            STATE.clips.forEach(c => c.build3D());
            updateAllTracksVisibility();
        });

        // åœ¨ initController å‡½æ•°å†…éƒ¨

        DOM.sceneZoom.addEventListener('input', (e) => {
            // 1. è·å–æ—§é€Ÿåº¦å’Œæ–°é€Ÿåº¦
            const oldSpeed = STATE.playbackSpeed;
            const newSpeed = parseInt(e.target.value);

            const textEl = document.getElementById('val-sceneZoom');
            if(textEl) textEl.innerText = newSpeed;

            STATE.playbackSpeed = newSpeed;

            // 2. æ ¸å¿ƒä¿®å¤ï¼šè®¡ç®—ç¼©æ”¾å¯¼è‡´çš„ä¸­å¿ƒç‚¹ä½ç§»å·®
            // åªæœ‰åŸºäº currentTime è®¡ç®—ï¼Œæ‰èƒ½ä¿è¯ä»¥"æ’­æ”¾å¤´"ä¸ºä¸­å¿ƒç¼©æ”¾
            const oldFocusX = STATE.currentTime * oldSpeed;
            const newFocusX = STATE.currentTime * newSpeed;
            const delta = newFocusX - oldFocusX;

            // 3. é‡å»º 3D ç‰©ä½“ (ä¿æŒä¸å˜)
            STATE.clips.forEach(c => c.build3D());
            updateAllTracksVisibility(); // ğŸ”¥ ç¡®ä¿é‡å»ºååˆ·æ–°å¯è§æ€§

            // 4. ç«‹å³ä¿®æ­£ç›¸æœºå’Œæ§åˆ¶å™¨çš„ä½ç½®
            camera.position.x += delta;
            controls.target.x += delta;
            cameraTargetX = newFocusX;
        });

        // æ—¶é—´è½´ç‚¹å‡»è·³è½¬
        DOM.timelineLanes.addEventListener('mousedown', (e) => {
            // å¦‚æœç‚¹å‡»çš„æ˜¯ clipï¼Œä¸è¦è·³è½¬
            if(e.target.classList.contains('clip') || e.target.classList.contains('clip-name')) return;

            const rect = DOM.timelineLanes.getBoundingClientRect();
            const offsetX = e.clientX - rect.left + DOM.timelineLanes.scrollLeft;
            const time = offsetX / STATE.pxPerSec;
            seekTo(time);
        });

        DOM.timelineLanes.addEventListener('scroll', () => {
            DOM.headers.scrollTop = DOM.timelineLanes.scrollTop;
        });

        window.addEventListener('keydown', (e) => {
            const target = e.target;
            const tag = target.tagName.toUpperCase();

            // ============================================================
            // ğŸ”¥ æ ¸å¿ƒä¿®å¤ 1ï¼šæ›´ç²¾å‡†çš„â€œæ­£åœ¨æ‰“å­—â€æ£€æµ‹
            // ============================================================
            // åªåœ¨ç”¨æˆ·çœŸæ­£éœ€è¦æ‰“å­—çš„æ—¶å€™ï¼ˆæ–‡æœ¬æ¡†ã€æ•°å­—æ¡†ã€å¤‡æ³¨æ¡†ï¼‰æ‰å±è”½å¿«æ·é”®
            // å…è®¸ input[type="range"] (æ»‘å—), input[type="color"], button ç­‰å“åº”å…¨å±€å¿«æ·é”®
            const isTyping = (
                tag === 'TEXTAREA' ||
                target.isContentEditable ||
                (tag === 'INPUT' && (target.type === 'text' || target.type === 'number' || target.type === 'password' || target.type === 'search'))
            );

            if (isTyping) {
                // å¦‚æœæ­£åœ¨æ‰“å­—ï¼Œä¸è¦è§¦å‘ DAW çš„å¿«æ·é”®ï¼Œä½†è¦å…è®¸ ESC é€€å‡ºç„¦ç‚¹
                if (e.code === 'Escape') target.blur();
                return;
            }

            if (e.code === 'KeyR') {
                toggleRecord();
                return;
            }

            if ((e.ctrlKey || e.metaKey) && e.code === 'KeyA') {
                e.preventDefault(); // ğŸ›‘ æ ¸å¿ƒï¼šé˜»æ­¢æµè§ˆå™¨é»˜è®¤çš„â€œå…¨é€‰ç½‘é¡µæ–‡æœ¬â€è¡Œä¸º

                // éå†æ‰€æœ‰ Clip å¹¶é€‰ä¸­
                STATE.clips.forEach(clip => {
                    selectClip(clip, true); // true è¡¨ç¤ºæ·»åŠ åˆ°é€‰ä¸­é›†åˆï¼Œä¸æ¸…é™¤æ—§çš„
                });
                console.log(`å·²å…¨é€‰ ${STATE.clips.length} ä¸ª Clip`);
                return; // ç»“æŸï¼Œä¸å†å¤„ç†åç»­é€»è¾‘
            }

            if (e.code === 'Escape') {
                // 1. å®šä¹‰æ‰€æœ‰å¼¹çª—çš„ ID åˆ—è¡¨
                const modalIds = [
                    'export-modal',
                    'save-project-modal',
                    'bg-settings-modal',
                    'view-settings-modal',
                    'model-preview-modal',
                    'version-modal',
                    'context-menu' // å³é”®èœå•
                ];

                // 2. éå†éšè—
                modalIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = 'none';
                });

                // 3. ç‰¹æ®Šå¤„ç†é¢œè‰²é€‰æ‹©å™¨ (è°ƒç”¨ close æ–¹æ³•ä»¥æ¸…ç†å†…éƒ¨å›è°ƒçŠ¶æ€)
                if (typeof ColorPickerMgr !== 'undefined') {
                    ColorPickerMgr.close();
                }

                // 4. ç‰¹æ®Šå¤„ç†æ¨¡å‹é¢„è§ˆ (æ¸…ç†åŠ¨ç”»å¾ªç¯)
                if (typeof closePreviewModal === 'function') {
                    closePreviewModal();
                }
            }

            // 5. ä¿å­˜ç›¸å…³å¿«æ·é”®
            if ((e.ctrlKey || e.metaKey) && e.code === 'KeyS') {
                e.preventDefault(); // é˜»æ­¢æµè§ˆå™¨é»˜è®¤çš„ä¿å­˜å¼¹çª—

                if (e.shiftKey) {
                    // ğŸ”¥ æƒ…å†µ A: Shift + Ctrl + S (æˆ– Shift + Cmd + S) -> å¼ºåˆ¶å¦å­˜ä¸º (Save As)
                    // ç”Ÿæˆé»˜è®¤æ–‡ä»¶å
                    const defaultName = `SeeMusic_Project_${new Date().toLocaleDateString().replace(/\//g, '-')}`;
                    // è°ƒç”¨å¦å­˜ä¸ºé€»è¾‘
                    ProjectMgr.executeSave(defaultName);
                    console.log("è§¦å‘å¦å­˜ä¸º (Save As)");
                } else {
                    // ğŸ”¥ æƒ…å†µ B: Ctrl + S (æˆ– Cmd + S) -> æ™ºèƒ½ä¿å­˜ (Quick Save)
                    // å¦‚æœæœ‰å¥æŸ„åˆ™è¦†ç›–ï¼Œæ²¡æœ‰åˆ™å¦å­˜ä¸º
                    ProjectMgr.quickSave();
                }
            }

            // --- M é”®ï¼šMute é€‰ä¸­è½¨é“ ---
            if (e.code === 'KeyM') {
                if (STATE.selectedTrackIds.size > 0) {
                    const firstId = Array.from(STATE.selectedTrackIds)[0];
                    const firstTrack = STATE.tracks.find(t => t.id === firstId);
                    const targetMute = !firstTrack.isMuted;

                    STATE.selectedTrackIds.forEach(id => {
                        const t = STATE.tracks.find(track => track.id === id);
                        if (t) t.setMute(targetMute);
                    });
                    updateAllTracksVisibility();
                }
            }

            // --- S é”®ï¼šSolo é€‰ä¸­è½¨é“ ---
            if (e.code === 'KeyS') {
                if (STATE.selectedTrackIds.size > 0) {
                    const firstId = Array.from(STATE.selectedTrackIds)[0];
                    const firstTrack = STATE.tracks.find(t => t.id === firstId);
                    const targetSolo = !firstTrack.isSoloed;

                    STATE.selectedTrackIds.forEach(id => {
                        const t = STATE.tracks.find(track => track.id === id);
                        if (t) t.setSolo(targetSolo);
                    });
                    updateAllTracksVisibility();
                }
            }

            // ============================================================
            // ğŸ”¥ æ ¸å¿ƒä¿®å¤ 2ï¼šæ’­æ”¾æ§åˆ¶ (ç©ºæ ¼é”®) ç»ˆææŠ¢ç„¦ç‚¹
            // ============================================================
            if(e.code === 'Space') {
                // 1. é˜»æ­¢æµè§ˆå™¨é»˜è®¤è¡Œä¸º (é˜²æ­¢æ»šåŠ¨é¡µé¢ã€é˜²æ­¢è§¦å‘æŒ‰é’®ç‚¹å‡»)
                e.preventDefault();
                e.stopPropagation();

                // 2. ğŸ”¥ğŸ”¥ğŸ”¥ å¼ºåˆ¶ç§»é™¤ç„¦ç‚¹ (Blur) ğŸ”¥ğŸ”¥ğŸ”¥
                // æ— è®ºå½“å‰ç„¦ç‚¹æ˜¯åœ¨ Button ä¸Šï¼Œè¿˜æ˜¯åœ¨ Range æ»‘å—ä¸Šï¼Œç»Ÿç»Ÿç§»é™¤ï¼
                // è¿™æ ·ç©ºæ ¼é”®å°±åªå±äºâ€œæ’­æ”¾/æš‚åœâ€ï¼Œç»ä¸ä¼šè¯¯è§¦å…¶ä»–æ§ä»¶
                if (document.activeElement && document.activeElement !== document.body) {
                    document.activeElement.blur();
                }

                togglePlay();
            }

            if (e.code === 'Backspace' || e.code === 'Delete') {
                e.preventDefault();

                // ğŸ”¥ ä¼˜å…ˆå¤„ç†ï¼šåˆ é™¤é€‰ä¸­çš„ MIDI äº‹ä»¶ (Clips)
                if (STATE.selectedClips.size > 0) {
                    const clipsToDelete = Array.from(STATE.selectedClips);

                    // 1. å‡†å¤‡å†å²æ•°æ®
                    const backupData = clipsToDelete.map(clip => ({
                        trackId: clip.track.id,
                        data: serializeClip(clip)
                    }));

                    // 2. æ·»åŠ åˆ°å†å²è®°å½•
                    HistoryMgr.add({
                        type: 'delete_events',
                        backup: backupData,
                        originalClips: clipsToDelete // å­˜å¼•ç”¨ç”¨äºåˆæ¬¡æ“ä½œ
                    });

                    // 3. æ‰§è¡Œåˆ é™¤
                    clipsToDelete.forEach(clip => {
                        // ä» Track ç§»é™¤
                        const idx = clip.track.clips.indexOf(clip);
                        if (idx > -1) clip.track.clips.splice(idx, 1);

                        // é”€æ¯èµ„æº
                        clip.destroy();

                        // ä»å…¨å±€ STATE ç§»é™¤
                        const gIdx = STATE.clips.indexOf(clip);
                        if (gIdx > -1) STATE.clips.splice(gIdx, 1);
                    });

                    // æ¸…ç©ºé€‰ä¸­
                    STATE.selectedClips.clear();
                    console.log(`å·²åˆ é™¤ ${clipsToDelete.length} ä¸ªäº‹ä»¶ (å¯æ’¤å›)`);
                    return; // ğŸ”¥ åˆ äº†äº‹ä»¶å°±ä¸åˆ è½¨é“äº†ï¼Œç›´æ¥è¿”å›
                }
                if (STATE.selectedTrackIds.size > 0) {
                    e.preventDefault();

                    const tracksToDelete = [];
                    STATE.selectedTrackIds.forEach(id => {
                        const t = STATE.tracks.find(x => x.id === id);
                        if(t) tracksToDelete.push(t);
                    });

                    tracksToDelete.forEach(t => {
                        const trackData = serializeTrack(t);
                        const index = STATE.tracks.indexOf(t);

                        HistoryMgr.add({
                            type: 'delete_track',
                            trackData: trackData,
                            index: index
                        });

                        deleteTrackContext(t);
                    });
                }
            }

            // 4. æ’¤é”€ä¸é‡åš (Ctrl+Z / Ctrl+Y)
            if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.code === 'KeyZ') {
                e.preventDefault();
                HistoryMgr.undo();
            }
            if ((e.ctrlKey || e.metaKey) && e.code === 'KeyY') {
                e.preventDefault();
                HistoryMgr.redo();
            }
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.code === 'KeyZ') {
                e.preventDefault();
                HistoryMgr.redo();
            }
        });

        const sliders = ['sceneZoom', 'thicknessSlider', 'heightSlider'];
        sliders.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                // 1. é˜»æ­¢ mousedown å†’æ³¡ï¼Œé˜²æ­¢è§¦å‘çˆ¶çº§ç‚¹å‡»é€»è¾‘
                el.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                });

                // 2. ã€å…³é”®ã€‘é˜»æ­¢ dragstartã€‚
                // å¦‚æœä¸åŠ è¿™ä¸ªï¼Œå¿«é€Ÿæ‹–åŠ¨æ—¶æµè§ˆå™¨ä¼šä»¥ä¸ºä½ åœ¨æ‹–æ‹½å›¾ç‰‡ï¼Œä»è€Œä¸­æ–­æ»‘å—æ“ä½œã€‚
                el.addEventListener('dragstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });

                // 3. é’ˆå¯¹è§¦æ‘¸å±/è§¦æ§æ¿çš„ä¿®å¤
                el.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                }, { passive: false });
            }
        });

        // ğŸ”¥ æ ¸å¿ƒä¿®å¤ 2ï¼šåˆå§‹åŒ–æ—¶ä¹ŸåŒæ­¥ä¸€ä¸‹ 3D Zoom å’Œå…¶ä»–æ»‘å—
        if (DOM.sceneZoom) {
            STATE.playbackSpeed = parseInt(DOM.sceneZoom.value);
        }
        updateGridBackground();

        const menu = document.getElementById('context-menu');
        const menuGroup = document.getElementById('menu-group');
        const menuUngroup = document.getElementById('menu-ungroup');

        const shapeSelect = document.getElementById('noteShapeSelect');
        const modelInput = document.getElementById('customModelInput');

        // ç»‘å®šå½•åˆ¶æŒ‰é’®
        if (DOM.recordBtn) {
            DOM.recordBtn.addEventListener('click', toggleRecord);
        }

        if (shapeSelect) {
            shapeSelect.addEventListener('keydown', (e) => e.stopPropagation());

            shapeSelect.addEventListener('change', (e) => {
                const val = e.target.value;

                if (val === 'custom') {
                    // å¦‚æœé€‰äº†è‡ªå®šä¹‰ï¼Œè§¦å‘æ–‡ä»¶é€‰æ‹©
                    modelInput.click();
                    // æš‚æ—¶åˆ‡å›ä¸Šä¸€ä¸ªçŠ¶æ€ï¼Œé˜²æ­¢è¿˜æ²¡é€‰æ–‡ä»¶å°±å´©äº†ï¼ˆå¯é€‰ä¼˜åŒ–ï¼‰
                } else {
                    STATE.noteShape = val;
                    refreshAllMidiMeshes();
                }
            });
        }

        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        if (modelInput) {
            modelInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // æ˜¾ç¤ºåŠ è½½ä¸­...
                const loader = new GLTFLoader();
                const reader = new FileReader();

                reader.onload = (ev) => {
                    loader.parse(ev.target.result, '', (gltf) => {

                        // 1. å‡†å¤‡ä¸€ä¸ªæ•°ç»„å­˜æ”¾æ‰€æœ‰é›¶ä»¶
                        const geometries = [];

                        // 2. å¼ºåˆ¶æ›´æ–°ä¸€ä¸‹æ¨¡å‹çš„ä¸–ç•ŒçŸ©é˜µï¼Œç¡®ä¿é›¶ä»¶ä½ç½®æ­£ç¡®
                        gltf.scene.updateMatrixWorld(true);

                        // 3. éå†æ‰€æœ‰å­å¯¹è±¡
                        gltf.scene.traverse((child) => {
                            if (child.isMesh) {
                                // å…‹éš†å‡ ä½•ä½“
                                const geo = child.geometry.clone();

                                // ğŸ”¥ å…³é”®æ­¥éª¤ï¼šåº”ç”¨è¯¥é›¶ä»¶åœ¨æ¨¡å‹ä¸­çš„ä½ç½®/æ—‹è½¬/ç¼©æ”¾
                                // å¦‚æœä¸åŠ è¿™è¡Œï¼Œæ‰€æœ‰æŒ‰é”®éƒ½ä¼šå †åœ¨åŸç‚¹(0,0,0)
                                geo.applyMatrix4(child.matrixWorld);

                                // æ”¶é›†èµ·æ¥
                                geometries.push(geo);
                            }
                        });

                        if (geometries.length > 0) {
                            // ğŸ”¥ 4. ä½¿ç”¨å·¥å…·å°†æ‰€æœ‰é›¶ä»¶åˆå¹¶æˆä¸€ä¸ªå·¨å¤§çš„å‡ ä½•ä½“
                            // useGroups: false è¡¨ç¤ºæˆ‘ä»¬ä¸éœ€è¦ä¿ç•™å¤šæè´¨åˆ†ç»„ï¼ˆå› ä¸ºåæ­£è¦å˜æˆå‘å…‰éŸ³ç¬¦ï¼‰
                            let mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries, false);

                            // 5. å±…ä¸­å¹¶æ ‡å‡†åŒ–å¤§å° (å¤ç”¨ä½ ä¹‹å‰çš„é€»è¾‘)
                            mergedGeometry = normalizeGeometry(mergedGeometry);

                            // 6. æ•æ‰ç¬¬ä¸€ä¸ªæè´¨ç”¨äºé¢„è§ˆ (å¯é€‰ï¼Œå–ç¬¬ä¸€ä¸ªé›¶ä»¶çš„æè´¨)
                            // é•¿ç¬›é€šå¸¸æè´¨éƒ½ä¸€æ ·ï¼Œå–ç¬¬ä¸€ä¸ªå°±è¡Œ
                            let foundMaterial = null;
                            gltf.scene.traverse(c => {
                                if (!foundMaterial && c.isMesh) foundMaterial = c.material;
                            });

                            // 7. æ‰“å¼€é¢„è§ˆçª—å£
                            openPreviewModal(mergedGeometry, foundMaterial);

                        } else {
                            alert("é”™è¯¯ï¼šæ¨¡å‹ä¸­æ²¡æœ‰å‘ç°ä»»ä½• Mesh å‡ ä½•ä½“ã€‚");
                        }
                    }, (err) => {
                        console.error(err);
                        alert("æ¨¡å‹è§£æå¤±è´¥ï¼Œå¯èƒ½æ˜¯æ–‡ä»¶æŸåã€‚");
                    });
                };
                reader.readAsArrayBuffer(file);
                e.target.value = '';
            });
        }

        const resetBtn = document.getElementById('resetViewBtn');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                // 1. æ¢å¤ DOM å…ƒç´ çš„å€¼åˆ°é»˜è®¤ (å‚è€ƒ HTML ä¸­çš„ value)
                // DOM.timelineZoom.value = 50;
                DOM.sceneZoom.value = 8;
                document.getElementById('heightSlider').value = 250;
                document.getElementById('thicknessSlider').value = 150;

                if (shapeSelect) {
                    shapeSelect.value = 'capsule';
                    STATE.noteShape = 'capsule';
                }

                // 2. æ‰‹åŠ¨è§¦å‘ input äº‹ä»¶ï¼Œåˆ©ç”¨å·²æœ‰çš„ç›‘å¬å™¨å»æ›´æ–° STATE å’Œ 3D è§†å›¾
                // è¿™æ ·ä¸éœ€è¦é‡å†™æ›´æ–°é€»è¾‘
                [DOM.timelineZoom, DOM.sceneZoom, document.getElementById('heightSlider'), document.getElementById('thicknessSlider')].forEach(el => {
                    el.dispatchEvent(new Event('input'));
                });

                STATE.clips.forEach(c => { if (c.track.type === 'midi') c.build3D(); });

                // 3. é¢å¤–ç¡®ä¿ç½‘æ ¼æ›´æ–°
                updateGridBackground();
            });
        }

        // éšè—èœå• (ç‚¹å‡»ç©ºç™½å¤„)
        window.addEventListener('click', () => {
            menu.style.display = 'none';
        });

        // ç»‘å®šèœå•åŠ¨ä½œ
        menuGroup.addEventListener('click', () => {
            createGroupForSelection();
            menu.style.display = 'none';
        });

        menuUngroup.addEventListener('click', () => {
            ungroupSelection();
            menu.style.display = 'none';
        });

        initMidiAccess();

        initScrubbing();
        initBoxSelection();
        ViewMgr.init();
    }

    // --- ç»ˆæç‰ˆ ViewMgr (çƒåæ ‡ + è§’åº¦ä¿®æ­£ + Xå¹³ç§») ---
    const ViewMgr = {
        // é»˜è®¤å€¼ï¼šè·ç¦»80ï¼Œæ°´å¹³0åº¦ï¼Œå‚ç›´-30åº¦(ç›¸å½“äºåŸæ¥çš„60åº¦ä¿¯è§†)
        defaults: { radius: 200, theta: 0, phi: 0, targetX: 0, targetY: 0 },

        init() {
            this.modal = document.getElementById('view-settings-modal');
            this.inputs = {
                radius: document.getElementById('cam-radius'),
                theta: document.getElementById('cam-theta'),
                phi: document.getElementById('cam-phi'),
                targetX: document.getElementById('target-off-x'), // æ–°å¢
                targetY: document.getElementById('target-off-y')
            };

            // ç»‘å®šäº‹ä»¶ (ä¿æŒä¸å˜)
            document.getElementById('viewSettingsBtn').addEventListener('click', () => {
                this.modal.style.display = 'flex';
                this.forceSync();
            });
            document.getElementById('closeViewSettingsBtn').addEventListener('click', () => {
                this.modal.style.display = 'none';
            });
            // å›è½¦é”®
            Object.values(this.inputs).forEach(el => {
                if(el) el.addEventListener('keydown', e => {
                    if(e.key === 'Enter') this.applyFromUIToScene();
                });
            });
            // å¯¼å…¥å¯¼å‡º
            document.getElementById('exportViewBtn').addEventListener('click', () => this.exportToFile());
            const fileInput = document.getElementById('viewParamInput');
            document.getElementById('importViewBtn').addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                if (e.target.files[0]) this.importFromFile(e.target.files[0]);
                e.target.value = '';
            });
        },

        // ğŸ”¥ è·å–é€»è¾‘ (åœºæ™¯ -> UI)
        getCurrentSpherical() {
            if (!camera || !controls) return null;

            // 1. ç›¸å¯¹å‘é‡
            const offset = new THREE.Vector3().copy(camera.position).sub(controls.target);
            const spherical = new THREE.Spherical().setFromVector3(offset);

            // 2. è§’åº¦ä¿®æ­£
            // Three.js: 0=é¡¶, 90=å¹³, 180=åº•
            // ç”¨æˆ·ä¹ æƒ¯: -90=é¡¶, 0=å¹³, 90=åº• (æˆ–è€…åè¿‡æ¥)
            // è¿™é‡Œæˆ‘ä»¬è¦è®© "90åº¦(æ°´å¹³)" æ˜¾ç¤ºä¸º "0åº¦" -> å…¬å¼: æ˜¾ç¤ºå€¼ = çœŸå®å€¼ - 90
            const displayPhi = THREE.MathUtils.radToDeg(spherical.phi) - 90;
            const displayTheta = THREE.MathUtils.radToDeg(spherical.theta);

            // 3. è®¡ç®—ç›¸å¯¹ Target X
            // cameraTargetX æ˜¯å…¨å±€å˜é‡ï¼Œä»£è¡¨æ’­æ”¾å¤´çš„ç†è®ºä½ç½®
            // controls.target.x æ˜¯å½“å‰ç›¸æœºçš„çœ‹å‘ç‚¹
            // å®ƒä»¬çš„å·®å€¼å°±æ˜¯ç”¨æˆ·çš„ "Pan Offset X"
            const relTargetX = controls.target.x - (typeof cameraTargetX !== 'undefined' ? cameraTargetX : 0);

            return {
                radius: spherical.radius,
                theta: displayTheta,
                phi: displayPhi,
                targetX: relTargetX,
                targetY: controls.target.y
            };
        },

        // å®æ—¶æ›´æ–°å¼¹çª— UI
        updateLiveUI() {
            if (!this.modal || this.modal.style.display === 'none') return;
            const s = this.getCurrentSpherical();
            if (!s) return;

            const active = document.activeElement;
            const safeUpdate = (el, val) => { if (active !== el) el.value = val; };

            safeUpdate(this.inputs.radius, s.radius.toFixed(1));
            safeUpdate(this.inputs.theta,  s.theta.toFixed(1));
            safeUpdate(this.inputs.phi,    s.phi.toFixed(1)); // å·²ç»æ˜¯ä¿®æ­£è¿‡çš„è§’åº¦
            safeUpdate(this.inputs.targetX, s.targetX.toFixed(1));
            safeUpdate(this.inputs.targetY, s.targetY.toFixed(1));
        },

        forceSync() {
            const s = this.getCurrentSpherical();
            if(!s) return;
            this.inputs.radius.value = s.radius.toFixed(1);
            this.inputs.theta.value = s.theta.toFixed(1);
            this.inputs.phi.value = s.phi.toFixed(1);
            this.inputs.targetX.value = s.targetX.toFixed(1);
            this.inputs.targetY.value = s.targetY.toFixed(1);
        },

        // ğŸ”¥ åº”ç”¨é€»è¾‘ (UI -> åœºæ™¯)
        applyFromUIToScene() {
            if (!camera || !controls) return;

            const r = parseFloat(this.inputs.radius.value);
            const t = parseFloat(this.inputs.theta.value);
            const p = parseFloat(this.inputs.phi.value);
            const tx = parseFloat(this.inputs.targetX.value);
            const ty = parseFloat(this.inputs.targetY.value);

            // 1. è¿˜åŸè§’åº¦ (UI + 90 = çœŸå®Phi)
            const realPhi = p + 90;

            // 2. è½¬å›çƒåæ ‡
            // é™åˆ¶ Phi é˜²æ­¢ä¸‡å‘èŠ‚æ­»é” (0.001 ~ 179.999)
            const clampedPhi = Math.max(0.1, Math.min(179.9, realPhi));

            const spherical = new THREE.Spherical(
                r,
                THREE.MathUtils.degToRad(clampedPhi),
                THREE.MathUtils.degToRad(t)
            );

            const newOffset = new THREE.Vector3().setFromSpherical(spherical);

            // 3. åº”ç”¨ Target åç§»
            // Target X = æ’­æ”¾å¤´åŸºå‡†(cameraTargetX) + ç”¨æˆ·åç§»(tx)
            const baseX = (typeof cameraTargetX !== 'undefined' ? cameraTargetX : controls.target.x);
            controls.target.set(baseX + tx, ty, 0);

            // 4. åº”ç”¨ Camera ä½ç½®
            camera.position.copy(controls.target).add(newOffset);

            controls.update();
            document.activeElement.blur();
        },

        // åœ¨ ViewMgr å¯¹è±¡å†…éƒ¨ï¼š

        async exportToFile() {
            const s = this.getCurrentSpherical();
            const sceneParams = {
                wScale: DOM.sceneZoom ? DOM.sceneZoom.value : 20,
                hScale: document.getElementById('heightSlider').value,
                thickness: document.getElementById('thicknessSlider').value,
                zSpace: document.getElementById('zSpaceSlider').value
            };
            const data = {
                name: "SeeMusic Spherical View",
                timestamp: new Date().toISOString(),
                params: s,
                sceneSettings: sceneParams
            };
            const jsonStr = JSON.stringify(data, null, 2);

            // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šå°è¯•è°ƒç”¨ç³»ç»ŸåŸç”Ÿçš„"å¦å­˜ä¸º"çª—å£
            if (window.showSaveFilePicker) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: `View_Preset.json`, // é»˜è®¤æ–‡ä»¶å
                        types: [{
                            description: 'SeeMusic View Preset',
                            accept: {'application/json': ['.json']},
                        }],
                    });

                    // å†™å…¥æ–‡ä»¶
                    const writable = await handle.createWritable();
                    await writable.write(jsonStr);
                    await writable.close();

                    alert("é¢„è®¾ä¿å­˜æˆåŠŸï¼");
                    return; // æˆåŠŸåç›´æ¥ç»“æŸ
                } catch (err) {
                    // å¦‚æœç”¨æˆ·ç‚¹å‡»äº†å–æ¶ˆï¼Œä»€ä¹ˆéƒ½ä¸åš
                    if (err.name === 'AbortError') return;
                    console.warn("ä¿å­˜æ–‡ä»¶å‡ºé”™ï¼Œå°è¯•é™çº§ä¸ºè‡ªåŠ¨ä¸‹è½½:", err);
                }
            }

            // å¤‡ç”¨æ–¹æ¡ˆ (å…¼å®¹æ—§æµè§ˆå™¨)ï¼šè‡ªåŠ¨ä¸‹è½½
            const blob = new Blob([jsonStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `View_Preset.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        },

        importFromFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const json = JSON.parse(e.target.result);
                    if (json.params && json.params.radius !== undefined) {

                        // ğŸ”¥ ä¿®æ”¹ï¼šè®°å½•å†å²
                        const oldView = this.getCurrentSpherical(); // 1. ç•™åº•
                        this.restore(json.params, json.sceneSettings);           // 2. åº”ç”¨

                        HistoryMgr.add({                            // 3. å­˜æ¡£
                            type: 'change_view',
                            oldView: oldView,
                            newView: json.params
                        });
                        alert("è§†è§’é¢„è®¾å·²åŠ è½½");
                    } else {
                        alert("æ ¼å¼é”™è¯¯");
                    }
                } catch (err) { alert("JSON è§£æå¤±è´¥"); }
            };
            reader.readAsText(file);
        },

        restore(viewData, sceneData) {
            // 1. æ¢å¤è§†è§’ (Spherical)
            if (viewData && viewData.radius !== undefined) {
                this.inputs.radius.value = viewData.radius;
                this.inputs.theta.value = viewData.theta;
                this.inputs.phi.value = viewData.phi;
                this.inputs.targetX.value = viewData.targetX || 0;
                this.inputs.targetY.value = viewData.targetY;
                this.applyFromUIToScene();
            }

            // 2. ğŸ”¥ æ¢å¤åœºæ™¯å‚æ•° (é€šè¿‡æ¨¡æ‹Ÿ Input äº‹ä»¶è§¦å‘æ‰€æœ‰æ›´æ–°é€»è¾‘)
            if (sceneData) {
                const updateSlider = (id, val) => {
                    const el = document.getElementById(id);
                    if (el && val !== undefined) {
                        el.value = val;
                        // è§¦å‘ input äº‹ä»¶ï¼Œè¿™æ ·ä¸Šé¢å†™çš„ç›‘å¬å™¨å°±ä¼šè‡ªåŠ¨è¿è¡Œï¼šæ›´æ–° STATEï¼Œæ›´æ–°æ•°å€¼æ–‡å­—ï¼Œé‡å»º 3D
                        el.dispatchEvent(new Event('input'));
                    }
                };

                updateSlider('sceneZoom', sceneData.wScale);
                updateSlider('heightSlider', sceneData.hScale);
                updateSlider('thicknessSlider', sceneData.thickness);
                updateSlider('zSpaceSlider', sceneData.zSpace);
            }
        },

        reset() {
            // é‡ç½®è§†è§’
            this.restore(this.defaults);
            // é‡ç½®æ»‘å—åˆ°é»˜è®¤å€¼ (ä½ å¯ä»¥åœ¨è¿™é‡Œç¡¬ç¼–ç é»˜è®¤å€¼)
            const defaultScene = { wScale: 20, hScale: 150, thickness: 100, zSpace: 5 };
            this.restore(this.defaults, defaultScene);
        }
    };

    function refreshAllMidiMeshes() {
        if (!STATE || !STATE.clips) return;

        STATE.clips.forEach(c => {
            if (c.track.type === 'midi') c.build3D();
        });
        // ç¡®ä¿ updateAllTracksVisibility ä¹Ÿæ˜¯å…¨å±€å¯è®¿é—®çš„ï¼ˆé€šå¸¸å®ƒå·²ç»æ˜¯äº†ï¼‰
        if (typeof updateAllTracksVisibility === 'function') {
            updateAllTracksVisibility();
        }
    }

    function initDragAndDrop() {
        // 1. å…¨å±€é˜»æ­¢é»˜è®¤è¡Œä¸º
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            window.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
            }, false);
        });

        // 2. æ‹–å…¥æ˜¾ç¤ºå…¨å±é®ç½©
        window.addEventListener('dragenter', () => {
            document.body.classList.add('global-drag-over');
        });

        // 3. æ‹–ç¦»éšè—é®ç½©
        window.addEventListener('dragleave', (e) => {
            if (e.relatedTarget === null) {
                document.body.classList.remove('global-drag-over');
            }
        });

        // 4. é‡Šæ”¾æ–‡ä»¶
        window.addEventListener('drop', async (e) => {
            document.body.classList.remove('global-drag-over');

            // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šå¿…é¡»åœ¨ await ä¹‹å‰è·å– filesï¼ğŸ”¥ğŸ”¥ğŸ”¥
            // å¦åˆ™ä¸€æ—¦è¿›å…¥ await å¼‚æ­¥æµç¨‹ï¼Œe.dataTransfer å°±ä¼šè¢«æµè§ˆå™¨æ¸…ç©º
            const files = e.dataTransfer.files;

            // ğŸ”¥ å°è¯•è·å– FileSystemHandle (ç”¨äºæ”¯æŒæ‹–æ‹½åçš„ä¿å­˜)
            const items = e.dataTransfer.items;
            let droppedHandle = null;

            // ç°ä»£æµè§ˆå™¨æ”¯æŒ getAsFileSystemHandle
            if (items && items.length > 0) {
                const item = items[0];
                if (item.kind === 'file' && item.getAsFileSystemHandle) {
                    try {
                        const handle = await item.getAsFileSystemHandle();
                        if (handle.kind === 'file' && handle.name.endsWith('.json')) {
                            droppedHandle = handle;
                        }
                    } catch(err) { console.log("Drop handle access denied"); }
                }
            }

            // è¿™é‡Œä½¿ç”¨æˆ‘ä»¬æœ€å¼€å§‹æ•è·çš„ files å˜é‡ï¼Œè€Œä¸æ˜¯ e.dataTransfer.files
            if (files.length > 0) {
                // å¦‚æœæ£€æµ‹åˆ°æ˜¯ JSON ä¸”è·å–åˆ°äº†å¥æŸ„ï¼Œå­˜å…¥ ProjectMgr
                if (droppedHandle && files[0].name.endsWith('.json')) {
                    ProjectMgr.currentFileHandle = droppedHandle;
                } else {
                    // å¦‚æœæ‹–æ‹½çš„æ˜¯å…¶ä»–æ–‡ä»¶ï¼Œæˆ–è€…æµè§ˆå™¨ä¸æ”¯æŒ handleï¼Œæ¸…ç©ºå¥æŸ„ä»¥å…è¯¯å†™
                    if (files[0].name.endsWith('.json')) {
                        ProjectMgr.currentFileHandle = null;
                    }
                }

                handleGlobalDrop(files);
            }
        });
    }

    // ğŸ”¥ ç»Ÿä¸€çš„æ™ºèƒ½æ–‡ä»¶å¤„ç†å™¨
    function handleGlobalDrop(files) {
        Array.from(files).forEach(file => {
            const name = file.name.toLowerCase();
            const type = file.type;

            console.log(`æ£€æµ‹åˆ°æ–‡ä»¶: ${name} (${type})`);

            // ----------------------------------------------------
            // 1. MIDI æ–‡ä»¶
            // ----------------------------------------------------
            if (name.endsWith('.mid') || name.endsWith('.midi')) {
                processMidiFile(file);
            }

                // ----------------------------------------------------
                // 2. éŸ³é¢‘æ–‡ä»¶ (Audio)
                // ----------------------------------------------------
            // å®½æ¾åˆ¤æ–­ï¼šåªè¦ MIME æ˜¯ audio å¼€å¤´ï¼Œæˆ–è€…åç¼€æ˜¯ mp3/wav/ogg
            else if (type.startsWith('audio/') || name.endsWith('.mp3') || name.endsWith('.wav') || name.endsWith('.ogg') || name.endsWith('.m4a')) {
                processAudioFile(file);
            }

                // ----------------------------------------------------
                // 3. èƒŒæ™¯ç´ æ (Image / Video)
            // ----------------------------------------------------
            else if (type.startsWith('image/') || type.startsWith('video/') ||
                name.endsWith('.png') || name.endsWith('.jpg') || name.endsWith('.jpeg') ||
                name.endsWith('.mp4') || name.endsWith('.webm') || name.endsWith('.mov')) {
                processBackgroundFile(file);
            }

                // ----------------------------------------------------
                // 4. JSON æ–‡ä»¶ (éœ€è¦è¯»å–å†…å®¹æ¥åŒºåˆ†æ˜¯ "å·¥ç¨‹" è¿˜æ˜¯ "è§†è§’")
            // ----------------------------------------------------
            else if (name.endsWith('.json')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const json = JSON.parse(e.target.result);

                        // A. åˆ¤æ–­æ˜¯å¦ä¸ºã€å·¥ç¨‹æ–‡ä»¶ã€‘ (ç‰¹å¾ï¼šæœ‰ tracks å’Œ settings)
                        if (json.tracks && json.settings) {
                            console.log("è¯†åˆ«ä¸ºï¼šå·¥ç¨‹æ–‡ä»¶");
                            // æ”¯æŒæ’¤å›çš„åŠ è½½é€»è¾‘
                            const oldProjectState = ProjectMgr.getCurrentState();
                            ProjectMgr.restoreState(json);
                            HistoryMgr.add({
                                type: 'load_project',
                                oldProject: oldProjectState,
                                newProject: json
                            });
                        }
                        // B. åˆ¤æ–­æ˜¯å¦ä¸ºã€è§†è§’é¢„è®¾ã€‘ (ç‰¹å¾ï¼šæœ‰ params.radius)
                        else if (json.name === "SeeMusic Spherical View" || (json.params && json.params.radius !== undefined)) {
                            console.log("è¯†åˆ«ä¸ºï¼šè§†è§’é¢„è®¾");
                            const params = json.params || json;

                            // æ”¯æŒæ’¤å›çš„åŠ è½½é€»è¾‘
                            const oldView = ViewMgr.getCurrentSpherical();
                            ViewMgr.restore(params, json.sceneSettings);
                            HistoryMgr.add({
                                type: 'change_view',
                                oldView: oldView,
                                newView: params
                            });

                            // ç®€å•çš„æ–‡å­—æç¤º
                            alert("âœ… è§†è§’å‚æ•°å·²åº”ç”¨");
                        }
                        else {
                            alert("âŒ æ— æ³•è¯†åˆ«çš„ JSON æ–‡ä»¶æ ¼å¼");
                        }
                    } catch (err) {
                        console.error(err);
                        alert("JSON è§£æå¤±è´¥");
                    }
                };
                reader.readAsText(file);
            }

                // ----------------------------------------------------
                // 5. 3D æ¨¡å‹ (.glb / .gltf)
            // ----------------------------------------------------
            else if (name.endsWith('.glb') || name.endsWith('.gltf')) {
                // æ—¢ç„¶æ”¯æŒå…¨å±æ‹–æ‹½ï¼Œè¿™é‡Œä¹Ÿå¯ä»¥é¡ºä¾¿æ”¯æŒæ‹–å…¥æ¨¡å‹
                // æ¨¡æ‹Ÿç‚¹å‡» inputï¼Œæˆ–è€…ç›´æ¥è°ƒç”¨ä¹‹å‰çš„æ¨¡å‹åŠ è½½é€»è¾‘
                // è¿™é‡Œç®€å•å¤„ç†ï¼šæç¤ºç”¨æˆ·å»ä¸‹é¢é€‰ï¼Œæˆ–è€…ä½ å¯ä»¥æŠŠä¹‹å‰çš„ GLTF åŠ è½½é€»è¾‘å¤ç”¨åˆ°è¿™é‡Œ
                alert("æ£€æµ‹åˆ° 3D æ¨¡å‹ï¼Œè¯·åœ¨ä¸‹æ–¹ã€Shape -> Customã€‘ä¸­é€‰æ‹©åŠ è½½ï¼Œæˆ–ç¼–å†™ä¸“é—¨çš„æ‹–æ‹½é€»è¾‘ã€‚");
            }

            else {
                console.warn("ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹:", name);
                alert("ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: " + name);
            }
        });
    }

    function initResizeHandle() {
        const handle = document.getElementById('resize-handle');
        const dawContainer = document.getElementById('daw-container');

        if (!handle || !dawContainer) return;

        handle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            document.body.classList.add('resizing');

            const startY = e.clientY;
            const startHeight = dawContainer.getBoundingClientRect().height;
            let animationFrameId = null;

            const onMouseMove = (moveEvent) => {
                // 1. è®¡ç®—é«˜åº¦
                const deltaY = moveEvent.clientY - startY;
                let newHeight = startHeight + deltaY;
                const minHeight = 100;
                const maxHeight = window.innerHeight - 150;

                if (newHeight >= minHeight && newHeight <= maxHeight) {
                    dawContainer.style.height = newHeight + 'px';

                    // 2. ä½¿ç”¨ 'drag' æ¨¡å¼è°ƒç”¨ï¼Œæè‡´ä¸æ»‘
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    animationFrameId = requestAnimationFrame(() => {
                        onResize('drag');
                    });
                }
            };

            const onMouseUp = () => {
                document.body.classList.remove('resizing');
                window.removeEventListener('mousemove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);

                // 3. æ¾æ‰‹ç¬é—´ï¼Œæ‰§è¡Œä¸€æ¬¡â€œå®Œç¾æ¸²æŸ“â€
                // æ­¤æ—¶è™½ç„¶ä¼šé—ªä¸€ä¸‹ï¼Œä½†ç”¨æˆ·å·²ç»åœæ­¢æ“ä½œäº†ï¼Œä½“éªŒæ˜¯å¯ä»¥æ¥å—çš„
                requestAnimationFrame(() => {
                    onResize();
                });
            };

            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
        });
    }

    // è¾…åŠ©ï¼šæ˜¾ç¤ºèœå• (å·²ä¼˜åŒ–è¾¹ç•Œæ£€æµ‹)
    function showContextMenu(x, y) {
        const menu = document.getElementById('context-menu');

        // å…ˆæ˜¾ç¤ºå‡ºæ¥ï¼Œæ‰èƒ½è·å–åˆ°å®ƒçš„å®½åº¦å’Œé«˜åº¦
        menu.style.display = 'block';

        // è·å–èœå•å°ºå¯¸å’Œçª—å£å°ºå¯¸
        const rect = menu.getBoundingClientRect();
        const winWidth = window.innerWidth;
        const winHeight = window.innerHeight;

        // 1. é˜²æ­¢è¶…å‡ºå³è¾¹ç•Œï¼šå¦‚æœ é¼ æ ‡X + èœå•å®½ > å±å¹•å®½ï¼Œåˆ™èœå•æ˜¾ç¤ºåœ¨é¼ æ ‡å·¦ä¾§
        if (x + rect.width > winWidth) {
            x -= rect.width;
        }

        // 2. é˜²æ­¢è¶…å‡ºä¸‹è¾¹ç•Œï¼šå¦‚æœ é¼ æ ‡Y + èœå•é«˜ > å±å¹•é«˜ï¼Œåˆ™èœå•æ˜¾ç¤ºåœ¨é¼ æ ‡ä¸Šæ–¹
        if (y + rect.height > winHeight) {
            y -= rect.height;
        }

        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
    }

    function updateGridBackground() {
        // æ›´æ–° CSS grid èƒŒæ™¯å¤§å°ä»¥åŒ¹é… 1ç§’çš„åƒç´ æ•°
        DOM.grid.style.backgroundSize = `${STATE.pxPerSec}px 100%`;
    }

    // ğŸ”¥ æ–°å¢è¾…åŠ©å‡½æ•°ï¼šç›´æ¥ä»äºŒè¿›åˆ¶æ•°æ®ä¸­æ‰«æè½¨é“åç§°
    function scanTrackNames(arrayBuffer) {
        const data = new Uint8Array(arrayBuffer);
        const names = [];
        let p = 0;

        // è¾…åŠ©ï¼šè¯»å–å˜é•¿æ•°å€¼ (Variable Length Quantity)
        function readVarInt() {
            let result = 0;
            while (p < data.length) {
                const b = data[p++];
                result = (result << 7) | (b & 0x7f);
                if ((b & 0x80) === 0) break;
            }
            return result;
        }

        // è¾…åŠ©ï¼šè¯»å–æŒ‡å®šé•¿åº¦å­—ç¬¦ä¸²
        function readString(len) {
            let s = "";
            for (let i = 0; i < len; i++) {
                if (p < data.length) {
                    // è¿‡æ»¤ä¸å¯è§å­—ç¬¦ï¼Œåªä¿ç•™ ASCII æˆ– UTF-8
                    const code = data[p++];
                    if (code > 0) s += String.fromCharCode(code);
                }
            }
            return decodeURIComponent(escape(s)); // å°è¯•è§£å†³ç®€å•çš„ç¼–ç é—®é¢˜
        }

        // 1. è·³è¿‡ Header Chunk (MThd)
        if (data.length > 14 &&
            data[0] === 0x4D && data[1] === 0x54 && data[2] === 0x68 && data[3] === 0x64) {
            p = 14;
        }

        // 2. éå† Track Chunks (MTrk)
        while (p < data.length - 8) {
            // å¯»æ‰¾ 'MTrk' æ ‡å¿—
            if (data[p] === 0x4D && data[p+1] === 0x54 && data[p+2] === 0x72 && data[p+3] === 0x6B) {
                p += 4; // è·³è¿‡æ ‡å¿—
                const trackLen = (data[p] << 24) | (data[p+1] << 16) | (data[p+2] << 8) | data[p+3];
                p += 4; // è·³è¿‡é•¿åº¦å­—æ®µ

                const chunkEnd = p + trackLen;
                let foundName = null;

                // æ‰«æè¯¥è½¨é“çš„å‰ 500 ä¸ªå­—èŠ‚ï¼ˆé€šå¸¸åå­—åœ¨æœ€å‰é¢ï¼‰
                // æ³¨æ„ï¼šè¿™æ˜¯ç®€åŒ–ç‰ˆæ‰«æï¼Œå‡è®¾ DeltaTime ä¸º 0 æˆ–å¾ˆçŸ­
                let scanLimit = p + 1000;
                if (scanLimit > chunkEnd) scanLimit = chunkEnd;

                let tempP = p;

                // ç®€å•çš„è¯•æ¢æ€§æ‰«æï¼šå¯»æ‰¾ FF 03 (Track Name)
                // åœ¨æ ‡å‡†çš„ MIDI æµä¸­ï¼Œæ ¼å¼é€šå¸¸æ˜¯ï¼š[DeltaTime] FF 03 [Len] [Text]
                // å¤§å¤šæ•° DAW å¯¼å‡ºçš„è½¨é“åéƒ½åœ¨ Tick 0ï¼ŒDeltaTime = 00
                while (tempP < scanLimit - 3) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ 00 FF 03 (DeltaTime=0, Meta=FF, Type=03)
                    // æˆ–è€…å¯èƒ½æ˜¯å˜é•¿ DeltaTimeï¼Œè¿™é‡Œä¸»è¦é€šè¿‡ç‰¹å¾ç  FF 03 æš´åŠ›åŒ¹é…
                    if (data[tempP] === 0xFF && data[tempP+1] === 0x03) {
                        const len = data[tempP+2];
                        // ç®€å•çš„å®Œæ•´æ€§æ£€æŸ¥ï¼šé•¿åº¦ä¸è¦å¤ªç¦»è°±
                        if (len > 0 && len < 100) {
                            let extracted = "";
                            for(let k=0; k<len; k++) extracted += String.fromCharCode(data[tempP+3+k]);
                            // ç§»é™¤ç©ºå­—ç¬¦å’Œä¹±ç 
                            foundName = extracted.replace(/\u0000/g, '').trim();
                            break;
                        }
                    }
                    tempP++;
                }
                names.push(foundName); // å³ä½¿æ˜¯ null ä¹Ÿè¦å ä½ï¼Œä¿æŒç´¢å¼•å¯¹é½

                p = chunkEnd; // è·³åˆ°ä¸‹ä¸€è½¨é“
            } else {
                p++; // æ²¡æ‰¾åˆ° MTrkï¼Œé€å­—èŠ‚åç§»ï¼ˆå®¹é”™ï¼‰
            }
        }
        return names;
    }

    function processMidiFile(file) {
        if (!file) return;

        DOM.loading.style.display = 'flex';
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                const arrayBuffer = ev.target.result;
                const midiData = new Midi(arrayBuffer);

                // 1. è¯»å– BPM å’Œ æ‹å·
                if (midiData.header) {
                    if (midiData.header.tempos && midiData.header.tempos.length > 0) {
                        STATE.bpm = Math.round(midiData.header.tempos[0].bpm);
                    }
                    if (midiData.header.timeSignatures && midiData.header.timeSignatures.length > 0) {
                        const tsObj = midiData.header.timeSignatures[0];
                        if (tsObj.timeSignature && tsObj.timeSignature.length >= 1) {
                            STATE.timeSignature = tsObj.timeSignature[0];
                        }
                    }
                    console.log(`å·²æ›´æ–°å·¥ç¨‹è®¾ç½®: BPM=${STATE.bpm}, æ‹å·=${STATE.timeSignature}/4`);
                }

                // ==========================================
                // ğŸ”¥ğŸ”¥ æ–°å¢ï¼šè‡ªåŠ¨ç§»é™¤ MIDI å¼€å¤´ç©ºç™½ ğŸ”¥ğŸ”¥
                // ==========================================
                let globalStartTime = Infinity;

                // 1. ç¬¬ä¸€æ¬¡éå†ï¼šæ‰¾åˆ°å…¨æ›²æœ€æ—©çš„éŸ³ç¬¦æ—¶é—´
                midiData.tracks.forEach(track => {
                    track.notes.forEach(note => {
                        if (note.time < globalStartTime) globalStartTime = note.time;
                    });
                });

                // 2. å¦‚æœå¼€å¤´æœ‰æ˜æ˜¾çš„ç©ºç™½ (ä¾‹å¦‚ > 0.05ç§’)ï¼Œåˆ™æ‰§è¡Œä¿®å‰ª
                if (globalStartTime > 0.05 && globalStartTime !== Infinity) {
                    console.log(`æ£€æµ‹åˆ° MIDI å¼€å¤´ç©ºç™½: ${globalStartTime.toFixed(3)}ç§’ï¼Œæ­£åœ¨è‡ªåŠ¨ç§»é™¤...`);

                    const offset = globalStartTime;

                    // 3. ç¬¬äºŒæ¬¡éå†ï¼šå°†æ‰€æœ‰äº‹ä»¶å‘å‰å¹³ç§»
                    midiData.tracks.forEach(track => {
                        // A. ç§»åŠ¨éŸ³ç¬¦
                        track.notes.forEach(note => {
                            note.time = Math.max(0, note.time - offset);
                        });

                        // B. ç§»åŠ¨æ§åˆ¶ä¿¡æ¯ (å¦‚å»¶éŸ³è¸æ¿ CC64)
                        if (track.controlChanges) {
                            Object.keys(track.controlChanges).forEach(ccKey => {
                                track.controlChanges[ccKey].forEach(ccEvent => {
                                    ccEvent.time = Math.max(0, ccEvent.time - offset);
                                });
                            });
                        }
                    });

                    // âŒ åˆ é™¤è¿™ä¸€è¡Œï¼šmidiData.duration æ˜¯è‡ªåŠ¨è®¡ç®—çš„åªè¯»å±æ€§ï¼Œæ— éœ€æ‰‹åŠ¨ä¿®æ”¹
                    // midiData.duration = Math.max(0, midiData.duration - offset);
                }
                // ==========================================
                // ğŸ”¥ğŸ”¥ ç»“æŸè‡ªåŠ¨ç§»é™¤é€»è¾‘ ğŸ”¥ğŸ”¥
                // ==========================================


                // è·å–æ‰€æœ‰åŸå§‹è½¨é“åç§°
                const rawTrackNames = scanTrackNames(arrayBuffer);
                const trackIndexOffset = Math.max(0, rawTrackNames.length - midiData.tracks.length);

                let targetTrack = STATE.tracks.find(t => t.type === 'midi' && t.clips.length === 0);
                let nameQueue = [];
                const newTrackIds = [];

                if (nameQueue.length === 0 && rawTrackNames) {
                    for (let k = trackIndexOffset; k < rawTrackNames.length; k++) {
                        let n = rawTrackNames[k];
                        if (n) {
                            n = n.replace(/\u0000/g, '').trim();
                            // åªæœ‰å½“åå­—ä¸ä¸ºç©ºæ—¶æ‰åŠ å…¥é˜Ÿåˆ—ï¼Œè·³è¿‡ç©ºå ä½ç¬¦
                            if (n.length > 0) {
                                nameQueue.push(n);
                            }
                        }
                    }
                }

                for (let i = 0; i < midiData.tracks.length; i++) {
                    const t = midiData.tracks[i];

                    // (åŸæœ‰çš„é€ä¸ª push é€»è¾‘å·²ç§»é™¤ï¼Œæ”¹ä¸ºä¸Šæ–¹çš„ä¸€æ¬¡æ€§é¢„å¡«å……ï¼Œä»¥é˜²æ­¢ç©ºåå­—å ä½)

                    const hasNotes = t.notes.length > 0;

                    if (hasNotes) {
                        let finalName = "";

                        if (nameQueue.length > 0) {
                            finalName = nameQueue.shift(); // ç›´æ¥å–ç¬¬ä¸€ä¸ªæœ‰æ•ˆåå­—
                        } else {
                            finalName = `Track ${STATE.nextTrackId}`;
                        }

                        if (!finalName && t.instrument && t.instrument.name) {
                            finalName = t.instrument.name;
                        }

                        if (!targetTrack) {
                            targetTrack = new Track(`MIDI ${STATE.nextTrackId}`, 'midi');
                            STATE.tracks.push(targetTrack);
                        }

                        newTrackIds.push(targetTrack.id);
                        targetTrack.setName(finalName);

                        targetTrack.addClip(0, midiData.duration, t, finalName, t);
                        targetTrack = null;
                    }
                }

                updateTrackZRanks();

                autoFitZoom(midiData.duration);
                updateTotalDuration();
                STATE.clips.forEach(c => c.updateDOMPosition());
                reorderTracks();

                if (newTrackIds.length > 0) {
                    HistoryMgr.add({
                        type: 'import_tracks',
                        trackIds: newTrackIds
                    });
                }

            } catch (err) {
                console.error(err);
                alert("MIDI è§£æå¤±è´¥: " + file.name);
            }

            requestAnimationFrame(() => {
                window.dispatchEvent(new Event('resize'));
                if(typeof updateGridBackground === 'function') updateGridBackground();
            });

            DOM.loading.style.display = 'none';
        };
        reader.readAsArrayBuffer(file);
    }

    // ğŸ”¥ è¾…åŠ©å‡½æ•°ï¼šå°†è½¨é“å¯¹è±¡è½¬æ¢ä¸º JSON æ•°æ® (ç”¨äº Undo/Redo ä¿å­˜)
    function serializeTrack(track) {
        return {
            id: track.id,
            name: track.name,
            type: track.type,
            ownColor: track.ownColor,
            groupId: track.groupId,
            isMuted: track.isMuted,
            isSoloed: track.isSoloed,
            clips: track.clips.map(c => ({
                start: c.startTime,
                duration: c.duration,
                name: c.name,
                // ğŸ”¥ ä¿®å¤ï¼šè¿™é‡Œå¿…é¡»ä¿å­˜ sourceDataï¼Œå¦åˆ™æ¢å¤æ—¶éŸ³ç¬¦ä¸¢å¤±
                sourceData: c.sourceFile
            }))
        };
    }

    function reorderTracks() {
        // 1. æ’åºæ•°æ®æ•°ç»„ (Audio ä¼˜å…ˆï¼Œå…¶ä»–æŒ‰ ID)
        STATE.tracks.sort((a, b) => {
            // å¦‚æœç±»å‹ä¸åŒï¼ŒAudio æ’å‰é¢ (-1)
            if (a.type === 'audio' && b.type !== 'audio') return -1;
            if (a.type !== 'audio' && b.type === 'audio') return 1;

            // å¦‚æœç±»å‹ç›¸åŒï¼ŒæŒ‰åˆ›å»º ID æ’åº (ä¿æŒå…ˆåé¡ºåº)
            return a.id - b.id;
        });

        // 2. æŒ‰ç…§æ–°é¡ºåºé‡æ–°æ’åˆ— DOM
        // (appendChild å¦‚æœå…ƒç´ å·²å­˜åœ¨ï¼Œä¼šå°†å…¶ç§»åŠ¨åˆ°æœ«å°¾ï¼Œä»è€Œå®ç°é‡æ’)
        STATE.tracks.forEach(track => {
            // ç§»åŠ¨å·¦ä¾§ Header
            if (track.headerEl) {
                DOM.headers.appendChild(track.headerEl);
            }
            // ç§»åŠ¨å³ä¾§ Lane
            if (track.laneEl) {
                // æ³¨æ„ï¼šDOM.lanes é‡Œå¯èƒ½æœ‰ gridLines å’Œ playhead ç­‰ç»å¯¹å®šä½å…ƒç´ 
                // ä½† track-lane æ˜¯æµå¼å¸ƒå±€çš„ blockï¼Œè¿½åŠ åˆ°æœ€åå³å¯ä¿æŒå‚ç›´å †å é¡ºåº
                DOM.lanes.appendChild(track.laneEl);
            }
        });

        console.log("è½¨é“å·²é‡æ–°æ’åºï¼šAudio ç½®é¡¶");
    }

    // ğŸ”¥ æ–°å¢ï¼šä¸“é—¨ç”¨äºè®¡ç®— Zè½´æ’åçš„å‡½æ•° (åªåœ¨éœ€è¦æ—¶è°ƒç”¨ï¼Œä¸æ”¾åœ¨æ¸²æŸ“å¾ªç¯é‡Œ)
    function updateTrackZRanks() {
        const allMidiTracks = STATE.tracks.filter(t => t.type === 'midi');

        // è®¡ç®—æ¯ä¸ªè½¨é“çš„â€œç¬¬ä¸€é¢—éŸ³ç¬¦æ—¶é—´â€
        const trackOrderMap = allMidiTracks.map(t => {
            let realFirstNoteTime = Infinity;

            if (t.clips.length > 0) {
                t.clips.forEach(c => {
                    if (c.data && c.data.notes && c.data.notes.length > 0) {
                        let minRelTime = Infinity;
                        for (let n of c.data.notes) {
                            if (n.time < minRelTime) minRelTime = n.time;
                        }
                        const absTime = c.startTime + minRelTime;
                        if (absTime < realFirstNoteTime) {
                            realFirstNoteTime = absTime;
                        }
                    }
                });
            }
            if (realFirstNoteTime === Infinity) realFirstNoteTime = 999999;
            return { id: t.id, time: realFirstNoteTime };
        });

        // æ’åº
        trackOrderMap.sort((a, b) => {
            if (Math.abs(a.time - b.time) < 0.01) {
                return b.id - a.id;
            }
            return a.time - b.time;
        });

        // ğŸ”¥ å°†æ’åç›´æ¥å†™å…¥ Track å¯¹è±¡ç¼“å­˜èµ·æ¥
        trackOrderMap.forEach((item, index) => {
            const track = STATE.tracks.find(t => t.id === item.id);
            if(track) track.zRank = index;
        });

        console.log("Z-Index æ’åå·²æ›´æ–° (Cached)");
    }

    // ğŸ”¥ æ–°å¢å·¥å…·ï¼šè‡ªåŠ¨å‰ªåˆ‡éŸ³é¢‘å¼€å¤´çš„é™éŸ³
    function trimSilence(audioCtx, buffer, threshold = 0.01) {
        const rawData = buffer.getChannelData(0); // é€šå¸¸æ£€æµ‹å·¦å£°é“å³å¯
        const len = rawData.length;
        let startSample = 0;

        // 1. å¯»æ‰¾ç¬¬ä¸€ä¸ªè¶…è¿‡é˜ˆå€¼çš„ç‚¹
        for (let i = 0; i < len; i++) {
            if (Math.abs(rawData[i]) > threshold) {
                startSample = i;
                break;
            }
        }

        // å¦‚æœå¼€å¤´é™éŸ³å°‘äº 0.05ç§’ï¼Œå°±ä¸å¤„ç†äº†ï¼Œé¿å…ä¸å¿…è¦çš„è®¡ç®—
        // buffer.sampleRate é€šå¸¸æ˜¯ 44100 æˆ– 48000
        const safetyPadding = Math.floor(0.05 * buffer.sampleRate);

        // å›é€€ä¸€ç‚¹ç‚¹ï¼Œä¿ç•™ 0.05ç§’ çš„å‘¼å¸ç©ºé—´ï¼Œé˜²æ­¢èµ·éŸ³è¢«åˆ‡å
        startSample = Math.max(0, startSample - safetyPadding);

        if (startSample === 0) {
            console.log("éŸ³é¢‘å¼€å¤´æ²¡æœ‰æ˜æ˜¾çš„é™éŸ³ï¼Œæ— éœ€å‰ªåˆ‡ã€‚");
            return buffer;
        }

        console.log(`æ£€æµ‹åˆ°é™éŸ³ï¼Œå‰ªåˆ‡å‰ ${ (startSample / buffer.sampleRate).toFixed(3) } ç§’`);

        // 2. åˆ›å»ºæ–°çš„ Buffer
        const newLength = len - startSample;
        const newBuffer = audioCtx.createBuffer(
            buffer.numberOfChannels,
            newLength,
            buffer.sampleRate
        );

        // 3. å¤åˆ¶æ•°æ® (æ‰€æœ‰å£°é“éƒ½è¦åˆ‡)
        for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
            const oldChannelData = buffer.getChannelData(channel);
            const newChannelData = newBuffer.getChannelData(channel);

            // ä½¿ç”¨é«˜æ€§èƒ½çš„ subarray è¿›è¡Œå†…å­˜å¤åˆ¶
            // ä¹Ÿå°±æ˜¯æŠŠ oldData ä» startSample å¼€å§‹åˆ°æœ€åçš„æ•°æ®ï¼Œå¤åˆ¶åˆ° newData ä¸­
            newChannelData.set(oldChannelData.subarray(startSample));
        }

        return newBuffer;
    }

    async function processAudioFile(file) {
        if (!file) return;

        DOM.loading.style.display = 'flex';
        try {
            const existingTrack = STATE.tracks.find(t => t.type === 'audio');
            // å¦‚æœå­˜åœ¨æ—§è½¨é“ï¼Œä¿å­˜å®ƒçš„æ•°æ®ï¼›å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™ä¸º null
            const oldTrackData = existingTrack ? serializeTrack(existingTrack) : null;
            // ğŸ”¥ğŸ”¥ğŸ”¥ ä¿®å¤å¼€å§‹ï¼šå¤ç”¨å…¨å±€ AudioContext ğŸ”¥ğŸ”¥ğŸ”¥
            if (!sharedAudioCtx) {
                sharedAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            // ç¡®ä¿ Context æ˜¯è¿è¡ŒçŠ¶æ€ (æµè§ˆå™¨æœ‰æ—¶ä¼šä¸ºäº†çœç”µæš‚åœå®ƒ)
            if (sharedAudioCtx.state === 'suspended') {
                await sharedAudioCtx.resume();
            }
            const audioCtx = sharedAudioCtx;
            // ğŸ”¥ğŸ”¥ğŸ”¥ ä¿®å¤ç»“æŸ ğŸ”¥ğŸ”¥ğŸ”¥

            const arrayBuffer = await file.arrayBuffer();
            // 1. åŸå§‹è§£ç 
            let buffer = await audioCtx.decodeAudioData(arrayBuffer);

            // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šåœ¨è¿™é‡Œè°ƒç”¨è‡ªåŠ¨å‰ªåˆ‡ ğŸ”¥ğŸ”¥ğŸ”¥
            // é˜ˆå€¼ 0.01 ç›¸å½“äº -40dB å·¦å³ï¼Œæ—¢èƒ½åˆ‡æ‰åº•å™ªï¼Œåˆä¸ä¼šåˆ‡æ‰æå¼±çš„å¼€åœºéŸ³
            buffer = trimSilence(audioCtx, buffer, 0.01);

            // é‡æ–°è¯»å– Base64 ç”¨äºä¿å­˜ (è¿™ä¸ªä»…ä»…ç”¨äºå­˜æ¡£ï¼Œè§†è§‰å’Œæ’­æ”¾ä½¿ç”¨çš„æ˜¯ä¸Šé¢çš„ buffer)
            const base64Str = await new Promise((resolve) => {
                const r = new FileReader();
                r.onload = e => resolve(e.target.result);
                r.readAsDataURL(file);
            });

            // ==========================================
            // ğŸ”¥ æ ¸å¿ƒé€»è¾‘ï¼šæŸ¥æ‰¾æˆ–æ–°å»º
            // ==========================================

            let targetTrack = STATE.tracks.find(t => t.type === 'audio');

            if (targetTrack) {
                console.log("å¤ç”¨ç°æœ‰ Audio è½¨é“:", targetTrack.name);
                targetTrack.clearClips();
            } else {
                targetTrack = new Track("Audio", 'audio');
                STATE.tracks.push(targetTrack);
            }

            // ==========================================

            // 2. æ·»åŠ æ–° Clip (ä½¿ç”¨å‰ªåˆ‡åçš„ buffer)
            const clip = targetTrack.addClip(0, buffer.duration, buffer, file.name, base64Str);

            const url = URL.createObjectURL(file);
            DOM.audio.src = url;

            DOM.audio.playbackRate = 1.0;
            DOM.audio.preservesPitch = true;

            // ğŸ”¥ å…³é”®ä¿®æ­£ï¼šå› ä¸ºæˆ‘ä»¬åˆ‡æ‰äº†å¼€å¤´çš„é™éŸ³ï¼ŒHTML5 Audio æ’­æ”¾æ—¶éœ€è¦è·³è¿‡é‚£æ®µé™éŸ³
            // æˆ‘ä»¬è®¡ç®—ä¸€ä¸‹åˆ‡æ‰äº†å¤šå°‘ç§’
            const originalCtx = new (window.AudioContext || window.webkitAudioContext)();
            const originalBuffer = await originalCtx.decodeAudioData(await file.slice(0).arrayBuffer());
            const trimmedTime = originalBuffer.duration - buffer.duration;

            // è®°å½•è¿™ä¸ªåç§»é‡ï¼Œä»¥åæ’­æ”¾æ—¶å¯èƒ½ç”¨åˆ° (æš‚æ—¶åªéœ€å­˜ç€)
            clip.trimOffset = trimmedTime;

            // 4. æ›´æ–°å…¨å±€å¼•ç”¨
            STATE.activeAudioClip = clip;

            // 5. è§†å›¾è°ƒæ•´
            autoFitZoom(buffer.duration);
            updateTotalDuration();
            STATE.clips.forEach(c => c.updateDOMPosition());

            // 6. è‡ªåŠ¨å¯¹é½
            autoAlignAudioToMidi(true);

            // 7. é‡æ–°æ’åº
            if (typeof reorderTracks === 'function') reorderTracks();

            const newTrackData = serializeTrack(targetTrack);

            HistoryMgr.add({
                type: 'import_audio',
                oldData: oldTrackData, // å¦‚æœä¹‹å‰æ²¡è½¨é“ï¼Œè¿™é‡Œæ˜¯ null (æ’¤é”€=åˆ é™¤)
                newData: newTrackData  // (é‡åš=æ¢å¤è¿™ä¸ªæ–°è½¨é“)
            });

            requestAnimationFrame(() => {
                window.dispatchEvent(new Event('resize'));
                if(typeof updateGridBackground === 'function') updateGridBackground();
            });

        } catch (err) {
            console.error(err);
            alert("éŸ³é¢‘å¯¼å…¥å¤±è´¥: " + file.name);
        }
        DOM.loading.style.display = 'none';
    }

    function autoAlignAudioToMidi(isAuto = false) {
        // 1. å¯»æ‰¾ç›®æ ‡ Audio Track (æˆ‘ä»¬è¦ç§»åŠ¨çš„é‚£ä¸ª)
        // ç›®å‰é€»è¾‘æ˜¯ç§»åŠ¨ç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„ Audio è½¨é“
        const audioTrack = STATE.tracks.find(t => t.type === 'audio' && t.clips.length > 0);

        // 2. æ‰«ææ‰€æœ‰ MIDI è½¨é“ï¼Œå¯»æ‰¾å…¨å±€æœ€æ—©çš„éŸ³ç¬¦æ—¶é—´
        let earliestMidiTime = Infinity;
        let hasMidi = false;

        STATE.tracks.forEach(track => {
            if (track.type === 'midi') {
                track.clips.forEach(clip => {
                    // ç¡®ä¿æœ‰éŸ³ç¬¦æ•°æ®
                    if (clip.data && clip.data.notes && clip.data.notes.length > 0) {
                        hasMidi = true;

                        // éå†è¯¥ Clip å†…çš„æ‰€æœ‰éŸ³ç¬¦
                        clip.data.notes.forEach(note => {
                            // ğŸ”¥ å…³é”®ï¼šè®¡ç®—ç»å¯¹æ—¶é—´
                            // Note.time æ˜¯ç›¸å¯¹äº Clip å¼€å§‹çš„ï¼Œæ‰€ä»¥è¦åŠ ä¸Š Clip.startTime
                            const absTime = clip.startTime + note.time;

                            if (absTime < earliestMidiTime) {
                                earliestMidiTime = absTime;
                            }
                        });
                    }
                });
            }
        });

        // 3. æ ¡éªŒæ¡ä»¶
        if (!hasMidi || !audioTrack) {
            // åªæœ‰æ‰‹åŠ¨ç‚¹å‡»æŒ‰é’®æ—¶æ‰å¼¹çª—è­¦å‘Š
            if (!isAuto) {
                alert("æ— æ³•å¯¹é½ï¼šéœ€è¦è‡³å°‘ä¸€ä¸ª MIDI è½¨é“ï¼ˆå«éŸ³ç¬¦ï¼‰å’Œä¸€ä¸ª Audio è½¨é“ï¼");
            }
            return;
        }

        console.log(`å…¨å±€æœ€æ—© MIDI éŸ³ç¬¦æ—¶é—´: ${earliestMidiTime.toFixed(3)}s`);

        const audioClip = audioTrack.clips[0];

        // 4. åˆ†æ Audio çš„ç¬¬ä¸€ä¸ªå‘å£°ç‚¹ (é™éŸ³æ£€æµ‹)
        const audioBuffer = audioClip.data;
        const rawData = audioBuffer.getChannelData(0); // å–å·¦å£°é“
        const sampleRate = audioBuffer.sampleRate;

        let firstSampleIndex = 0;
        const threshold = 0.015; // é™éŸ³é˜ˆå€¼

        for (let i = 0; i < rawData.length; i++) {
            if (Math.abs(rawData[i]) > threshold) {
                firstSampleIndex = i;
                break;
            }
        }

        // éŸ³é¢‘å†…éƒ¨çš„é™éŸ³æ—¶é•¿ï¼ˆç©ºç™½å¤´ï¼‰
        const audioSilenceDuration = firstSampleIndex / sampleRate;

        // 5. è®¡ç®—æ–°ä½ç½®
        // å…¬å¼ï¼šAudioæ–°èµ·ç‚¹ = MIDIæœ€æ—©æ—¶é—´ - Audioç©ºç™½å¤´æ—¶é•¿
        let newStartTime = earliestMidiTime - audioSilenceDuration;

        console.log(`Audio ç©ºç™½å¤´: ${audioSilenceDuration.toFixed(3)}s`);
        console.log(`Audio ç§»åŠ¨: ${audioClip.startTime.toFixed(3)}s -> ${newStartTime.toFixed(3)}s`);

        // 6. è®°å½•å†å² (Undo)
        if (Math.abs(audioClip.startTime - newStartTime) > 0.001) {
            HistoryMgr.add({
                type: 'move_clip',
                clip: audioClip,
                oldStart: audioClip.startTime,
                newStart: newStartTime
            });

            // 7. åº”ç”¨ä½ç½®
            audioClip.startTime = newStartTime;
            audioClip.updateDOMPosition();
            audioClip.update3DPosition();
            updateTotalDuration();

            // è·³è½¬è¿‡å»æŸ¥çœ‹
            seekTo(Math.max(0, newStartTime));
        } else {
            if(!isAuto) console.log("æ— éœ€å¯¹é½ï¼Œä½ç½®æœªå˜");
        }
    }

    function updateTotalDuration() {
        // 1. åˆå§‹åŒ–ä¸º 0 (æˆ–è€…ç»™ä¸€ä¸ªå¾ˆå°çš„é»˜è®¤å€¼ï¼Œæ¯”å¦‚ 4å°èŠ‚/8ç§’ï¼Œä»¥é˜²ç©ºå·¥ç¨‹å¤ªéš¾çœ‹)
        let maxTime = 0;

        // 2. éå†æ‰€æœ‰ Clip æ‰¾åˆ°æœ€æ™šç»“æŸçš„æ—¶é—´ç‚¹
        if (STATE.clips.length > 0) {
            STATE.clips.forEach(c => {
                const end = c.startTime + c.duration;
                if (end > maxTime) maxTime = end;
            });

            // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šåªåœ¨æœ«å°¾å¢åŠ å°‘é‡ç¼“å†² (ä¾‹å¦‚ 1 ä¸ªå°èŠ‚çš„æ—¶é—´ï¼Œæˆ–å›ºå®š 2 ç§’)
            // è¿™æ ·æ—¢ä¸ä¼šé¡¶æ ¼å¤ªéš¾å—ï¼Œä¹Ÿä¸ä¼šç•™å‡ºå¤§ç‰‡ç©ºç™½
            const bufferSeconds = (60 / STATE.bpm) * 4; // è‡ªåŠ¨ç•™ 1 ä¸ªå°èŠ‚çš„ç¼“å†²
            maxTime += bufferSeconds;
        } else {
            // å¦‚æœæ²¡æœ‰ä»»ä½• Clipï¼Œä¿æŒä¸€ä¸ªé»˜è®¤é•¿åº¦ (ä¾‹å¦‚ 10ç§’)
            maxTime = 60;
        }

        STATE.totalDuration = maxTime;

        // 3. æ ¹æ®å†…å®¹æ›´æ–°å®¹å™¨å®½åº¦
        const contentWidth = (maxTime * STATE.pxPerSec) + 20; // +100px é˜²æ­¢å³ä¾§æº¢å‡º

        // è¿™æ˜¯ä¸€ä¸ªå®‰å…¨æ£€æŸ¥ï¼Œé˜²æ­¢å®½åº¦è¿‡å°å¯¼è‡´å¸ƒå±€å´©å
        const minWidth = DOM.timelineLanes.clientWidth;
        const finalWidth = Math.max(minWidth, contentWidth);

        DOM.lanes.style.minWidth = finalWidth + 'px';
        DOM.lanes.style.width = finalWidth + 'px';
        DOM.grid.style.width = finalWidth + 'px';

        // æ ‡å°ºå®½åº¦ç•¥å®½ä¸€ç‚¹
        const rulerCompensatedWidth = finalWidth + 10;
        DOM.barRuler.style.width = rulerCompensatedWidth + 'px';
        DOM.timeRuler.style.width = rulerCompensatedWidth + 'px';

        renderRulers();
    }

    // --- æ’­æ”¾æ§åˆ¶ ---
    function togglePlay() {
        if (STATE.isPlaying) {
            // === æš‚åœçŠ¶æ€ ===
            STATE.isPlaying = false;

            // 1. æ¢å¤é˜»å°¼ï¼Œè®©é¼ æ ‡æ‹–æ‹½æ‰‹æ„Ÿæ›´å¥½
            if (controls) controls.enableDamping = true;

            if (STATE.isRecording) toggleRecord();

            DOM.audio.pause();
            if (bgVideoElement) bgVideoElement.pause();
            DOM.playBtn.innerText = "PLAY (Space)";
            DOM.playBtn.classList.remove('btn-primary');
        } else {
            // === æ’­æ”¾çŠ¶æ€ ===
            STATE.isPlaying = true;
            STATE.lastFrameTime = performance.now();
            DOM.playBtn.innerText = "PAUSE (Space)";
            DOM.playBtn.classList.add('btn-primary');

            // 2. ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘æ’­æ”¾æ—¶å¼ºåˆ¶å…³é—­é˜»å°¼ï¼Œæ¶ˆé™¤æŠ–åŠ¨
            if (controls) {
                controls.enableDamping = false;
                controls.update(); // ç«‹å³åˆ·æ–°ä¸€æ¬¡çŠ¶æ€
            }

            syncAudio();
            if (bgVideoElement) {
                bgVideoElement.play().catch(e => console.log("Bg video play blocked"));
            }
        }
    }

    function stopPlay() {
        STATE.isPlaying = false;
        DOM.audio.pause();
        if (bgVideoElement) bgVideoElement.pause();
        DOM.playBtn.innerText = "PLAY (Space)";
        DOM.playBtn.classList.remove('btn-primary');
        seekTo(0);
    }



    function seekTo(time) {
        if (!camera || !controls) return;
        STATE.currentTime = Math.max(0, Math.min(time, STATE.totalDuration));
        updatePlayhead();

        // 3D ç›¸æœºç¬ç§»
        const targetX = STATE.currentTime * STATE.playbackSpeed;
        const delta = targetX - cameraTargetX;
        camera.position.x += delta;    // ç›¸æœºç§»åŠ¨ delta
        controls.target.x += delta;
        cameraTargetX = targetX;

        if (bgVideoElement && bgVideoElement.duration > 0) {
            // ä½¿ç”¨å–ä½™è¿ç®—å®ç°è§†é¢‘æ¯”éŸ³é¢‘çŸ­æ—¶çš„è‡ªåŠ¨å¾ªç¯
            bgVideoElement.currentTime = STATE.currentTime % bgVideoElement.duration;
        }

        // å¦‚æœæ­£åœ¨æ’­æ”¾ï¼ŒåŒæ­¥éŸ³é¢‘
        if (STATE.isPlaying) {
            syncAudio();
            // å¦‚æœè§†é¢‘å› ä¸ºæŸäº›åŸå› æš‚åœäº†ï¼Œç¡®ä¿å®ƒç»§ç»­æ’­æ”¾
            if (bgVideoElement && bgVideoElement.paused) {
                bgVideoElement.play().catch(() => {});
            }
        }
    }

    // æ ¸å¿ƒéŸ³é¢‘åŒæ­¥é€»è¾‘
    function syncAudio() {
        if (!STATE.activeAudioClip) return;
        const clip = STATE.activeAudioClip;
        const visualRelativeTime = STATE.currentTime - clip.startTime;
        const realAudioTime = visualRelativeTime + (clip.trimOffset || 0);
        if (visualRelativeTime >= 0 && visualRelativeTime < clip.duration) {
            if (DOM.audio.paused || Math.abs(DOM.audio.currentTime - realAudioTime) > 0.3) {
                DOM.audio.currentTime = realAudioTime;
                DOM.audio.play().catch(e => console.log("Auto-play blocked"));
            }
        } else {
            if (!DOM.audio.paused) DOM.audio.pause();
        }
    }

    function updatePlayhead() {
        // UI æ›´æ–°
        const px = STATE.currentTime * STATE.pxPerSec;

        // 1. ç§»åŠ¨ä¸‹æ–¹è½¨é“çš„æŒ‡é’ˆ (åŸæœ‰)
        DOM.playhead.style.left = px + 'px';

        // 2. ğŸ”¥ æ–°å¢ï¼šç§»åŠ¨æ ‡å°ºä¸Šçš„æŒ‡é’ˆ
        if (DOM.rulerPlayhead) {
            DOM.rulerPlayhead.style.left = px + 'px';
        }

        // è‡ªåŠ¨æ»šåŠ¨ (åŸæœ‰é€»è¾‘ä¿æŒä¸å˜)
        const scrollCenter = DOM.timelineLanes.scrollLeft + (DOM.timelineLanes.clientWidth / 2);
        if (Math.abs(px - scrollCenter) > DOM.timelineLanes.clientWidth / 3) {
            DOM.timelineLanes.scrollLeft = px - 1000;
        }
    }

    function renderRulers() {
        const duration = STATE.totalDuration + (1000 / STATE.pxPerSec); // å¯¹åº”ä¸Šé¢çš„é¢„ç•™ç©ºé—´
        const pxPerSec = STATE.pxPerSec;
        const totalWidth = duration * pxPerSec;

        // è®¾ç½®å®¹å™¨å®½åº¦
        DOM.barRuler.style.width = totalWidth + 'px';
        DOM.timeRuler.style.width = totalWidth + 'px';

        // ==========================================
        // 1. æ™ºèƒ½ç»˜åˆ¶æ—¶é—´è½¨é“ (Time Ruler)
        // ==========================================
        DOM.timeRuler.innerHTML = '';

        // å®šä¹‰æœ€å°æ ‡ç­¾é—´è· (åƒç´ )
        const minTimeLabelDist = 60;

        // åŸºç¡€æ­¥é•¿ç­–ç•¥ (ç§’): 1, 2, 5, 10, 15, 30, 60
        const timeSteps = [1, 2, 5, 10, 15, 30, 60];
        let timeStep = 1;

        // æ‰¾åˆ°åˆé€‚çš„æ­¥é•¿
        for (let step of timeSteps) {
            if (step * pxPerSec >= minTimeLabelDist) {
                timeStep = step;
                break;
            }
        }

        for (let s = 0; s < duration; s += timeStep) {
            const div = document.createElement('div');
            div.className = 'ruler-mark';

            // å¦‚æœæ˜¯æ•´åˆ†é’Ÿï¼Œæˆ–è€…æ ¹æ®æ­¥é•¿åˆ¤æ–­æ˜¯"å¤§åˆ»åº¦"ï¼ŒåŠ ç²—æ˜¾ç¤º
            const isMajor = (s % 60 === 0);
            if (isMajor) div.className += ' major';

            div.style.left = (s * pxPerSec) + 'px';
            div.innerText = formatRulerTime(s);
            DOM.timeRuler.appendChild(div);
        }

        // ==========================================
        // 2. æ™ºèƒ½ç»˜åˆ¶å°èŠ‚è½¨é“ (Bar Ruler)
        // ==========================================
        DOM.barRuler.innerHTML = '';

        const bps = STATE.bpm / 60;
        const secPerBeat = 1 / bps;
        const secPerBar = secPerBeat * STATE.timeSignature;
        const totalBars = Math.ceil(duration / secPerBar);

        // è®¡ç®—å½“å‰ç¼©æ”¾ä¸‹ä¸€å°èŠ‚æœ‰å¤šå®½
        const pxPerBar = secPerBar * pxPerSec;
        const minBarLabelDist = 40; // å°èŠ‚å·æ¯”è¾ƒçŸ­ï¼Œé—´è·å¯ä»¥å°ä¸€ç‚¹

        // åŠ¨æ€è®¡ç®—æ­¥é•¿ (Step): 1 -> 2 -> 4 -> 8 -> 16 ... (2çš„å€æ•°ç¬¦åˆéŸ³ä¹é€»è¾‘)
        let barStep = 1;
        while (pxPerBar * barStep < minBarLabelDist) {
            barStep *= 2;
        }

        for (let b = 0; b < totalBars; b++) {
            const currentBarX = b * secPerBar * pxPerSec;

            // 1. ç»˜åˆ¶å°èŠ‚å· (åªæœ‰ç¬¦åˆæ­¥é•¿çš„æ‰ç»˜åˆ¶æ–‡å­—)
            if (b % barStep === 0) {
                const div = document.createElement('div');
                div.className = 'ruler-mark major';
                div.style.left = currentBarX + 'px';
                div.style.borderLeftColor = '#aaa';
                div.innerText = (b + 1).toString();
                DOM.barRuler.appendChild(div);
            } else if (pxPerBar * barStep > minBarLabelDist * 2) {
                // å¦‚æœç©ºé—´éå¸¸å……è£•ï¼Œä½†åˆæ²¡åˆ° barStepï¼Œå¯ä»¥ç”»ä¸ªæ·¡ä¸€ç‚¹çš„çº¿ä½†ä¸å†™å­— (å¯é€‰)
                // è¿™é‡Œä¸ºäº†ç®€æ´æš‚ä¸ç”»ä¸­é—´çš„ç»†çº¿ï¼Œé¿å…æ··ä¹±
            }

            // 2. ç»˜åˆ¶æ‹å­ç»†åˆ† (Beat Subdivisions)
            // åªæœ‰å½“"ä¸€å°èŠ‚"éå¸¸å®½ï¼ˆæ¯”å¦‚å¤§äº 150pxï¼‰æ—¶ï¼Œæ‰æ˜¾ç¤ºæ‹å­åˆ»åº¦
            if (pxPerBar >= 150) {
                for(let beat = 1; beat < STATE.timeSignature; beat++) {
                    const beatDiv = document.createElement('div');
                    beatDiv.className = 'ruler-mark';
                    // è®¡ç®—ä½ç½®
                    beatDiv.style.left = (currentBarX + (beat * secPerBeat * pxPerSec)) + 'px';
                    beatDiv.style.height = '5px'; // çŸ­çº¿
                    beatDiv.style.top = '15px';   // é ä¸‹
                    beatDiv.style.borderLeft = '1px solid #444';
                    DOM.barRuler.appendChild(beatDiv);
                }
            }
        }
    }

    // è¾…åŠ©æ ¼å¼åŒ–æ—¶é—´ 0:05
    function formatRulerTime(seconds) {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, '0')}`;
    }

    // --- å®æ—¶ HUD æ›´æ–°é€»è¾‘ (Spherical ç‰ˆ) ---
    const HUD = {
        zoom: document.getElementById('hud-radius'), // å¯¹åº” HTML é‡Œçš„ id
        theta: document.getElementById('hud-theta'),
        phi: document.getElementById('hud-phi'),
        panX: document.getElementById('hud-pan-x'),
        panY: document.getElementById('hud-pan-y'),
        frameCounter: 0
    };

    function updateRealtimeHUD() {
        HUD.frameCounter++;
        if (HUD.frameCounter % 30 !== 0) return;

        // ç›´æ¥å¤ç”¨ ViewMgr çš„è®¡ç®—é€»è¾‘ï¼Œç¡®ä¿æ•°æ® 100% ä¸€è‡´
        const s = ViewMgr.getCurrentSpherical();
        if (!s) return;

        // 1. è·ç¦»
        HUD.zoom.innerText = s.radius.toFixed(1);

        // 2. è§’åº¦ (å·²ç»æ˜¯ä¿®æ­£è¿‡çš„: å¹³è§†=0)
        HUD.theta.innerText = Math.round(s.theta) + "Â°";
        HUD.phi.innerText = Math.round(s.phi) + "Â°";

        // 3. å¹³ç§»
        HUD.panX.innerText = s.targetX.toFixed(1);
        HUD.panY.innerText = s.targetY.toFixed(1);
    }

    // ==========================================
    // 5. åŠ¨ç”»å¾ªç¯
    // ==========================================
    // ==========================================
    // 5. åŠ¨ç”»å¾ªç¯ (å·²ä¿®å¤å½•åˆ¶å¡é¡¿é—®é¢˜)
    // ==========================================
    function animate() {
        requestAnimationFrame(animate);

        const now = performance.now();
        // å¦‚æœæ˜¯ç¬¬ä¸€å¸§ï¼Œåˆå§‹åŒ– lastFrameTime
        if (!STATE.lastFrameTime) STATE.lastFrameTime = now;

        // 1. è®¡ç®—è¿™ä¸€å¸§è·ç¦»ä¸Šä¸€å¸§çš„æ—¶é—´å·® (ç§’)
        let delta = (now - STATE.lastFrameTime) / 1000;

        // 2. æ›´æ–°æ—¶é—´æˆ³ (ä¾›ä¸‹ä¸€å¸§ä½¿ç”¨)
        STATE.lastFrameTime = now;

        // 3. å®‰å…¨é’³åˆ¶ï¼šéå½•åˆ¶çŠ¶æ€ä¸‹ï¼Œå¦‚æœå¡é¡¿è¶…è¿‡0.5ç§’ï¼Œä¿®æ­£ä¸ºä¸€å¸§çš„æ—¶é—´ï¼Œé˜²æ­¢åˆ‡å±å›æ¥åç”»é¢ç¬ç§»
        if (!ExportMgr.isRecording && delta > 0.5) delta = 0.016;

        // --- æ˜Ÿç©ºæ—‹è½¬ (å§‹ç»ˆè½¬åŠ¨) ---
        if (starMesh){
            starMesh.rotation.y += 0.0002;
            starMesh.rotation.x += 0.000005;
            if (starMesh.material.uniforms && starMesh.material.uniforms.uCamX) {
                // è¿™é‡Œä¼ å…¥çš„æ˜¯ cameraTargetX (å³æ’­æ”¾å¤´çš„ç†è®ºä½ç½®)ï¼Œæ¯” camera.position.x æ›´ç¨³å®š
                starMesh.material.uniforms.uCamX.value = cameraTargetX;
            }
        }

        if (STATE.isPlaying) {
            STATE.currentTime += delta;

            // å¦‚æœæœ‰éŸ³é¢‘åœ¨æ’­æ”¾ï¼Œæˆ‘ä»¬åªæ£€æµ‹â€œäººä¸ºè·³è½¬â€
            if (!DOM.audio.paused && STATE.activeAudioClip) {
                const clip = STATE.activeAudioClip;
                // è·å–éŸ³é¢‘å½“å‰çš„çœŸå®æ—¶é—´
                const rawVisualTime = DOM.audio.currentTime - (clip.trimOffset || 0);
                const audioBasedTime = rawVisualTime + clip.startTime;

                // è®¡ç®—è§†è§‰æ—¶é—´ä¸éŸ³é¢‘æ—¶é—´çš„å·®è·
                const diff = Math.abs(STATE.currentTime - audioBasedTime);

                // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šåªæœ‰å½“è¯¯å·®è¶…è¿‡ 0.3ç§’ (è¯´æ˜å‘ç”Ÿäº†æ‹–æ‹½æˆ–å¡é¡¿) æ—¶ï¼Œæ‰å¼ºåˆ¶å¯¹é½
                // å¦åˆ™ï¼Œå®Œå…¨å¿½ç•¥éŸ³é¢‘æ—¶é’Ÿçš„å°æ•°ç‚¹æ³¢åŠ¨ï¼Œä¾é  delta åªæœ‰ç‰©ç†å¹³æ»‘
                if (diff > 0.3) {
                    STATE.currentTime = audioBasedTime;
                }
            }

            if (STATE.isRecording) {
                updateRecordingVisuals();

                // ============================================================
                // ğŸ”¥ [æ–°å¢]ï¼šå®æ—¶æ‹‰ä¼¸ Clip é•¿åº¦ & æ‰©å±•æ—¶é—´è½´
                // ============================================================
                let needExpand = false;
                let currentMaxDuration = 0;

                // 1. éå†æ‰€æœ‰æ­£åœ¨å½•åˆ¶çš„è½¨é“ï¼Œæ‹‰é•¿å®ƒä»¬çš„ Clip
                STATE.tracks.forEach(track => {
                    if (track.type === 'midi' && track.isArmed && track.clips.length > 0) {
                        // å‡è®¾å½•åˆ¶åˆ°ç¬¬ä¸€ä¸ª Clip (æ ¹æ®ç°æœ‰é€»è¾‘)
                        const clip = track.clips[0];

                        // å¦‚æœæ’­æ”¾å¤´è¶…è¿‡äº† Clip çš„å½“å‰æœ«å°¾ï¼Œå°±æ‹‰é•¿å®ƒ
                        if (STATE.currentTime > clip.startTime + clip.duration) {
                            clip.duration = STATE.currentTime - clip.startTime;
                            clip.updateDOMPosition(); // å®æ—¶æ›´æ–°è“è‰²æ–¹å—çš„ CSS width
                            needExpand = true;
                        }

                        const end = clip.startTime + clip.duration;
                        if (end > currentMaxDuration) currentMaxDuration = end;
                    }
                });

                // 2. åŠ¨æ€æ‰©å±•æ—¶é—´è½´æ€»é•¿åº¦ (Timeline Limit)
                // åªè¦å½“å‰å½•åˆ¶ä½ç½®æ¥è¿‘æ€»æ—¶é•¿è¾¹ç¼˜ (ä¾‹å¦‚åªå‰© 1 ç§’)ï¼Œå°±è‡ªåŠ¨æ’‘å¤§
                if (currentMaxDuration > STATE.totalDuration - 1) {
                    STATE.totalDuration = currentMaxDuration + 2; // å§‹ç»ˆä¿æŒ 2ç§’ çš„ä½™é‡

                    // æ‰‹åŠ¨æ›´æ–°å®¹å™¨å®½åº¦ï¼Œè®©æ»šåŠ¨æ¡èƒ½æ»šå¾—æ›´è¿œ
                    const newWidth = (STATE.totalDuration * STATE.pxPerSec) + 20;
                    DOM.lanes.style.width = newWidth + 'px';
                    DOM.grid.style.width = newWidth + 'px';
                    DOM.barRuler.style.width = newWidth + 'px';
                    DOM.timeRuler.style.width = newWidth + 'px';

                    // ä¼˜åŒ–ï¼šä¸è¦æ¯ä¸€å¸§éƒ½é‡ç»˜æ ‡å°ºæ•°å­—(renderRulers)ï¼Œéå¸¸è€—æ€§èƒ½
                    // ä»…å½“æ•´æ•°ç§’å‘ç”Ÿå˜åŒ–æ—¶æ‰é‡ç»˜ (1ç§’åˆ·æ–°ä¸€æ¬¡åˆ»åº¦)
                    if (Math.floor(STATE.currentTime) > Math.floor(STATE.currentTime - delta)) {
                        renderRulers();
                    }
                }
                // ============================================================
            }

            // æ›´æ–° UI æŒ‡é’ˆä½ç½®
            updatePlayhead();

            // æ£€æŸ¥éŸ³é¢‘åŒæ­¥ (è´Ÿè´£å¯åŠ¨/åœæ­¢/è·³è½¬éŸ³é¢‘)
            syncAudio();

            // ç§»åŠ¨ 3D ç›¸æœº
            const idealTargetX = STATE.currentTime * STATE.playbackSpeed;

            // 2. è·å–å½“å‰ç›¸æœºç›¸å¯¹äº Target çš„åç§»é‡ (ä¿ç•™ç”¨æˆ·çš„æ—‹è½¬/ç¼©æ”¾çŠ¶æ€)
            // æ³¨æ„ï¼šè¿™é‡Œåªå– X è½´çš„ç›¸å¯¹è·ç¦»æ˜¯ä¸å¤Ÿçš„ï¼ŒOrbitControls çš„æ ¸å¿ƒæ˜¯ä¿æŒç›¸å¯¹çŸ¢é‡ä¸å˜
            const relativeOffset = camera.position.x - controls.target.x;

            // 3. å¼ºåˆ¶å¯¹é½ Target åˆ°ç»å¯¹æ—¶é—´ä½ç½®
            controls.target.x = idealTargetX;

            // 4. å¼ºåˆ¶å¯¹é½ Cameraï¼Œä¿æŒä¸ Target çš„ç›¸å¯¹è·ç¦»ä¸å˜
            camera.position.x = idealTargetX + relativeOffset;

            // 5. æ›´æ–°è¿½è¸ªå™¨ï¼Œé˜²æ­¢æ˜Ÿç©ºèƒŒæ™¯è®¡ç®—å‡ºé”™
            cameraTargetX = idealTargetX;
        }

        // --- Shader Uniforms æ›´æ–° ---
        const playheadX = STATE.currentTime * STATE.playbackSpeed;

        // è·å–å½“å‰å¼€å…³çŠ¶æ€ (1.0 å¼€, 0.0 å…³)
        const fadeVal = STATE.enableMidiFade ? 1.0 : 0.0;

        for (let i = 0, l = activeShaderMaterials.length; i < l; i++) {
            const mat = activeShaderMaterials[i];
            if (mat.uniforms) {
                mat.uniforms.uPlayheadX.value = playheadX;

                // ğŸ”¥ æ–°å¢ï¼šå®æ—¶åŒæ­¥ Fade å¼€å…³
                if (mat.uniforms.uEnableFade) {
                    mat.uniforms.uEnableFade.value = fadeVal;
                }
            }
        }

        controls.update();
        updateRealtimeHUD();
        ViewMgr.updateLiveUI();

        // --- èƒŒæ™¯æ¸²æŸ“ (å«æ¨¡ç³Šé€»è¾‘) ---
        if (bgMesh && bgMesh.visible && bgTexture) {
            let blurAmount = BG_STATE.blur;

            if (blurAmount > 0) {
                // åŠ¨æ€è°ƒæ•´æ¨¡ç³Šç”»è´¨ä»¥ä¿è¯æ€§èƒ½
                if (ExportMgr.isRecording) {
                    // å½•åˆ¶æ—¶ï¼šå¦‚æœè¿™ä¸€å¸§æ¸²æŸ“å¤ªæ…¢ (>40ms)ï¼Œç¨å¾®é™ä½æ¨¡ç³Šé‡‡æ ·ç‡é˜²æ­¢å´©æºƒ
                    if (delta > 0.04) {
                        ExportMgr.blurThrottle = Math.max(0.0, ExportMgr.blurThrottle - 0.01);
                    }
                } else {
                    // å¹³æ—¶ï¼šç”»è´¨ä¼˜å…ˆ
                    ExportMgr.blurThrottle = Math.min(1.0, ExportMgr.blurThrottle + 0.05);
                }

                const effectiveBlur = blurAmount * ExportMgr.blurThrottle;

                // Pass 1: æ¨ªå‘æ¨¡ç³Š
                blurMesh.material = blurMatX;
                blurMatX.uniforms.tMap.value = bgTexture;
                blurMatX.uniforms.uBlur.value = effectiveBlur;
                renderer.setRenderTarget(blurRtX);
                renderer.render(blurScene, blurCamera);

                // Pass 2: çºµå‘æ¨¡ç³Š
                blurMesh.material = blurMatY;
                blurMatY.uniforms.tMap.value = blurRtX.texture;
                blurMatY.uniforms.uBlur.value = effectiveBlur;
                renderer.setRenderTarget(blurRtY);
                renderer.render(blurScene, blurCamera);

                // Final: ä¸Šå±
                renderer.setRenderTarget(null);
                bgMaterial.uniforms.tMap.value = blurRtY.texture;
            } else {
                bgMaterial.uniforms.tMap.value = bgTexture;
            }
        }

        renderer.render(scene, camera);
    }

    const ExportMgr = {
        modal: document.getElementById('export-modal'),
        statusEl: document.getElementById('recording-status'),
        recTimeEl: document.getElementById('rec-time'),
        recTotalEl: document.getElementById('rec-total'),

        mediaRecorder: null,
        isRecording: false,
        blurThrottle: 1.0,

        // ğŸ”¥ æ–°å¢ï¼šæµå¼å†™å…¥ç›¸å…³çš„å¥æŸ„
        fileHandle: null,
        writableStream: null,
        isStreamMode: false, // æ ‡è®°æ˜¯å¦æ”¯æŒæµå¼å†™å…¥

        // å¤‡ç”¨æ–¹æ¡ˆçš„å†…å­˜æ•°ç»„ï¼ˆä»…å½“ä¸æ”¯æŒæµå¼å†™å…¥æ—¶ä½¿ç”¨ï¼‰
        chunks: [],

        originalSize: { width: 0, height: 0 },
        audioContext: null,
        destNode: null,
        sourceNode: null,

        init() {
            // 1. å¡«å……æ ¼å¼é€‰é¡¹
            const formatSel = document.getElementById('exportFormat');
            const types = [
                'video/mp4',
                'video/webm;codecs=vp9',
                'video/webm;codecs=vp8',
                'video/webm',
            ];
            types.forEach(type => {
                if (MediaRecorder.isTypeSupported(type)) {
                    const opt = document.createElement('option');
                    opt.value = type;
                    opt.innerText = type;
                    formatSel.appendChild(opt);
                }
            });

            // 2. ç»‘å®šæŒ‰é’®
            document.getElementById('showExportBtn').addEventListener('click', () => {
                // ğŸ”¥ ä¿®æ”¹ç‚¹ï¼šå¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œåªæš‚åœ (togglePlay)ï¼Œä¸è¦åœæ­¢ (stopPlay)
                // stopPlay() ä¼šå¼ºåˆ¶ seekTo(0)ï¼Œå¯¼è‡´è¿›åº¦ä¸¢å¤±
                if (STATE.isPlaying) {
                    togglePlay();
                }
                this.modal.style.display = 'flex';
            });

            document.getElementById('cancelExportBtn').addEventListener('click', () => {
                this.modal.style.display = 'none';
            });

            document.getElementById('startExportBtn').addEventListener('click', () => {
                this.startRecording();
            });

            document.getElementById('stopRecBtn').addEventListener('click', () => {
                this.stopRecording();
            });
        },

        async startRecording() {
            // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ 1: å…ˆç«‹ flagï¼Œé˜²æ­¢ CSS å˜åŠ¨è§¦å‘ onResize æ£ä¹± ğŸ”¥ğŸ”¥ğŸ”¥
            this.isRecording = true;
            this.statusEl.style.display = 'flex';

            this.modal.style.display = 'none';

            // è‡ªåŠ¨å›æ»šé€»è¾‘
            if (STATE.currentTime >= STATE.totalDuration - 0.5) {
                seekTo(0);
            }

            this.wasBgVisible = bgMesh ? bgMesh.visible : false;
            this.forcedBgVisible = false;

            const isStarfieldOn = document.getElementById('starfieldToggle').checked;

            if (!currentBgType && isStarfieldOn && bgMesh && bgMaterial) {
                if (window.starfieldBgTexture) {
                    bgMaterial.uniforms.tMap.value = window.starfieldBgTexture;
                }
                bgMaterial.uniforms.uOpacity.value = 1.0;
                bgMaterial.uniforms.uBrightness.value = 0.0;
                bgMaterial.uniforms.uContrast.value = 1.0;
                BG_STATE.fit = 'cover';
                updateBackgroundUV();
                bgMesh.visible = true;
                this.forcedBgVisible = true;
            }
            else if (bgMesh && this.wasBgVisible) {
                bgMesh.visible = true;
            }

            // è·å–å¯¼å‡ºå‚æ•°
            const ratio = parseFloat(document.getElementById('exportRatio').value);
            const resolutionP = parseInt(document.getElementById('exportRes').value);
            const fps = parseInt(document.getElementById('exportFps').value);
            const mimeType = document.getElementById('exportFormat').value;

            let width, height;
            if (ratio >= 1) {
                height = resolutionP;
                width = Math.round(height * ratio);
            } else {
                width = resolutionP;
                height = Math.round(width / ratio);
            }
            width = width % 2 === 0 ? width : width + 1;
            height = height % 2 === 0 ? height : height + 1;

            // --- æµå¼å†™å…¥åˆå§‹åŒ– ---
            this.isStreamMode = false;
            this.fileHandle = null;
            this.writableStream = null;
            this.chunks = [];

            if (window.showSaveFilePicker) {
                try {
                    const isMp4 = mimeType.includes('mp4');
                    const ext = isMp4 ? '.mp4' : '.webm';
                    this.fileHandle = await window.showSaveFilePicker({
                        suggestedName: `SeeMusic_${new Date().getTime()}${ext}`,
                        types: [{
                            description: 'Video File',
                            accept: isMp4 ? {'video/mp4': ['.mp4']} : {'video/webm': ['.webm']}
                        }],
                    });
                    this.writableStream = await this.fileHandle.createWritable();
                    this.isStreamMode = true;
                } catch (err) {
                    if (err.name === 'AbortError') {
                        this.cleanup(); // å¦‚æœå–æ¶ˆä¿å­˜ï¼Œè®°å¾—æ¸…ç†çŠ¶æ€
                        this.isRecording = false; // å¤ä½æ ‡è®°
                        return;
                    }
                    console.warn("æ— æ³•å»ºç«‹æ–‡ä»¶æµï¼Œé™çº§ä¸ºå†…å­˜æ¨¡å¼:", err);
                }
            }

            // --- è®¾ç½®åœºæ™¯å‚æ•° ---
            const canvas = renderer.domElement;
            this.originalSize.width = canvas.width;
            this.originalSize.height = canvas.height;
            this.originalPixelRatio = renderer.getPixelRatio();

            renderer.setClearColor(0x000000, 1.0);

            // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ 2: å¼ºåˆ¶ 1.0 åƒç´ æ¯”ï¼Œç¡®ä¿ 1080p å°±æ˜¯ 1080p ğŸ”¥ğŸ”¥ğŸ”¥
            renderer.setPixelRatio(1.0);
            renderer.setSize(width, height);

            // æ¨¡ç³Šç³»ç»Ÿç¼©æ”¾ (é…åˆä¹‹å‰å»ºè®®çš„ BLUR_SCALE ä½¿ç”¨ï¼Œå»ºè®®è®¾ä¸º 0.5)
            // ç¡®ä¿ä½ å·²ç»å®šä¹‰äº†å…¨å±€çš„ BLUR_SCALE (åœ¨ä»£ç é¡¶éƒ¨)
            const bScale = (typeof BLUR_SCALE !== 'undefined') ? BLUR_SCALE : 0.5;

            if (blurRtX) blurRtX.setSize(width * bScale, height * bScale);
            if (blurRtY) blurRtY.setSize(width * bScale, height * bScale);
            if (blurMatX) blurMatX.uniforms.uResolution.value.set(width * bScale, height * bScale);
            if (blurMatY) blurMatY.uniforms.uResolution.value.set(width * bScale, height * bScale);

            // é”å®š CSS æ ·å¼ (è¿™å¯èƒ½ä¼šè§¦å‘ resizeï¼Œä½†å› ä¸º isRecording=trueï¼Œä¼šè¢« onResize æ‹¦æˆª)
            document.getElementById('canvas-wrapper').classList.add('recording-mode');

            camera.aspect = ratio;
            camera.updateProjectionMatrix();
            updateBackgroundSize();
            updateBackgroundUV();

            // --- éŸ³é¢‘èŠ‚ç‚¹ ---
            if (!this.audioContext) this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (this.audioContext.state === 'suspended') await this.audioContext.resume();

            if (!this.sourceNode && DOM.audio) {
                try {
                    this.sourceNode = this.audioContext.createMediaElementSource(DOM.audio);
                    this.sourceNode.connect(this.audioContext.destination);
                } catch (e) { console.warn(e); }
            }

            if (this.sourceNode) {
                if (this.destNode) {
                    try { this.sourceNode.disconnect(this.destNode); } catch(e) {}
                }
                this.destNode = this.audioContext.createMediaStreamDestination();
                this.sourceNode.connect(this.destNode);
            }

            // --- å¼€å§‹å½•åˆ¶ ---
            const canvasStream = canvas.captureStream(fps);
            const tracks = [...canvasStream.getVideoTracks()];

            if (this.destNode) tracks.push(...this.destNode.stream.getAudioTracks());

            const combinedStream = new MediaStream(tracks);

            // æé«˜ç ç‡ä¸Šé™
            const bitrate = resolutionP > 1080 ? 25000000 : 12000000;
            const options = {
                mimeType: mimeType,
                videoBitsPerSecond: bitrate,
                // ğŸ”¥ æ–°å¢ï¼šæ˜ç¡®æŒ‡å®šéŸ³é¢‘æ¯”ç‰¹ç‡ï¼ˆå»ºè®® 128kbps æˆ–æ›´é«˜ï¼‰
                audioBitsPerSecond: 256000
            };

            try {
                this.mediaRecorder = new MediaRecorder(combinedStream, options);
            } catch (e) {
                this.mediaRecorder = new MediaRecorder(combinedStream);
            }

            this.mediaRecorder.ondataavailable = async (e) => {
                if (e.data && e.data.size > 0) {
                    if (this.isStreamMode && this.writableStream) {
                        try {
                            await this.writableStream.write(e.data);
                        } catch (err) {
                            console.error("å†™å…¥å¤±è´¥:", err);
                            this.stopRecording();
                        }
                    } else {
                        this.chunks.push(e.data);
                    }
                }
            };

            this.mediaRecorder.onstop = async () => {
                if (this.isStreamMode && this.writableStream) {
                    await this.writableStream.close();
                    this.fileHandle = null;
                    this.writableStream = null;
                    alert("è§†é¢‘å·²ä¿å­˜ï¼");
                } else {
                    const blob = new Blob(this.chunks, { type: this.mediaRecorder.mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = `SeeMusic_Export_${new Date().getTime()}.webm`;
                    document.body.appendChild(a);
                    a.click();
                    setTimeout(() => {
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                        this.chunks = [];
                    }, 100);
                }
                this.cleanup();
            };

            this.recTotalEl.innerText = formatTime(STATE.totalDuration);
            this.mediaRecorder.start(1000);

            if (!STATE.isPlaying) togglePlay();

            this.checkInterval = setInterval(() => {
                this.recTimeEl.innerText = formatTime(STATE.currentTime);
                if (STATE.currentTime >= STATE.totalDuration) {
                    this.stopRecording();
                }
            }, 500);
        },

        stopRecording() {
            if (!this.isRecording) return;
            this.isRecording = false;

            this.blurThrottle = 1.0;

            if (STATE.isPlaying) togglePlay();

            if(this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                this.mediaRecorder.stop();
                this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
            clearInterval(this.checkInterval);
        },

        cleanup() {
            this.statusEl.style.display = 'none';
            document.getElementById('canvas-wrapper').classList.remove('recording-mode');

            renderer.setPixelRatio(this.originalPixelRatio || window.devicePixelRatio);

            renderer.setClearColor(0x0b0c15, 0);

            if (this.forcedBgVisible) {
                // å¦‚æœæ˜¯æˆ‘ä»¬åˆšæ‰å¼ºè¡Œæ‰“å¼€çš„ï¼Œç°åœ¨å…³æ‰å®ƒ
                if (bgMesh) bgMesh.visible = false;
                this.forcedBgVisible = false;
            } else {
                // å¦åˆ™æ¢å¤ä¹‹å‰çš„çŠ¶æ€
                if (bgMesh) bgMesh.visible = this.wasBgVisible;
            }

            const wrapper = document.getElementById('canvas-wrapper');
            renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);

            camera.aspect = wrapper.clientWidth / wrapper.clientHeight;
            camera.updateProjectionMatrix();
            updateBackgroundSize();
            updateBackgroundUV();
            const starToggle = document.getElementById('starfieldToggle');
            if (starToggle && starToggle.checked && !currentBgType) {
                setStarfieldState(true);
            }
            renderer.render(scene, camera);
        }
    };

    // ==========================================
    // 6. å·¥ç¨‹ç®¡ç† (Save / Load / Undo)
    // ==========================================
    const ProjectMgr = {
        // ğŸ”¥ æ–°å¢ï¼šç”¨äºå­˜å‚¨å½“å‰æ‰“å¼€æ–‡ä»¶çš„å¥æŸ„
        currentFileHandle: null,

        init() {
            // ç‚¹å‡»ä¿å­˜æŒ‰é’® (é»˜è®¤ä¸ºå¦å­˜ä¸ºï¼Œä½†å¦‚æœå·²æœ‰å¥æŸ„åˆ™è¯¢é—®æˆ–è¦†ç›–ï¼Œè¿™é‡Œä¿ç•™åŸé€»è¾‘ä¸ºå¦å­˜ä¸ºï¼Œæˆ–è€…ä½ å¯ä»¥æ”¹ä¸ºè°ƒç”¨ quickSave)
            // å»ºè®®ï¼šç‚¹å‡»å·¥å…·æ çš„â€œä¿å­˜å·¥ç¨‹â€æŒ‰é’®æ‰§è¡Œ QuickSaveï¼ˆå¦‚æœæœ‰æ–‡ä»¶ï¼‰ï¼Œå¦åˆ™æ‰§è¡Œ SaveAs
            document.getElementById('saveProjectBtn').addEventListener('click', () => {
                this.quickSave();
            });

            // ğŸ”¥ ä¿®æ”¹è¯»å–æŒ‰é’®é€»è¾‘ï¼šä¼˜å…ˆä½¿ç”¨ showOpenFilePicker ä»¥è·å–å¥æŸ„
            document.getElementById('loadProjectBtn').addEventListener('click', async () => {
                if (window.showOpenFilePicker) {
                    try {
                        const [handle] = await window.showOpenFilePicker({
                            types: [{
                                description: 'SeeMusic Project File',
                                accept: { 'application/json': ['.json'] }
                            }],
                            multiple: false
                        });

                        // è·å–æ–‡ä»¶å¹¶åŠ è½½
                        const file = await handle.getFile();
                        this.currentFileHandle = handle; // ğŸ”¥ å…³é”®ï¼šä¿å­˜å¥æŸ„
                        this.loadProject(file);
                    } catch (err) {
                        // ç”¨æˆ·å–æ¶ˆæˆ–ä¸æ”¯æŒï¼Œå¿½ç•¥
                        if (err.name !== 'AbortError') console.error(err);
                    }
                } else {
                    // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨æ—§çš„ input æ–¹å¼ (ä¸æ”¯æŒè¦†ç›–ä¿å­˜)
                    document.getElementById('projectInput').click();
                }
            });

            // æ–‡ä»¶å˜æ›´ç›‘å¬ (é™çº§æ–¹æ¡ˆ)
            document.getElementById('projectInput').addEventListener('change', (e) => {
                this.currentFileHandle = null; // input æ–¹å¼æ— æ³•è·å–å†™æƒé™ï¼Œé‡ç½®å¥æŸ„
                this.loadProject(e.target.files[0]);
                e.target.value = '';
            });
        },

        getCurrentState() {
            // è·å–è§†è§’
            const currentViewParams = ViewMgr.getCurrentSpherical();

            // è·å–ç¼–ç»„ (Set è½¬ Array)
            const serializedGroups = {};
            for (const key in STATE.groups) {
                const group = STATE.groups[key];
                serializedGroups[key] = {
                    ...group,
                    trackIds: Array.from(group.trackIds)
                };
            }

            // è¿”å›å®Œæ•´çš„å·¥ç¨‹å¯¹è±¡
            return {
                version: "1.2",
                timestamp: new Date().toISOString(),
                settings: {
                    duration: STATE.totalDuration,
                    pxPerSec: STATE.pxPerSec,
                    playbackSpeed: STATE.playbackSpeed,
                    noteThickness: STATE.noteThickness,
                    noteHeightScale: STATE.noteHeightScale,

                    // âœ…ã€ä¿®å¤é‡ç‚¹ã€‘å¦‚æœ DOM å…ƒç´ ä¸å­˜åœ¨ï¼Œç›´æ¥ç”¨ STATE å˜é‡
                    sceneZoom: DOM.sceneZoom ? parseInt(DOM.sceneZoom.value) : STATE.playbackSpeed,
                    timelineZoom: STATE.pxPerSec, // âœ… ä¸å†è¯»å– DOM.timelineZoom.value

                    zSeparation: STATE.zSeparation,
                    noteShape: STATE.noteShape,
                    cameraView: currentViewParams,
                    starfieldVisible: document.getElementById('starfieldToggle') ? document.getElementById('starfieldToggle').checked : true
                },
                background: {
                    params: BG_STATE,
                    type: currentBgType,
                    data: storedBgBase64ForSave
                },
                groups: serializedGroups,
                tracks: STATE.tracks.map(t => ({
                    id: t.id,
                    name: t.name,
                    type: t.type,
                    ownColor: t.ownColor,
                    groupId: t.groupId,
                    isMuted: t.isMuted,
                    isSoloed: t.isSoloed,
                    clips: t.clips.map(c => ({
                        start: c.startTime,
                        duration: c.duration,
                        name: c.name,
                        sourceData: c.sourceFile
                    }))
                }))
            };
        },

        // ğŸ”¥ æ–°å¢ï¼šæ™ºèƒ½ä¿å­˜ (Quick Save / Ctrl+S)
        async quickSave() {
            // 1. å¦‚æœæœ‰å¥æŸ„ï¼Œç›´æ¥å†™å…¥åŸæ–‡ä»¶
            if (this.currentFileHandle) {
                try {
                    const project = this.getCurrentState();
                    const jsonStr = JSON.stringify(project);

                    // åˆ›å»ºå¯å†™æµ
                    const writable = await this.currentFileHandle.createWritable();
                    await writable.write(jsonStr);
                    await writable.close();

                    // ç®€å•çš„è§†è§‰åé¦ˆ
                    const btn = document.getElementById('saveProjectBtn');
                    const originalText = btn.innerText;
                    btn.innerText = "å·²ä¿å­˜!";
                    setTimeout(() => btn.innerText = originalText, 1500);
                    console.log("å·¥ç¨‹å·²ä¿å­˜åˆ°åŸæ–‡ä»¶");
                    return;
                } catch (err) {
                    console.warn("å†™å…¥åŸæ–‡ä»¶å¤±è´¥ï¼Œè½¬ä¸ºå¦å­˜ä¸º:", err);
                    // å¦‚æœå†™å…¥å¤±è´¥ï¼ˆä¾‹å¦‚æƒé™ä¸¢å¤±ï¼‰ï¼Œè½¬ä¸º Save As
                }
            }

            // 2. å¦‚æœæ²¡æœ‰å¥æŸ„ï¼Œæ‰§è¡Œâ€œå¦å­˜ä¸ºâ€
            const defaultName = `SeeMusic_Project_${new Date().toLocaleDateString().replace(/\//g, '-')}`;
            this.executeSave(defaultName);
        },

        // å¦å­˜ä¸º (Save As)
        async executeSave(fileName) {
            const project = this.getCurrentState();
            const jsonStr = JSON.stringify(project);

            if (window.showSaveFilePicker) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: `${fileName}.json`,
                        types: [{
                            description: 'SeeMusic Project File',
                            accept: { 'application/json': ['.json'] },
                        }],
                    });

                    // ğŸ”¥ å…³é”®ï¼šå¦å­˜ä¸ºæˆåŠŸåï¼Œæ›´æ–°å½“å‰å¥æŸ„
                    this.currentFileHandle = handle;

                    const writable = await handle.createWritable();
                    await writable.write(jsonStr);
                    await writable.close();
                    return;
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error('Save File Error:', err);
                        alert("ä¿å­˜å¤±è´¥ï¼Œè½¬ä¸ºè‡ªåŠ¨ä¸‹è½½...");
                    } else {
                        return;
                    }
                }
            }

            // å¤‡ç”¨æ–¹æ¡ˆï¼šè‡ªåŠ¨ä¸‹è½½ (æ— æ³•æ›´æ–°å¥æŸ„)
            const blob = new Blob([jsonStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${fileName}.json`;
            a.click();
            URL.revokeObjectURL(url);
        },

        async restoreState(json) {
            // å…ˆæ¸…ç©ºå½“å‰æ‰€æœ‰å†…å®¹
            this.clearAll();

            // 1. æ¢å¤å…¨å±€è®¾ç½®
            if (json.settings) {
                STATE.pxPerSec = json.settings.pxPerSec || 50;
                STATE.playbackSpeed = json.settings.playbackSpeed || 20;
                STATE.noteThickness = json.settings.noteThickness || 1.0;
                STATE.noteHeightScale = json.settings.noteHeightScale || 1.5;
                STATE.zSeparation = (json.settings.zSeparation !== undefined) ? json.settings.zSeparation : 0.3;

                if (json.settings.noteShape) {
                    STATE.noteShape = json.settings.noteShape;
                    const shapeSel = document.getElementById('noteShapeSelect');
                    if (shapeSel) shapeSel.value = STATE.noteShape;
                }

                if(DOM.timelineZoom) DOM.timelineZoom.value = STATE.pxPerSec;
                if(DOM.sceneZoom) DOM.sceneZoom.value = STATE.playbackSpeed;

                const thickSlider = document.getElementById('thicknessSlider');
                if(thickSlider) thickSlider.value = STATE.noteThickness * 100;

                const heightSlider = document.getElementById('heightSlider');
                if(heightSlider) heightSlider.value = STATE.noteHeightScale * 100;

                const zSlider = document.getElementById('zSpaceSlider');
                if(zSlider) zSlider.value = STATE.zSeparation * 10;

                if (json.settings.cameraView) {
                    ViewMgr.restore(json.settings.cameraView);
                }
                const starVisible = (json.settings.starfieldVisible !== undefined)
                    ? json.settings.starfieldVisible
                    : true;

                // è°ƒç”¨å…¨å±€å‡½æ•°è®¾ç½®çŠ¶æ€ (å®ƒä¼šè‡ªåŠ¨å¤„ç† checkbox å’Œ 3D åœºæ™¯)
                setStarfieldState(starVisible);
            }

            // 2. æ¢å¤èƒŒæ™¯
            if (json.background) {
                if (json.background.params) {
                    Object.assign(BG_STATE, json.background.params);
                    updateBgUI();
                    if (bgMaterial) {
                        bgMaterial.uniforms.uOpacity.value = BG_STATE.opacity;
                        bgMaterial.uniforms.uBrightness.value = (BG_STATE.brightness - 100) / 100;
                        bgMaterial.uniforms.uContrast.value = BG_STATE.contrast / 100;
                    }
                }
                if (json.background.data && json.background.type) {
                    currentBgBase64 = json.background.data;
                    currentBgType = json.background.type;
                    storedBgBase64ForSave = json.background.data;
                    applyBackgroundSource(currentBgBase64, currentBgType);
                }
            } else {
                if (bgMesh) bgMesh.visible = false;
                if (bgVideoElement) {
                    bgVideoElement.pause();
                    bgVideoElement = null;
                }
                currentBgBase64 = null;
                storedBgBase64ForSave = null;
            }

            // 3. æ¢å¤ç¼–ç»„ (Group)
            if (json.groups) {
                STATE.groups = json.groups;
                let maxId = 0;
                for (const gid in STATE.groups) {
                    const g = STATE.groups[gid];
                    if(g.id > maxId) maxId = g.id;

                    // ğŸ”¥ å…³é”®ä¿®å¤ 2ï¼šé˜²æ­¢è¯»å–æ—§åæ¡£æ—¶æŠ¥é”™
                    // å¦‚æœæ˜¯æ•°ç»„(æ–°ç‰ˆæ­£å¸¸æ¡£)ï¼Œç›´æ¥ç”¨ï¼›å¦‚æœæ˜¯å¯¹è±¡{}(æ—§ç‰ˆåæ¡£)æˆ–undefinedï¼Œç”¨ç©ºæ•°ç»„ä»£æ›¿
                    const ids = Array.isArray(g.trackIds) ? g.trackIds : [];
                    g.trackIds = new Set(ids);
                }
                STATE.nextGroupId = maxId + 1;
            }

            // 4. æ¢å¤è½¨é“ (Tracks)
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            let maxTrackId = 0;

            for (const tData of json.tracks) {
                const track = new Track(tData.name, tData.type);
                track.id = tData.id;
                if (track.id > maxTrackId) maxTrackId = track.id;

                if (track.laneEl) track.laneEl.id = `lane-${track.id}`;
                const groupInd = track.headerEl.querySelector('.group-indicator');
                if (groupInd) groupInd.id = `group-ind-${track.id}`;

                track.ownColor = tData.ownColor;

                // æ¢å¤ç¼–ç»„å…³è”
                if (tData.groupId && STATE.groups[tData.groupId]) {
                    track.groupId = tData.groupId;
                    // ç¡®ä¿æ˜¯ Set å†æ·»åŠ  (ä¸Šé¢ä¿®å¤åè¿™é‡Œä¸€å®šæ˜¯ Set)
                    if (STATE.groups[tData.groupId].trackIds instanceof Set) {
                        STATE.groups[tData.groupId].trackIds.add(track.id);
                    }
                } else {
                    track.groupId = null;
                }

                STATE.tracks.push(track);

                const colorInput = track.headerEl.querySelector('.track-color-picker');
                if(colorInput) colorInput.value = tData.ownColor;

                for (const cData of tData.clips) {
                    let processedData = null;
                    if (tData.type === 'midi') {
                        processedData = cData.sourceData;
                    } else if (tData.type === 'audio') {
                        try {
                            const res = await fetch(cData.sourceData);
                            const ab = await res.arrayBuffer();
                            processedData = await audioCtx.decodeAudioData(ab);
                        } catch (err) { console.error("éŸ³é¢‘æ¢å¤å¤±è´¥", err); }
                    }

                    if (processedData) {
                        track.addClip(cData.start, cData.duration, processedData, cData.name, cData.sourceData);
                    }
                }

                track.setMute(tData.isMuted || false);
                track.setSolo(tData.isSoloed || false);
                track.refreshColor();
            }

            STATE.nextTrackId = maxTrackId + 1;

            updateTrackZRanks();

            updateTotalDuration();
            autoFitZoom(STATE.totalDuration);

            // å¦‚æœæœ‰éŸ³é¢‘ï¼Œæ¢å¤æ’­æ”¾å™¨
            const firstAudioClip = STATE.clips.find(c => c.track.type === 'audio');
            if (firstAudioClip) {
                STATE.activeAudioClip = firstAudioClip;
                DOM.audio.src = firstAudioClip.sourceFile;
            }

            console.log("å·¥ç¨‹å·²æ¢å¤ï¼ŒåŒ…å«è§†è§’å‚æ•°ã€‚");
        },

        // ç”¨äº Undo åˆ é™¤çš„æ¢å¤é€»è¾‘ (ä¿æŒä¸å˜)
        async restoreSingleTrack(tData, insertIndex) {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const track = new Track(tData.name, tData.type);

            track.id = tData.id;
            if (track.laneEl) track.laneEl.id = `lane-${track.id}`;
            const groupInd = track.headerEl.querySelector('.group-indicator');
            if (groupInd) groupInd.id = `group-ind-${track.id}`;

            track.ownColor = tData.ownColor;
            track.groupId = tData.groupId;

            const colorInput = track.headerEl.querySelector('.track-color-picker');
            if(colorInput) colorInput.value = tData.ownColor;

            STATE.tracks.splice(insertIndex, 0, track);
            DOM.headers.appendChild(track.headerEl);
            DOM.lanes.appendChild(track.laneEl);

            if (typeof reorderTracks === 'function') reorderTracks();

            for (const cData of tData.clips) {
                let processedData = null;
                if (tData.type === 'midi') {
                    processedData = cData.sourceData;
                } else if (tData.type === 'audio') {
                    try {
                        const res = await fetch(cData.sourceData);
                        const ab = await res.arrayBuffer();
                        processedData = await audioCtx.decodeAudioData(ab);
                    } catch (err) { console.error(err); }
                }

                if (processedData) {
                    track.addClip(cData.start, cData.duration, processedData, cData.name, cData.sourceData);
                }
            }

            if (track.type === 'audio' && track.clips.length > 0) {
                const clip = track.clips[0];
                STATE.activeAudioClip = clip;
                DOM.audio.src = clip.sourceFile;
                DOM.audio.load();
                if (STATE.currentTime > 0) {
                    DOM.audio.currentTime = STATE.currentTime - clip.startTime;
                }
            }

            track.refreshColor();
            updateGridBackground();
            updateTotalDuration();
            STATE.clips.forEach(c => c.updateDOMPosition());
        },

        loadProject(file) {
            if (!file) return;
            DOM.loading.style.display = 'flex';

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const json = JSON.parse(e.target.result);
                    const oldProjectState = this.getCurrentState();
                    await this.restoreState(json);

                    HistoryMgr.add({
                        type: 'load_project',
                        oldProject: oldProjectState, // å­˜å…¥æ—§ç‰ˆæ‰€æœ‰æ•°æ®
                        newProject: json             // å­˜å…¥æ–°ç‰ˆæ‰€æœ‰æ•°æ®
                    });

                    requestAnimationFrame(() => {
                        window.dispatchEvent(new Event('resize'));
                    });
                } catch (err) {
                    console.error(err);
                    alert("å·¥ç¨‹æ–‡ä»¶æŸåæˆ–æ ¼å¼é”™è¯¯");
                }
                DOM.loading.style.display = 'none';
            };
            reader.readAsText(file);
        },

        clearAll() {
            stopPlay();
            STATE.clips.forEach(c => c.destroy());
            STATE.tracks.forEach(t => {
                if(t.headerEl) t.headerEl.remove();
                if(t.laneEl) t.laneEl.remove();
            });
            STATE.tracks = [];
            STATE.clips = [];
            STATE.groups = {};
            STATE.selectedTrackIds.clear();
            STATE.nextTrackId = 1;
            STATE.nextGroupId = 1;

            DOM.headers.innerHTML = '';
            DOM.lanes.innerHTML = `
                <div class="grid-lines" id="gridLines"></div>
                <div id="ui-playhead"></div>
            `;
            DOM.grid = document.getElementById('gridLines');
            DOM.playhead = document.getElementById('ui-playhead');
            updateGridBackground();

            // é‡ç½®è§†è§’åˆ°é»˜è®¤
            ViewMgr.reset();
        }
    };

    // ç®€å•çš„ç§’è½¬ mm:ss æ ¼å¼åŒ–å‡½æ•°
    function formatTime(seconds) {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }

    // åœ¨åˆå§‹åŒ–é‡Œå¯åŠ¨
    ExportMgr.init();

    // ğŸ”¥ å¯åŠ¨å·¥ç¨‹ç®¡ç†å™¨
    ProjectMgr.init();

    // å¯åŠ¨
    initController();
    window.addEventListener('beforeunload', () => {
        // 1. ç«‹å³åˆ‡æ–­åŠ¨ç”»å¾ªç¯æ ‡å¿—ä½
        // åªè¦è¿™ä¸ªä¸º falseï¼Œanimate() é‡Œçš„æ¸²æŸ“é€»è¾‘å°±ä¼šåœæ­¢
        STATE.isPlaying = false;

        // 2. åœæ­¢ HTML5 Audio (é˜²æ­¢å…³é—­åå£°éŸ³æ®‹ç•™)
        if (DOM.audio) {
            DOM.audio.pause();
            DOM.audio.src = "";
            DOM.audio.load();
        }

        // 3. å…³é—­ Web Audio Context (è¿™æ˜¯ç³»ç»Ÿçº§èµ„æºï¼Œå»ºè®®æ˜¾å¼å…³é—­)
        if (sharedAudioCtx && sharedAudioCtx.state !== 'closed') {
            sharedAudioCtx.close().catch(e => {});
        }

        // 4. åœæ­¢èƒŒæ™¯è§†é¢‘
        if (bgVideoElement) {
            bgVideoElement.pause();
            bgVideoElement.src = "";
        }

        // 5. åœæ­¢å½•åˆ¶ (å¦‚æœæ­£åœ¨å½•åˆ¶)
        if (typeof ExportMgr !== 'undefined' && ExportMgr.isRecording) {
            ExportMgr.mediaRecorder = null; // ç›´æ¥åˆ‡æ–­å¼•ç”¨ï¼Œä¸å†è°ƒç”¨ stop() ä»¥å…è§¦å‘å›è°ƒé€»è¾‘
        }

        // 6. æ¸…ç©ºå†å²è®°å½•æ ˆå¼•ç”¨ (å¿«é€Ÿé‡Šæ”¾å†…å­˜å¼•ç”¨ï¼Œä½†ä¸æ‰§è¡Œç¹é‡çš„é”€æ¯é€»è¾‘)
        // è®©æµè§ˆå™¨ GC è‡ªå·±å»å¤„ç†ï¼Œä¸è¦æ‰‹åŠ¨éå†
        if (typeof HistoryMgr !== 'undefined') {
            HistoryMgr.undoStack = null;
            HistoryMgr.redoStack = null;
        }

        // âŒ åˆ é™¤ï¼šä¸è¦è°ƒç”¨ renderer.forceContextLoss()ï¼Œè¿™ä¼šå¯¼è‡´ Chrome å´©æºƒ
        // âŒ åˆ é™¤ï¼šä¸è¦éå† scene.traverse()ï¼Œè¿™ä¼šå¯¼è‡´ä¸»çº¿ç¨‹å¡æ­»

        // 7. ç®€å•æ–­å¼€æ¸²æŸ“å™¨å¼•ç”¨
        renderer = null;
        scene = null;
        camera = null;
    });

    init3D();
    initDragAndDrop();
    initResizeHandle();
    if (document.getElementById('starfieldToggle').checked) {
        // ç¨å¾®å»¶è¿Ÿä¸€ç‚¹ç‚¹ï¼Œç¡®ä¿ init3D ä¸­çš„æè´¨å’Œçº¹ç†éƒ½å‡†å¤‡å¥½äº†
        setTimeout(() => {
            setStarfieldState(true);
        }, 100);
    }
    setTimeout(() => {
        window.dispatchEvent(new Event('resize'));
    }, 100);

    window.addEventListener('load', () => {
        const loadingScreen = document.getElementById('loading');
        if (loadingScreen) {
            // ç¨å¾®å»¶è¿Ÿ 500æ¯«ç§’ æ¶ˆå¤±ï¼Œè®©åŠ¨ç”»å±•ç¤ºä¸€ä¼šå„¿ï¼Œä½“éªŒæ›´æµç•…
            setTimeout(() => {
                loadingScreen.style.opacity = '0'; // æ·¡å‡ºæ•ˆæœ
                loadingScreen.style.transition = 'opacity 0.5s ease';

                // æ·¡å‡ºåŠ¨ç”»ç»“æŸåï¼Œéšè—å…ƒç´ å¹¶æ”¹å›åŠé€æ˜èƒŒæ™¯ï¼ˆä¸ºåç»­æ–‡ä»¶åŠ è½½åšå‡†å¤‡ï¼‰
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                    loadingScreen.style.opacity = '1';
                    // æ¢å¤æˆåŠé€æ˜èƒŒæ™¯ï¼Œç”¨äºåç»­ä¸Šä¼ æ–‡ä»¶æ—¶çš„ Loading
                    loadingScreen.style.background = 'rgba(0,0,0,0.4)';
                }, 500);
            }, 800);
        }
    });

    // é˜²æ­¢é•¿æ—¶é—´å¡æ­»ï¼šå¦‚æœ 5ç§’è¿˜æ²¡åŠ è½½å®Œï¼Œå¼ºåˆ¶å…³é—­
    setTimeout(() => {
        const loadingScreen = document.getElementById('loading');
        if(loadingScreen && loadingScreen.style.display !== 'none') {
            loadingScreen.style.display = 'none';
            loadingScreen.style.background = 'rgba(0,0,0,0.4)';
        }
    }, 5000);
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Visualizer</title>

    <link rel="preconnect" href="https://fonts.loli.net">
    <link rel="preconnect" href="https://gstatic.loli.net" crossorigin>
    <link href="https://fonts.loli.net/css2?family=Chango&display=swap" rel="stylesheet">


    <style>
        :root {
            /* Apple Dark Mode Palette */
            --bg-color: #0b0c15;
            --glass-panel: rgba(30, 30, 30, 0.65);
            --glass-header: rgba(44, 44, 46, 0.75);
            --glass-border: rgba(255, 255, 255, 0.12);
            --glass-highlight: rgba(255, 255, 255, 0.1);
            --text-main: #f5f5f7;
            --text-muted: #86868b;

            /* Accents */
            --accent-blue: #0a84ff;
            --accent-green: #30d158;
            --accent-red: #ff453a;
            --accent-orange: #ff9f0a;
            --accent-yellow: #ffd60a;
            --accent-pink: #bf5af2;

            --radius-lg: 16px;
            --radius-sm: 8px;
            --blur-amt: 20px;

            --timeline-height: 40vh;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-size: 13px;
            letter-spacing: -0.01em;
        }

        /* --- é€šç”¨æ»šåŠ¨æ¡ç¾åŒ– --- */
        ::-webkit-scrollbar { width: 10px; height: 10px; background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 5px; border: 2px solid transparent; background-clip: content-box; }
        ::-webkit-scrollbar-thumb:hover { background-color: rgba(255,255,255,0.3); }
        ::-webkit-scrollbar-corner { background: transparent; }

        /* --- é¡¶éƒ¨ DAW å®¹å™¨ --- */
        #daw-container {
            height: var(--timeline-height);
            display: flex;
            flex-direction: column;
            background: radial-gradient(circle at top left, #1c1c1e 0%, #000 100%);
            border-bottom: 1px solid var(--glass-border);
            position: relative;
            z-index: 20;
        }

        /* --- å·¥å…·æ  (Toolbar) --- */
        #toolbar {
            height: 54px;
            display: flex;
            align-items: center;
            padding: 0 16px;
            background: var(--glass-header);
            backdrop-filter: blur(var(--blur-amt));
            -webkit-backdrop-filter: blur(var(--blur-amt));
            border-bottom: 1px solid var(--glass-border);
            gap: 12px;
            user-select: none;
        }

        /* --- æŒ‰é’®æ ·å¼é‡æ„ (Modern Glass) --- */
        .btn {
            /* åŸºç¡€ç»ç’ƒæ€ï¼šé»˜è®¤æ˜¯ä½è°ƒçš„åŠé€æ˜ç° */
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-main);
            padding: 6px 14px;
            border-radius: 8px; /* æ›´åœ†æ¶¦ */
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.25s cubic-bezier(0.2, 0.8, 0.2, 1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            height: 32px; /* ç»Ÿä¸€é«˜åº¦ */

            /* ğŸ”¥ æ–°å¢è¿™ä¸¤è¡Œä¿®å¤å´©åé—®é¢˜ ğŸ”¥ */
            white-space: nowrap;
            flex-shrink: 0;
        }

        /* æ‚¬åœæ•ˆæœï¼šå˜äº®å¹¶è½»å¾®ä¸Šæµ® */
        .btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .btn:active {
            transform: translateY(0);
            opacity: 0.8;
        }

        /* --- åŠŸèƒ½è‰²å˜ä½“ (é€šè¿‡ç±»åæ§åˆ¶ï¼Œè€Œä¸æ˜¯å†™æ­» style) --- */

        /* 1. å¼ºè°ƒæ“ä½œ (ä¿å­˜/è¯»å–/ç¡®å®š) - iOS è“ */
        .btn-blue {
            background: rgba(10, 132, 255, 0.15);
            border-color: rgba(10, 132, 255, 0.3);
            color: #4facfe;
        }
        .btn-blue:hover {
            background: rgba(10, 132, 255, 0.8);
            color: #fff;
            box-shadow: 0 0 15px rgba(10, 132, 255, 0.4);
        }

        /* 2. æ ¸å¿ƒé«˜äº® (å¯¼å‡ºè§†é¢‘) - éœ“è™¹ç²‰ç´«æ¸å˜ */
        .btn-primary {
            background: linear-gradient(135deg, #0a84ff 0%, #bf5af2 100%) !important;
            color: #fff !important;
            border: none !important;
            font-weight: 600;
            box-shadow: 0 2px 10px rgba(10, 132, 255, 0.3);
        }
        .btn-primary:hover {
            box-shadow: 0 0 20px rgba(191, 90, 242, 0.5);
            transform: scale(1.02) translateY(-1px);
        }

        /* 3. å±é™©/åœæ­¢æ“ä½œ (Stop/æ¸…é™¤) - æŸ”å’Œçº¢ */
        .btn-red {
            background: rgba(255, 69, 58, 0.1);
            border-color: rgba(255, 69, 58, 0.2);
            color: #ff6b6b;
        }
        .btn-red:hover {
            background: rgba(255, 69, 58, 0.8);
            color: white;
            box-shadow: 0 0 10px rgba(255, 69, 58, 0.4);
        }

        /* 4. åˆ›æ„æ“ä½œ (è´´å›¾/èƒŒæ™¯) - æ´»åŠ›ç´«/æ©™ */
        .btn-accent {
            background: rgba(191, 90, 242, 0.1);
            border-color: rgba(191, 90, 242, 0.3);
            color: #e0aaff;
        }
        .btn-accent:hover {
            background: rgba(191, 90, 242, 0.7);
            color: white;
            box-shadow: 0 0 15px rgba(191, 90, 242, 0.3);
        }

        /* åˆ†éš”çº¿ç¾åŒ– */
        .toolbar-separator {
            width: 1px;
            height: 24px;
            background: linear-gradient(to bottom, transparent, rgba(255,255,255,0.2), transparent);
            margin: 0 8px;
        }


        /* --- æ ‡å°ºåŒºåŸŸ --- */
        #ruler-container {
            display: flex;
            height: 32px; /* æ›´ç´§å‡‘ */
            background: rgba(20, 20, 20, 0.8);
            border-bottom: 1px solid var(--glass-border);
            flex-shrink: 0;
            z-index: 30;
        }

        #ruler-header-spacer {
            width: 250px;
            background: transparent;
            border-right: 1px solid var(--glass-border);
            flex-shrink: 0;
        }

        #ruler-content {
            flex: 1;
            overflow: hidden;
            position: relative;
            background: transparent;
        }

        #bar-ruler, #time-ruler {
            height: 16px;
            position: relative;
            font-size: 9px;
            font-family: "SF Mono", "Menlo", monospace;
            color: var(--text-muted);
            pointer-events: none;
        }
        #bar-ruler { border-bottom: 1px solid rgba(255,255,255,0.05); color: #aaa; }

        .ruler-mark {
            position: absolute; top: 0; bottom: 0;
            border-left: 1px solid rgba(255,255,255,0.15);
            padding-left: 4px; line-height: 16px;
        }
        .ruler-mark.major { border-left-color: rgba(255,255,255,0.4); font-weight: 600; }

        /* --- è½¨é“åŒºåŸŸ --- */
        #tracks-area {
            flex: 1;
            overflow: hidden;
            position: relative;
            display: flex;
            background: rgba(0,0,0,0.3);
        }

        /* å·¦ä¾§è½¨é“å¤´ */
        #track-headers {
            width: 250px;
            background: var(--glass-panel);
            backdrop-filter: blur(10px);
            border-right: 1px solid var(--glass-border);
            flex-shrink: 0;
            z-index: 5;
            overflow: hidden;
        }

        .track-header {
            height: 64px;
            border-bottom: 1px solid var(--glass-border);
            padding: 0 16px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            background: transparent;
            transition: background 0.2s;
        }
        .track-header.selected {
            background: rgba(255, 255, 255, 0.08) !important;
            border-left: 2px solid var(--accent-blue);
        }

        .track-name {
            font-size: 13px; font-weight: 600; color: var(--text-main);
            margin-bottom: 6px; letter-spacing: 0.02em;
        }

        .track-controls { display: flex; align-items: center; gap: 6px; }

        /* è½¨é“å°æŒ‰é’® (M/S) */
        .btn-sm {
            width: 22px; height: 22px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.3);
            color: #888;
            font-size: 9px; font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-sm:hover { border-color: rgba(255,255,255,0.3); color: #fff; }

        .mute-btn.active-mute { background: var(--accent-red); color: white; border-color: transparent; box-shadow: 0 0 8px rgba(255, 69, 58, 0.4); }
        .solo-btn.active-solo { background: var(--accent-yellow); color: black; border-color: transparent; box-shadow: 0 0 8px rgba(255, 214, 10, 0.4); }

        /* é¢œè‰²é€‰æ‹©å™¨ç¾åŒ– */
        input[type="color"] {
            -webkit-appearance: none; border: none;
            width: 18px; height: 18px; padding: 0;
            background: none; cursor: pointer; border-radius: 50%; overflow: hidden;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 1px solid rgba(255,255,255,0.3); border-radius: 50%; }

        /* --- ç¼–ç»„æŒ‡ç¤ºæ¡ --- */
        .group-indicator {
            position: absolute; left: 0; top: 0; bottom: 0; width: 4px;
        }

        /* --- å³ä¾§æ—¶é—´è½´ --- */
        #timeline-lanes {
            flex: 1;
            position: relative;
            overflow: scroll;
            background: #111; /* æ·±è‰²èƒŒæ™¯å‡å°‘è§†è§‰ç–²åŠ³ */
            background-image: radial-gradient(#222 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .track-lane {
            height: 64px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            position: relative;
            /* æ–‘é©¬çº¹èƒŒæ™¯ */
            background-image: linear-gradient(to bottom, rgba(255,255,255,0.01), transparent);
        }

        .grid-lines {
            position: absolute; inset: 0; pointer-events: none;
            background-image: linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
            z-index: 0;
        }

        /* --- Clip (éŸ³ç¬¦å—) --- */
        .clip {
            position: absolute; top: 6px; height: 52px;
            background: rgba(10, 132, 255, 0.25);
            border: 1px solid rgba(10, 132, 255, 0.6);
            border-radius: 6px; /* åœ†è§’çŸ©å½¢ */
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            cursor: grab; overflow: hidden;
            backdrop-filter: blur(4px);
        }
        .clip:active { cursor: grabbing; border-color: #fff; }
        .clip-name {
            padding: 4px 6px; font-size: 10px; font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8); pointer-events: none; z-index: 2;
        }

        /* æ’­æ”¾æŒ‡é’ˆ */
        #ruler-playhead, #ui-playhead {
            position: absolute; top: 0; bottom: 0; width: 1px;
            background: var(--accent-red);
            z-index: 100; pointer-events: none;
            box-shadow: 0 0 4px rgba(255, 69, 58, 0.8);
        }
        #ruler-playhead::after {
            content: ''; position: absolute; top: 0; left: -5px;
            border-left: 5px solid transparent; border-right: 5px solid transparent;
            border-top: 8px solid var(--accent-red);
        }

        /* --- è°ƒæ•´æŠŠæ‰‹ (Resize Handle) --- */
        #resize-handle {
            height: 14px; /*æŠŠæ‰‹åŒºåŸŸé«˜åº¦*/
            background: #000; /* åˆ†å‰²çº¿é¢œè‰² */
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: row-resize; /* é¼ æ ‡æ ·å¼å˜æˆä¸Šä¸‹ç®­å¤´ */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0; /* é˜²æ­¢è¢«æŒ¤å‹ */
            z-index: 60; /* ç¡®ä¿åœ¨æœ€ä¸Šå±‚ */
            transition: background 0.2s;
        }

        #resize-handle:hover {
            background: #111; /* æ‚¬åœç¨å¾®å˜äº® */
        }

        /* æ¨¡ä»¿ iPhone å°ç™½æ¡ */
        .handle-bar {
            width: 180px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            transition: all 0.2s;
        }

        #resize-handle:hover .handle-bar {
            background: rgba(255, 255, 255, 0.6); /* æ‚¬åœé«˜äº® */
            width: 220px; /* æ‚¬åœå˜é•¿ä¸€ç‚¹ç‚¹ï¼Œå¢åŠ äº¤äº’æ„Ÿ */
            height: 5px;
        }

        /* æ‹–æ‹½æ—¶ç¦æ­¢é¡µé¢é€‰ä¸­æ–‡å­— */
        body.resizing {
            user-select: none;
            cursor: row-resize;
        }

        /* --- ä¸‹åŠéƒ¨åˆ†å¯è§†åŒ–åŒºåŸŸ --- */
        #visualizer-section {
            flex: 1;
            background: radial-gradient(circle at center, #1b2735 0%, #000000 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 20px 40px -20px rgba(0,0,0,1); /* é¡¶éƒ¨å†…é˜´å½±è¡”æ¥ */
        }

        #viz-overlay {
            position: absolute; top: 16px; right: 20px;
            color: rgba(255,255,255,0.3); font-size: 11px;
            background: rgba(0,0,0,0.4); padding: 8px 12px; border-radius: 20px;
            backdrop-filter: blur(10px); pointer-events: none;
        }

        /* --- åº•éƒ¨æ§åˆ¶æ  (Glass Bar) --- */
        #bottom-controls {
            height: 64px;
            background: rgba(28, 28, 30, 0.85); /* æ·±è‰²åŠé€æ˜ */
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border-top: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 32px;
            padding: 0 20px;
            flex-shrink: 0;
            z-index: 50;
        }

        .slider-group {
            display: flex; align-items: center; gap: 10px;
            font-size: 11px; font-weight: 500; color: var(--text-muted);
        }
        .slider-group > span {
            min-width: 60px;
            text-align: right;
        }

        /* --- é‡å†™ Range Slider (macOS é£æ ¼) --- */
        input[type=range] {
            -webkit-appearance: none;
            width: 120px;
            background: transparent;
        }

        /* è½¨é“ (Track) */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }

        /* æ»‘å— (Thumb) */
        input[type=range]::-webkit-slider-thumb {
            height: 16px; width: 16px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -6px; /* å‚ç›´å±…ä¸­ */
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
            transition: transform 0.1s;
        }
        input[type=range]:focus::-webkit-slider-thumb {
            transform: scale(1.1);
            box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.1);
        }

        /* åº•éƒ¨ Select ä¸‹æ‹‰æ¡† */
        #bottom-controls select {
            background-color: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 11px;
            outline: none;
            cursor: pointer;
        }
        #bottom-controls select:hover { background-color: rgba(255,255,255,0.15); }

        /* --- æ–°å¢ï¼šé«˜çº§å‚æ•°è¾“å…¥æ¡†æ ·å¼ --- */
        .param-box {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 6px 10px;
            margin-bottom: 8px;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
        }

        /* --- è¦†ç›–ï¼šç§»é™¤æ‰€æœ‰å½©è‰²çº¿æ¡ï¼Œå›å½’æç®€ --- */
        .param-box[class*="theme-"] {
            border-left-width: 0 !important;   /* å»æ‰å·¦ä¾§çº¿æ¡å®½åº¦ */
            border-left-style: none !important; /* å»æ‰çº¿æ¡æ ·å¼ */
            box-shadow: none !important;        /* å»æ‰ä»»ä½•é˜´å½± */
            background: rgba(0, 0, 0, 0.3);     /* ä¿æŒå’Œå…¶ä»–ç›’å­ä¸€æ ·çš„æ·±è‰²èƒŒæ™¯ */
            padding-left: 10px !important;      /* æ¢å¤é»˜è®¤å†…è¾¹è· */
        }

        /* é¼ æ ‡æ‚¬åœæ—¶çš„é€šç”¨å¾®äº¤äº’ */
        .param-box:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
        }

        /* é€‰ä¸­æ—¶é«˜äº®è¾¹æ¡† */
        .param-box:focus-within {
            border-color: var(--accent-blue);
            background: rgba(0, 0, 0, 0.5);
            box-shadow: 0 0 10px rgba(10, 132, 255, 0.1);
        }

        .param-label {
            font-size: 10px;
            color: #888;
            margin-bottom: 2px;
            font-weight: 500;
        }

        .param-input {
            background: transparent;
            border: none;
            color: #fff; /* æ–‡å­—ç™½è‰² */
            font-family: "SF Mono", "Menlo", monospace; /* ç­‰å®½å­—ä½“ï¼Œæ•°å­—æ›´å¥½çœ‹ */
            font-size: 14px;
            font-weight: 600;
            width: 100%;
            outline: none;
            padding: 0;
        }

        /* é’ˆå¯¹ input type=number éšè—é»˜è®¤çš„ä¸Šä¸‹ç®­å¤´ï¼Œä¿æŒç¾è§‚ */
        .param-input::-webkit-inner-spin-button,
        .param-input::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* --- Modals (iOS å¼¹çª—é£æ ¼) --- */
        .modal-content {
            background: rgba(30, 30, 30, 0.85) !important;
            backdrop-filter: blur(30px);
            -webkit-backdrop-filter: blur(30px);
            border-radius: 16px !important;
            border: 1px solid rgba(255,255,255,0.1) !important;
            box-shadow: 0 20px 50px rgba(0,0,0,0.6) !important;
            color: var(--text-main);
            width: 340px !important;
            padding: 24px !important;
        }

        .modal-content h3 {
            font-weight: 600; font-size: 18px; margin-bottom: 20px;
            text-align: center; color: #fff;
        }

        .form-group label { color: var(--text-muted); font-size: 11px; margin-bottom: 6px; display: block; }
        .form-group select, .form-group input[type="text"] {
            width: 100%;
            background: rgba(0,0,0,0.3) !important;
            border: 1px solid rgba(255,255,255,0.1) !important;
            border-radius: 8px !important;
            padding: 10px !important;
            color: #fff !important;
            font-size: 13px;
            outline: none;
        }
        .form-group select:focus, .form-group input:focus {
            border-color: var(--accent-blue) !important;
            background: rgba(0,0,0,0.5) !important;
        }

        .modal-buttons { gap: 12px !important; margin-top: 24px !important; }
        .modal-buttons .btn { flex: 1; padding: 10px; border-radius: 8px; font-size: 13px; }

        #context-menu {
            position: fixed; /* ğŸ”¥ å…³é”®ä¿®å¤ï¼šå¿…é¡»æ˜¯å›ºå®šå®šä½ï¼Œtop/left æ‰ä¼šç”Ÿæ•ˆ */
            display: none;   /* é»˜è®¤éšè— */
            z-index: 10000;  /* ç¡®ä¿åœ¨æœ€ä¸Šå±‚ï¼Œé®æŒ¡ä½è½¨é“ */

            background: rgba(30,30,30,0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 6px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .menu-item {
            border-radius: 6px; padding: 6px 12px; font-size: 12px;
        }
        .menu-item:hover { background: var(--accent-blue); color: #fff; }

        /* --- Logo æ ·å¼ (ä¸Šä¸‹ä¸¤è¡Œç‰ˆ) --- */
        #app-logo {
            display: flex;
            align-items: center; /* å‚ç›´å±…ä¸­æ•´ä¸ª Logo å— */
            gap: 8px;            /* Logo å’Œç‰ˆæœ¬å·ä¹‹é—´çš„é—´è· */
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 6px;
            transition: opacity 0.2s;
            user-select: none;
            text-decoration: none;
            height: 100%;        /* å æ»¡å·¥å…·æ é«˜åº¦ */
        }

        #app-logo:hover {
            opacity: 0.8;
        }

        /* æ–°å¢ï¼šæ–‡å­—å®¹å™¨ï¼Œè´Ÿè´£å‚ç›´æ’åˆ—å’Œå±…ä¸­ */
        .logo-wrapper {
            display: flex;
            flex-direction: column; /* å‚ç›´å †å  */
            align-items: center;    /* æ°´å¹³å±…ä¸­ */
            justify-content: center;
            line-height: 1.0;       /* ç´§å‡‘è¡Œé«˜ */
        }

        .logo-text {
            font-family: 'Chango', sans-serif;
            font-weight: 400;

            /* æ¸å˜æ–‡å­—æ•ˆæœ */
            background: linear-gradient(to bottom, #ffffff 30%, #9ca3af 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        /* ä¸Šé¢çš„å¤§å­— MIDI */
        .title-main {
            font-size: 18px;
            letter-spacing: 0.1em;
        }

        /* ä¸‹é¢çš„å°å­— Visualizer */
        .title-sub {
            font-size: 10px;
            letter-spacing: 0.15em; /* å­—é—´è·ç¨å¾®æ‹‰å®½ï¼Œä¸ä¸Šé¢å¯¹é½ */
            opacity: 0.9;
        }

        .version-tag {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            font-size: 9px;
            background: var(--accent-blue);
            color: white;
            padding: 1px 4px;
            border-radius: 4px;
            font-weight: 600;
            align-self: center; /* è®©ç‰ˆæœ¬å·ç¨å¾®é ä¸Šä¸€ç‚¹ï¼Œæˆ–è€… center å±…ä¸­ */
            margin-top: 4px;        /* å¾®è°ƒä½ç½® */
        }

        .version-tag {
            font-size: 9px;
            background: var(--accent-blue);
            color: white;
            padding: 1px 4px;
            border-radius: 4px;
            font-weight: 600;
        }

        /* Loading é®ç½© */
        #loading {
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(10px);
            font-size: 16px; font-weight: 500; letter-spacing: 1px;
        }

        body.global-drag-over::after {
            content: 'ğŸ“‚ é‡Šæ”¾ä»¥å¯¼å…¥æ–‡ä»¶ (MIDI / Audio / Image / Video / JSON)';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            border: 4px dashed var(--accent-blue);
            backdrop-filter: blur(5px);
            z-index: 99999;
            pointer-events: none; /* è®©é¼ æ ‡äº‹ä»¶ç©¿é€ï¼Œé˜²æ­¢é—ªçƒ */

            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 24px;
            font-weight: 600;
            box-sizing: border-box;
        }

        #canvas-wrapper.recording-mode {
            /* å¼ºåˆ¶ wrapper ä¿æŒåŸæœ‰å¤§å°ï¼Œä¸è¢«å­å…ƒç´ æ’‘å¼€ */
            pointer-events: auto !important; /* ğŸ”¥ å·²å¼€å¯äº¤äº’ï¼šå…è®¸å½•åˆ¶æ—¶æ‹–æ‹½è§†è§’å’Œè°ƒæ•´å‚æ•° */
        }

        #canvas-wrapper.recording-mode canvas {
            /* æ ¸å¿ƒä¿®å¤ï¼šå³ä½¿ Canvas ç‰©ç†åˆ†è¾¨ç‡æ˜¯ 4Kï¼Œ
               åœ¨å±å¹•ä¸Šä¹Ÿå¼ºåˆ¶ç¼©æ”¾åˆ° wrapper çš„å¤§å° */
            width: 100% !important;
            height: 100% !important;

            /* ä¿æŒæ¯”ä¾‹ï¼Œé˜²æ­¢ 9:16 å½•åˆ¶æ—¶ç”»é¢è¢«æ‹‰ä¼¸å˜å½¢ */
            object-fit: contain;
        }

        /* --- ä¿®å¤å½•åˆ¶çŠ¶æ€æ ä½ç½® --- */
        #recording-status {
            position: fixed;

            /* ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šä» top æ”¹ä¸º bottom */
            top: auto;          /* å¿…é¡»é‡ç½® topï¼Œå¦åˆ™å¯èƒ½å†²çª */
            bottom: 80px;       /* 64px(æ§åˆ¶æ é«˜) + 16px(é—´éš™) */

            left: 50%;
            transform: translateX(-50%); /* æ°´å¹³å±…ä¸­ */
            z-index: 9999;

            /* ä¿æŒåŸæœ‰çš„å¤–è§‚æ ·å¼ */
            background: rgba(0,0,0,0.7) !important;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1) !important;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            padding: 8px 16px !important;
            font-variant-numeric: tabular-nums;
            border-radius: 20px;

            display: none; /* JS ä¼šæ§åˆ¶å®ƒçš„æ˜¾ç¤º */
            align-items: center;
            color: white;
            pointer-events: auto; /* å…è®¸ç‚¹å‡»åœæ­¢æŒ‰é’® */
        }

        #export-modal {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7); /* åŠé€æ˜é»‘èƒŒæ™¯ */
            z-index: 5000; /* ä¿è¯åœ¨æœ€é¡¶å±‚ */

            /* Flex å±…ä¸­ä¸‰ä»¶å¥— */
            display: none; /* é»˜è®¤éšè—ï¼ŒJS ä¼šæ”¹ä¸º flex */
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px); /* èƒŒæ™¯æ¨¡ç³Šæ›´æ˜¾é«˜çº§ */
        }

        #model-preview-modal .modal-content {
            width: 900px !important;    /* å¼ºåˆ¶å˜å®½ */
            max-width: 95vw !important; /* é˜²æ­¢è¶…å‡ºå°å±å¹• */
            height: 700px !important;   /* å¢åŠ é«˜åº¦ */
            padding: 0 !important;      /* æ¨¡å‹çª—å£ä¸éœ€è¦å†…è¾¹è·ï¼Œå› ä¸ºå†…éƒ¨æœ‰å¸ƒå±€ */
            display: flex !important;
            flex-direction: column !important;
        }

        /* --- é‡æ„åçš„ iOS å¼€å…³æ ·å¼ (Fixed) --- */
        .ios-switch {
            position: relative;
            display: inline-block;
            width: 40px;  /* ä½ å¯ä»¥åœ¨è¿™é‡Œéšæ„ä¿®æ”¹å®½åº¦ï¼Œä¾‹å¦‚æ”¹æˆ 40px */
            height: 18px;
            vertical-align: middle;
            margin-left: 8px;

            /* å¦‚æœä½ å¸Œæœ›å®ƒèƒ½éšçˆ¶å®¹å™¨æŒ¤å‹è€Œç¼©å°ï¼Œè¯·æ³¨é‡Šæ‰ä¸‹é¢è¿™è¡Œï¼›
               ä½†é€šå¸¸å»ºè®®ä¿ç•™å®ƒï¼Œä»¥å…å¼€å…³å˜å½¢ */
            flex-shrink: 0;
        }

        /* éšè—åŸå§‹ Checkbox */
        .ios-switch input {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
            margin: 0;
        }

        /* è½¨é“ (èƒŒæ™¯) */
        .ios-switch .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0; /* è¿™é‡Œçš„ left/right:0 ç¡®ä¿äº† slider æ°¸è¿œå¡«æ»¡çˆ¶å®¹å™¨ */
            background-color: rgba(255, 255, 255, 0.2);
            transition: background-color 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-sizing: border-box; /* ç¡®ä¿è¾¹æ¡†åŒ…å«åœ¨å°ºå¯¸å†… */
        }

        /* æ—‹é’® (åœ†çƒ) */
        .ios-switch .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;

            /* åˆå§‹çŠ¶æ€ï¼šé å·¦ */
            left: 1px;
            bottom: 1px;

            background-color: white;
            /* æ”¹ç”¨ left å±æ€§è¿›è¡Œè¿‡æ¸¡ï¼Œæˆ–è€…ä½¿ç”¨ calc é…åˆ transform */
            transition: left 0.3s cubic-bezier(0.4, 0.0, 0.2, 1), transform 0.3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* é€‰ä¸­çŠ¶æ€ - è½¨é“å˜è‰² */
        .ios-switch input:checked + .slider {
            background-color: var(--accent-green);
            border-color: transparent;
        }

        /* é€‰ä¸­çŠ¶æ€ - æ—‹é’®ç§»åŠ¨ (æ ¸å¿ƒä¿®å¤) */
        .ios-switch input:checked + .slider:before {
            /* æ—§ä»£ç : transform: translateX(44px); -> é”™è¯¯ï¼Œä¼šé£å‡ºå»
               æ–°ä»£ç : ç›´æ¥è®©ä»–è·‘åˆ°å³è¾¹ï¼Œå‡å»çƒå®½(14px)å’Œå³è¾¹è·(1px)
            */
            left: calc(100% - 15px); /* 100% - çƒå®½14px - è¾¹è·1px */

            /* ç§»é™¤ translateXï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»ç”¨ left é‡æ–°å®šä½äº† */
            transform: none;
        }

        /* è‰²å—æ ·å¼ */
        .color-swatch {
            width: 80%;
            aspect-ratio: 1; /* æ­£æ–¹å½¢ */
            border-radius: 50%; /* <-- æ”¹ä¸º 50% å³ä¸ºåœ†å½¢ */
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s, border-color 0.1s;
            position: relative;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            z-index: 2;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        .color-swatch.active {
            border-color: #fff;
            box-shadow: 0 0 0 2px var(--accent-blue); /* åŒé‡è¾¹æ¡†é€‰ä¸­æ•ˆæœ */
        }

        /* éšè—åŸç”Ÿçš„é¢œè‰²è¾“å…¥æ¡†ï¼Œä½†ä¿ç•™ç‚¹å‡»åŒºåŸŸï¼ˆå¦‚æœéœ€è¦çš„è¯ï¼Œæˆ–è€…ç›´æ¥ç§»é™¤ï¼‰ */
        .color-trigger-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.3);
            cursor: pointer;
        }

    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@tonejs/midi": "https://esm.sh/@tonejs/midi"
            }
        }
    </script>
</head>
<body>

<div id="context-menu">
    <div class="menu-item" id="menu-group">ç¼–ç»„é€‰ä¸­è½¨é“</div>
    <div class="menu-item" id="menu-ungroup">è§£æ•£ç¼–ç»„</div>
    <div class="menu-separator"></div>
    <div class="menu-item" id="menu-color">
        è®¾ç½®ç¼–ç»„é¢œè‰²
    </div>
</div>

<div id="loading" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; justify-content: center; align-items: center; color: white;">
    Loading...
</div>

<div id="export-modal" style="display:none;">
    <div class="modal-content">
        <h3>å¯¼å‡ºè§†é¢‘è®¾ç½®ï¼ˆå®é™…å¸§ç‡å—æ€§èƒ½å½±å“ï¼‰</h3>

        <div class="form-group">
            <label>ç”»é¢æ¯”ä¾‹ (Aspect Ratio)</label>
            <select id="exportRatio">
                <option value="1.7777">16:9 (æ¨ªå±)</option>
                <option value="0.5625">9:16 (ç«–å± Shorts/TikTok)</option>
                <option value="1.3333">4:3</option>
                <option value="1.0">1:1 (Square)</option>
            </select>
        </div>

        <div class="form-group">
            <label>åˆ†è¾¨ç‡ (Resolution)</label>
            <select id="exportRes">
                <option value="720">720p (HD)</option>
                <option value="1080">1080p (FHD)</option>
                <option value="1440">1440p (QHD)</option>
                <option value="2160">4K (UHD)</option>
            </select>
        </div>

        <div class="form-group">
            <label>å¸§ç‡ (FPS)</label>
            <select id="exportFps">
                <option value="30">30 FPS</option>
                <option value="60" selected>60 FPS</option>
            </select>
        </div>

        <div class="form-group">
            <label>æ ¼å¼ (Format)</label>
            <select id="exportFormat">
            </select>
        </div>

        <div class="modal-buttons">
            <button class="btn" id="cancelExportBtn">å–æ¶ˆ</button>
            <button class="btn btn-primary" id="startExportBtn">å¼€å§‹å½•åˆ¶</button>
        </div>
        <p style="font-size:10px; color:#aaa; margin-top:10px;">
            æ³¨æ„ï¼šå½•åˆ¶æœŸé—´è¯·å‹¿åˆ‡æ¢æ ‡ç­¾é¡µï¼Œè¿™é€šè¿‡å®æ—¶å½•å±å®ç°ã€‚
        </p>
    </div>
</div>

<div id="save-project-modal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 3000; justify-content: center; align-items: center;">
    <div class="modal-content" style="background: #2a2a2a; padding: 20px; border-radius: 8px; width: 300px; border: 1px solid #444;">
        <h3 style="margin-top:0;">ä¿å­˜å·¥ç¨‹</h3>
        <div class="form-group">
            <label>å·¥ç¨‹åç§°</label>
            <input type="text" id="project-name-input" placeholder="è¾“å…¥åç§°..." style="width: 100%; background: #111; color: #fff; border: 1px solid #444; padding: 8px; border-radius: 4px; box-sizing: border-box;">
        </div>
        <div class="modal-buttons" style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
            <button class="btn" id="cancelSaveBtn">å–æ¶ˆ</button>
            <button class="btn btn-primary" id="confirmSaveBtn">ä¸‹è½½ JSON</button>
        </div>
    </div>
</div>

<div id="recording-status" style="display:none;">
    <div style="background:red; width:10px; height:10px; border-radius:50%; margin-right:10px; animation: blink 1s infinite;"></div>
    <span id="rec-time">00:00</span> / <span id="rec-total">00:00</span>
    <button class="btn" id="stopRecBtn" style="margin-left:15px; background:#333;">åœæ­¢</button>
</div>

<div id="daw-container">
    <div id="toolbar">
        <div id="app-logo" title="ç‚¹å‡»æŸ¥çœ‹ç‰ˆæœ¬æ›´æ–°">
            <div class="logo-wrapper">
                <span class="logo-text title-main">MIDI</span>
                <span class="logo-text title-sub">Visualizer</span>
            </div>
            <span class="version-tag">v1.5.2</span>
        </div>

        <div class="toolbar-separator"></div>

        <button class="btn btn-blue" id="playBtn" style="border-color: rgba(48, 209, 88, 0.4); background: rgba(48, 209, 88, 0.1); color: #30d158;">
            PLAY
        </button>
        <button class="btn btn-red" id="stopBtn">STOP</button>

        <div class="toolbar-separator"></div>

        <button class="btn btn-primary" id="showExportBtn">âœ¨ å¯¼å‡ºè§†é¢‘</button>

        <div class="toolbar-separator"></div>

        <button class="btn btn-blue" id="saveProjectBtn">ä¿å­˜å·¥ç¨‹</button>
        <button class="btn btn-blue" id="loadProjectBtn">è¯»å–å·¥ç¨‹</button>
        <input type="file" id="projectInput" accept=".json" style="display:none">

        <div class="toolbar-separator"></div>

        <button class="btn" id="btn-midi">å¯¼å…¥ MIDI</button>
        <input type="file" id="midiInput" accept=".mid,.midi" style="display:none">

        <button class="btn" id="btn-audio">å¯¼å…¥ Audio</button>
        <input type="file" id="audioInput" accept="audio/*" style="display:none">

        <div class="toolbar-separator"></div>

        <button class="btn btn-accent" id="btn-bg">è®¾ç½®èƒŒæ™¯</button>
        <input type="file" id="bgInput" accept="image/*,video/*" style="display:none">

        <button class="btn" id="bgSettingsBtn" style="padding: 0 8px;" title="èƒŒæ™¯å‚æ•°è®¾ç½®">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
        </button>

        <button class="btn btn-accent" id="btn-highlight-color">
            é«˜å…‰æ ·å¼
        </button>

        <button class="btn" id="viewSettingsBtn">è§†è§’å‚æ•°</button>

        <button class="btn btn-red" id="clearTextureBtn" style="font-size:11px; padding: 4px 8px; height: 26px;">æ¸…é™¤</button>
    </div>

    <div id="ruler-container">
        <div id="ruler-header-spacer"></div>

        <div id="ruler-content">
            <div id="ruler-playhead"></div>
            <div id="bar-ruler"></div>
            <div id="time-ruler"></div>
        </div>
    </div>

    <div id="tracks-area">
        <div id="track-headers"></div>

        <div id="timeline-lanes">
            <div id="lanes-container">
                <div class="grid-lines" id="gridLines"></div>
                <div id="ui-playhead"></div>
            </div>
        </div>

    </div>
</div>

<div id="resize-handle">
    <div class="handle-bar"></div>
</div>

<div id="visualizer-section">
    <div id="canvas-wrapper">
        <div id="shortcut-overlay" style="
            position: absolute;
            top: 16px;
            left: 20px; /* ğŸ“ è¿™é‡Œè®¾ä¸º leftï¼Œä¸å³è¾¹çš„ right:20px å¯¹ç§° */
            background: rgba(0,0,0,0.7);
            padding: 14px;
            border-radius: 8px;
            backdrop-filter: blur(8px);
            pointer-events: none; /* è®©é¼ æ ‡ç©¿é€ï¼Œä¸å½±å“æ“ä½œ */
            border: 1px solid rgba(255,255,255,0.1);
            font-family: 'SF Mono', 'Menlo', monospace;
            font-size: 11px;
            line-height: 1.6;
            color: #ddd;
            z-index: 100;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        ">
            <div id="shortcut-header" style="font-weight:700; color:#fff; border-bottom:1px solid rgba(255,255,255,0.2); margin-bottom:8px; padding-bottom:4px; cursor: pointer; pointer-events: auto;">
                å¿«æ·é”®æŒ‡å—ï¼ˆç‚¹å‡»æŠ˜å ï¼‰
            </div>

            <div id="shortcut-content" style="display: grid; grid-template-columns: 1fr auto; gap: 4px 20px;">
                <span style="color:#aaa;">æ’­æ”¾ / æš‚åœ</span>      <span style="color:#30d158; font-weight:700;">Space</span>
                <span style="color:#aaa;">Solo / Mute</span>      <span style="color:#30d158; font-weight:700;">S / M</span>
                <span style="color:#aaa;">åˆ é™¤è½¨é“</span>        <span style="color:#ff453a;">Del / Backspace</span>
                <span style="color:#aaa;">æ’¤é”€æ“ä½œ</span>        <span style="color:#0a84ff;">Ctrl/Cmd + Z</span>
                <span style="color:#aaa;">é‡åšæ“ä½œ</span>        <span style="color:#0a84ff;">Ctrl/Cmd + Shift + Y</span>
                <span style="color:#aaa;">ä¿å­˜å·¥ç¨‹</span>        <span style="color:#ffd60a;">Ctrl/Cmd + S</span>
                <span style="color:#aaa;">å¦å­˜å·¥ç¨‹</span>        <span style="color:#ffd60a;">Ctrl/Cmd + Shift + S</span>

                <div style="grid-column: span 2; height:1px; background:rgba(255,255,255,0.1); margin:4px 0;"></div>

                <span style="color:#aaa;">è§†è§’å¹³ç§»</span>        <span style="color:#bf5af2;">Ctrl/Cmd + æ‹–æ‹½</span>
                <span style="color:#aaa;">è§†è§’é‡ç½®</span>        <span style="color:#bf5af2;">Ctrl/Cmd + åŒå‡»</span>
                <span style="color:#aaa;">å¤šé€‰ / è¿é€‰</span>      <span>Ctrl / Shift</span>
            </div>
        </div>

        <div id="viz-overlay" style="
    position: absolute;
    top: 16px;
    right: 20px;
    background: rgba(0,0,0,0.7); /* ç¨å¾®åŠ æ·±èƒŒæ™¯æé«˜å¯¹æ¯”åº¦ */
    padding: 14px;
    border-radius: 8px;
    backdrop-filter: blur(8px);
    pointer-events: none;
    border: 1px solid rgba(255,255,255,0.1);
    font-family: 'SF Mono', 'Menlo', monospace;
    font-size: 11px;
    line-height: 1.8; /* å¢åŠ è¡Œé«˜ï¼Œå‚ç›´æ’åˆ—ä¸æ‹¥æŒ¤ */
    color: #ddd;
    min-width: 160px; /* ç¨å¾®å˜çª„ï¼Œå› ä¸ºä¸éœ€è¦æ¨ªå‘æ’å¸ƒäº† */
    z-index: 100;
    text-shadow: 0 1px 2px rgba(0,0,0,0.8);
">
            <div id="viz-header" style="font-weight:700; color:#fff; border-bottom:1px solid rgba(255,255,255,0.2); margin-bottom:8px; padding-bottom:4px; display:flex; justify-content:space-between; cursor: pointer; pointer-events: auto;">
                <span>è§†è§’å‚æ•°ï¼ˆç‚¹å‡»æŠ˜å ï¼‰</span>
                <span style="color:#0a84ff;">â— å®æ—¶</span>
            </div>

            <div id="viz-content">

                <div style="display:flex; justify-content:space-between;">
                    <span style="color:#aaa;">ç›¸æœºè·ç¦» (Zoom)</span>
                    <span id="hud-radius" style="color:#fff; font-weight:bold;">--</span>
                </div>

                <div style="margin:6px 0; border-top:1px dashed rgba(255,255,255,0.1);"></div>

                <div style="color:#0a84ff; font-weight:600; margin-bottom:2px;">è§†è§’æ—‹è½¬ (Rotation)</div>
                <div style="display:flex; justify-content:space-between; padding-left:8px;">
                    <span style="color:#888;">æ°´å¹³ (Î¸)</span>
                    <span id="hud-theta" style="color:#ff6b6b;">0Â°</span>
                </div>
                <div style="display:flex; justify-content:space-between; padding-left:8px;">
                    <span style="color:#888;">å‚ç›´ (Ï†)</span>
                    <span id="hud-phi" style="color:#30d158;">0Â°</span>
                </div>

                <div style="margin:6px 0; border-top:1px dashed rgba(255,255,255,0.1);"></div>

                <div style="color:#30d158; font-weight:600; margin-bottom:2px;">è§†è§’å¹³ç§» (Panning)</div>
                <div style="display:flex; justify-content:space-between; padding-left:8px;">
                    <span style="color:#888;">X å¹³ç§»</span>
                    <span id="hud-pan-x" style="color:#5e5ce6;">0</span>
                </div>
                <div style="display:flex; justify-content:space-between; padding-left:8px;">
                    <span style="color:#888;">Y å¹³ç§»</span>
                    <span id="hud-pan-y" style="color:#5e5ce6;">0</span>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="bottom-controls">

    <div class="slider-group">
        <span>W-Scale:</span>
        <input type="range" id="sceneZoom" min="1" max="100" value="20">
    </div>

    <div class="slider-group">
        <span>H-Scale:</span>
        <input type="range" id="heightSlider" min="1" max="600" value="150">
    </div>

    <div class="slider-group">
        <span>Thickness:</span>
        <input type="range" id="thicknessSlider" min="1" max="300" value="100">
    </div>

    <div class="slider-group">
        <span>Z-Space:</span>
        <input type="range" id="zSpaceSlider" min="0" max="200" value="5">
    </div>

    <div class="slider-group" style="margin-left: 15px; border-left: 1px solid rgba(255,255,255,0.1); padding-left: 15px;">
        <span>Stars:</span>
        <label class="ios-switch" title="æ˜¾ç¤º/éšè—æ˜Ÿç©º">
            <input type="checkbox" id="starfieldToggle" checked>
            <span class="slider"></span>
        </label>
    </div>

    <div class="slider-group">
        <span>Shape:</span>
        <select id="noteShapeSelect" style="background:#333; color:#fff; border:1px solid #555; border-radius:3px; padding:2px; max-width: 100px;">
            <option value="capsule" selected>Capsule (Default)</option>
            <option value="box">Box (Cube)</option>
            <option value="box-line">Box (Outlined)</option>
            <option value="cylinder">Cylinder</option>
            <option value="diamond">Diamond</option>
            <option value="hexagon">Hexagon</option>
            <option value="torus">Donut (Torus)</option>
            <option value="knot">Torus Knot</option>
            <option value="cone">Cone (Spike)</option>
            <option value="custom">Custom (.glb)...</option>
        </select>

        <input type="file" id="customModelInput" accept=".glb,.gltf" style="display: none;">
    </div>

    <button id="resetViewBtn" class="btn" style="margin-left: 15px; height: 24px; line-height: 1;">â†º é‡ç½®å‚æ•°</button>

</div>

<div id="bg-settings-modal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 3000; justify-content: center; align-items: center;">
    <div class="modal-content" style="background: #2a2a2a; padding: 20px; border-radius: 8px; width: 320px; border: 1px solid #444; box-shadow: 0 0 20px rgba(0,0,0,0.8);">
        <h3 style="margin-top:0; border-bottom:1px solid #444; padding-bottom:10px;">èƒŒæ™¯å‚æ•°è®¾ç½®</h3>

        <div class="form-group">
            <label>ä¸é€æ˜åº¦ (Opacity): <span id="val-opacity">1.0</span></label>
            <input type="range" id="bg-opacity" min="0" max="1" step="0.05" value="0.6" style="width:100%">
        </div>

        <div class="form-group" style="margin-bottom: 15px;">
            <label>æ¨¡ç³Šåº¦ (Blur): <span id="val-blur">0px</span></label>
            <input type="range" id="bg-blur" min="0" max="20" step="1" value="0" style="width:100%">
        </div>

        <div class="form-group" style="margin-bottom: 15px;">
            <label>äº®åº¦ (Brightness): <span id="val-bright">100%</span></label>
            <input type="range" id="bg-brightness" min="0" max="200" step="5" value="100" style="width:100%">
        </div>

        <div class="form-group" style="margin-bottom: 15px;">
            <label>å¯¹æ¯”åº¦ (Contrast): <span id="val-contrast">100%</span></label>
            <input type="range" id="bg-contrast" min="0" max="200" step="5" value="100" style="width:100%">
        </div>

        <div class="form-group" style="margin-bottom: 15px;">
            <label>å¡«å……æ¨¡å¼ (Fit Mode)</label>
            <select id="bg-fit" style="width:100%; padding:5px; background:#111; color:#fff; border:1px solid #555;">
                <option value="cover">Cover (é“ºæ»¡è£å‰ª)</option>
                <option value="contain">Contain (å®Œæ•´æ˜¾ç¤º)</option>
                <option value="fill">Fill (æ‹‰ä¼¸é“ºæ»¡)</option>
            </select>
        </div>

        <div class="modal-buttons" style="margin-top: 20px;">
            <button class="btn btn-primary" id="closeBgSettingsBtn" style="width:100%">å…³é—­</button>
        </div>
    </div>
</div>

<div id="view-settings-modal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 3500; justify-content: center; align-items: center;">
    <div class="modal-content" style="background: #1c1c1e; padding: 24px; border-radius: 16px; width: 360px; border: 1px solid #333; box-shadow: 0 20px 60px rgba(0,0,0,0.8);">

        <h3 style="margin-top:0; margin-bottom:20px; color:#fff; font-size:16px; font-weight:600; text-align:center;">è§†è§’å‚æ•° (Spherical)</h3>

        <div class="param-box">
            <span class="param-label" style="color:#aaa;">ç›¸æœºè·ç¦» (Distance / Zoom)</span>
            <input type="number" id="cam-radius" class="param-input" step="1">
        </div>

        <div style="height:1px; background:#333; margin:20px 0;"></div>

        <div style="font-size:11px; color:#aaa; margin-bottom:8px; font-weight:600;">è§†è§’æ—‹è½¬ (Rotation)</div>
        <div style="display:flex; gap:12px;">
            <div class="param-box" style="flex:1;">
                <span class="param-label">æ°´å¹³æ—‹è½¬ (Horz Â°)</span>
                <input type="number" id="cam-theta" class="param-input" step="1">
            </div>

            <div class="param-box" style="flex:1;">
                <span class="param-label">å‚ç›´æ—‹è½¬ (Vert Â°)</span>
                <input type="number" id="cam-phi" class="param-input" step="1">
            </div>
        </div>

        <div style="height:1px; background:#333; margin:20px 0;"></div>

        <div style="font-size:11px; color:#aaa; margin-bottom:8px; font-weight:600;">è§†è§’å¹³ç§» (Panning)</div>
        <div style="display:flex; gap:12px;">
            <div class="param-box" style="flex:1;">
                <span class="param-label">X è½´åç§»</span>
                <input type="number" id="target-off-x" class="param-input" step="1" value="0">
            </div>
            <div class="param-box" style="flex:1;">
                <span class="param-label">Y è½´åç§»</span>
                <input type="number" id="target-off-y" class="param-input" step="1" value="0">
            </div>
        </div>

        <div style="display:flex; gap:12px; margin-top:12px;">
            <button class="btn" id="exportViewBtn" style="flex:1; background:rgba(255,255,255,0.1); font-size:11px; border:1px solid rgba(255,255,255,0.1);">â¬‡ å¯¼å‡ºé¢„è®¾</button>
            <button class="btn" id="importViewBtn" style="flex:1; background:rgba(255,255,255,0.1); font-size:11px; border:1px solid rgba(255,255,255,0.1);">â¬† å¯¼å…¥é¢„è®¾</button>
            <input type="file" id="viewParamInput" accept=".json" style="display:none">
        </div>

        <button class="btn" id="closeViewSettingsBtn" style="width:100%; margin-top:12px; background:transparent; border:1px solid #333; color:#888;">å…³é—­</button>
    </div>
</div>

<div id="model-preview-modal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 4000; justify-content: center; align-items: center;">
    <div class="modal-content" style="width: 800px; height: 600px; display: flex; flex-direction: column; background: #1e1e1e; padding: 0; overflow: hidden;">

        <div style="padding: 15px; background: #252525; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin:0; color: #ddd;">å¯¼å…¥æ¨¡å‹é¢„è§ˆ / è°ƒæ•´æ–¹å‘</h3>
            <span style="font-size: 12px; color: #888;">çº¢è‰²=Xè½´ (æ‹‰ä¼¸æ–¹å‘) | ç»¿è‰²=Yè½´ | è“è‰²=Zè½´</span>
        </div>

        <div style="flex: 1; display: flex; overflow: hidden;">

            <div id="preview-canvas-container" style="flex: 2; background: #111; position: relative;">
                <div style="position: absolute; bottom: 10px; left: 10px; color: rgba(255,255,255,0.5); font-size: 12px; pointer-events: none;">
                    å·¦ä¾§ï¼šåŸå§‹æ¨¡å‹ <br> å³ä¾§ï¼šæ¨¡æ‹Ÿ MIDI æ‹‰ä¼¸æ•ˆæœ
                </div>
            </div>

            <div style="flex: 1; min-width: 250px; background: #2a2a2a; padding: 20px; border-left: 1px solid #333; display: flex; flex-direction: column; gap: 20px;">

                <div class="control-group">
                    <label style="color: #aaa; font-size: 12px; display: block; margin-bottom: 5px;">æ—‹è½¬ X (Rotate X)</label>
                    <input type="range" id="rot-x" min="0" max="360" value="0" style="width: 100%;">
                </div>
                <div class="control-group">
                    <label style="color: #aaa; font-size: 12px; display: block; margin-bottom: 5px;">æ—‹è½¬ Y (Rotate Y)</label>
                    <input type="range" id="rot-y" min="0" max="360" value="0" style="width: 100%;">
                </div>
                <div class="control-group">
                    <label style="color: #aaa; font-size: 12px; display: block; margin-bottom: 5px;">æ—‹è½¬ Z (Rotate Z)</label>
                    <input type="range" id="rot-z" min="0" max="360" value="0" style="width: 100%;">
                </div>

                <div style="height: 1px; background: #444; margin: 10px 0;"></div>

                <div class="control-group">
                    <label style="color: #aaa; font-size: 12px; display: block; margin-bottom: 5px;">é¢„è§ˆé¢œè‰²</label>
                    <label style="display: flex; align-items: center; color: #fff; font-size: 12px;">
                        <input type="checkbox" id="preview-use-texture" disabled>
                        ä¿ç•™åŸæè´¨ (æš‚ä¸æ”¯æŒ Shader æ‹‰ä¼¸)
                    </label>
                    <p style="font-size: 10px; color: #666; margin-top: 5px;">
                        * å½“å‰é«˜æ€§èƒ½æ¸²æŸ“ç®¡çº¿å¼ºåˆ¶ä½¿ç”¨è½¨é“é¢œè‰²ã€‚
                    </p>
                </div>

                <div style="flex: 1;"></div> <div style="display: flex; gap: 10px;">
                <button class="btn" id="cancelPreviewBtn" style="flex: 1;">å–æ¶ˆ</button>
                <button class="btn btn-primary" id="confirmImportBtn" style="flex: 1;">ç¡®è®¤å¯¼å…¥</button>
            </div>
            </div>
        </div>
    </div>
</div>

<div id="version-modal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 6000; justify-content: center; align-items: center;">
    <div class="modal-content" style="width: 400px !important;">
        <h3 style="border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 15px;">
            MIDI Visualizer <span style="font-size: 12px; color: #888; font-weight: normal;">v1.5.2</span>
        </h3>

        <div style="height: 250px; overflow-y: auto; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; margin-bottom: 20px;">
            <p style="color: #aaa; font-size: 12px; margin-top: 0;">2026-01-16 1.5.2 (Current)</p>
            <ul style="padding-left: 20px; color: #ddd; line-height: 1.6;">
                <li>ç´§æ€¥ä¿®å¤ï¼šè§†é¢‘æ— æ³•å½•åˆ¶</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 0;">2026-01-16 1.5.1</p>
            <ul style="padding-left: 20px; color: #ddd; line-height: 1.6;">
                <li>æ–°å¢ï¼šbox-line (Outlined) éŸ³ç¬¦æ ·å¼</li>
                <li>ä¼˜åŒ–ï¼šå¢å¼ºå½•åˆ¶ç¨³å®šæ€§</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 0;">2026-01-15 1.5.0</p>
            <ul style="padding-left: 20px; color: #ddd; line-height: 1.6;">
                <li>æ–°å¢ï¼š3D æ˜Ÿç©ºèƒŒæ™¯ (Starfield)ï¼Œæ”¯æŒ UI å¼€å…³æ§åˆ¶</li>
                <li>ä¼˜åŒ–ï¼šå¿«æ·é”®æŒ‡å—ã€è§†è§’å‚æ•°æŠ˜å çŠ¶æ€è®°å¿†</li>
                <li>ä¿®å¤ï¼šWindows ç³»ç»Ÿæµè§ˆå™¨ä¸‹å˜é€Ÿ/å˜è°ƒé—®é¢˜</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 0;">2026-01-14 1.4.0</p>
            <ul style="padding-left: 20px; color: #ddd; line-height: 1.6;">
                <li>æ–°å¢ï¼šé¢œè‰²é€‰æ‹©å™¨</li>
                <li>æ–°å¢ï¼šé«˜å…‰æ ·å¼è°ƒèŠ‚</li>
                <li>æ–°å¢ï¼šå…¨å±€ ESC é”®å¯å…³é—­æ‰€æœ‰å¼¹çª—</li>
                <li>æ–°å¢ï¼šå¿«æ·é”®æç¤º</li>
                <li>ä¼˜åŒ–ï¼šå¿«æ·é”®æç¤ºä¸è§†è§’å‚æ•°æ”¯æŒæŠ˜å </li>
                <li>ä¼˜åŒ–ï¼šç»Ÿä¸€äº†é«˜å…‰æ¸²æŸ“ç®—æ³•ï¼Œç§»é™¤å¼ºåˆ¶å…‰æ™•ï¼Œæ”¯æŒæ›´å®½çš„è°ƒèŠ‚èŒƒå›´ (0-100)</li>
                <li>ä¼˜åŒ–ï¼šæ’­æ”¾åŒæ­¥é€»è¾‘ï¼Œä¿®å¤åˆ‡æ¢æ ‡ç­¾é¡µåæ’­æ”¾çº¿è·³å˜/ä¸åŒæ­¥çš„é—®é¢˜</li>
                <li>ä¿®å¤ï¼šä¿®æ­£ç¼©ç•¥å›¾ä¸è½¨é“é¢œè‰²ä¸€è‡´æ€§</li>
                <li>ä¿®å¤ï¼šåˆ é™¤è½¨é“åè°ƒèŠ‚æ»‘å—ä¼šå¯¼è‡´â€œåƒµå°¸éŸ³ç¬¦â€å¤æ´»çš„ Bug</li>
            </ul>
            <p style="color: #aaa; font-size: 12px; margin-top: 0;">2026-01-14 1.3.0</p>
            <ul style="padding-left: 20px; color: #ddd; line-height: 1.6;">
                <li>æ–°å¢ï¼šå·¦ä¸Šè§’ç‰ˆæœ¬ä¿¡æ¯æŸ¥çœ‹å…¥å£</li>
                <li>æ–°å¢ï¼šæ”¯æŒéŸ³é¢‘å¼€å¤´çš„é™éŸ³è‡ªåŠ¨å‰ªåˆ‡</li>
                <li>æ–°å¢ï¼šå·¥ç¨‹æ”¯æŒç›´æ¥ä¿å­˜å›åŸæ–‡ä»¶ (Ctrl+S / Cmd+S)</li>
                <li>æ–°å¢ï¼šå¢åŠ â€œå¦å­˜ä¸ºâ€å¿«æ·é”® (Shift + Ctrl+S / Shift+Cmd+S)</li>
                <li>ä¼˜åŒ–ï¼šèƒŒæ™¯è®¾ç½®é½¿è½®ç§»åŠ¨è‡³èƒŒæ™¯æŒ‰é’®æ—</li>
                <li>ä¼˜åŒ–ï¼šå½•åˆ¶è§†é¢‘æ”¯æŒæµå¼å†™å…¥ (ä¸å å†…å­˜)</li>
                <li>ä¼˜åŒ–ï¼šW-Scaleè°ƒæ•´èŒƒå›´</li>
                <li>ä¿®å¤ï¼šä¿®å¤æ–‡ä»¶æ‹–æ‹½å¯¼å…¥å¤±æ•ˆçš„é—®é¢˜</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 15px;">2026-01-12 1.2.1</p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>ä¿®å¤ï¼šä¿®å¤å¯¼å…¥/å¯¼å‡ºå·¥ç¨‹</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 15px;">2026-01-12 1.2.0</p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>æ–°å¢ï¼šâ€œè§†è§’å‚æ•°â€è®¾ç½®åŠŸèƒ½ï¼Œä¿è¯å¤šå·¥ç¨‹è§†è§’çš„ç»Ÿä¸€ï¼ˆå¯å¯¼å‡ºå¯¼å…¥å‚æ•°ï¼‰</li>
                <li>æ–°å¢ï¼šæ’­æ”¾åŒºåŸŸé«˜å…‰é¢œè‰²æ›´æ”¹åŠŸèƒ½ï¼ˆæ¨èäº®è‰²ï¼‰</li>
                <li>æ–°å¢ï¼šä¸Šä¸‹åŒºåŸŸè°ƒæ•´æŠŠæ‰‹</li>
                <li>ä¼˜åŒ–ï¼šæ”¯æŒMIDIã€éŸ³é¢‘ã€å›¾ç‰‡ã€è§†é¢‘ã€è§†è§’JSONã€å·¥ç¨‹JSONæ‹–åŠ¨å¯¼å…¥</li>
                <li>ä¼˜åŒ–ï¼šå¯è§†åŒ–åŒºåŸŸâ€œCommand/Control+åŒå‡»â€å¯é‡ç½®è§†è§’ï¼ŒæŒ‰ä½â€œCommand/Controlâ€æ‹–åŠ¨å¯å¹³ç§»ï¼Œæ»šè½®æ”¾å¤§ç¼©å°</li>
                <li>ä¼˜åŒ–ï¼šâ€œå¯¼å…¥æ–‡ä»¶â€çš„æ“ä½œæ”¯æŒæ’¤å›</li>
                <li>ä¼˜åŒ–ï¼šä¼˜åŒ–midiå¯¼å…¥è½¨é“çš„åŒæ­¥</li>
                <li>ä¼˜åŒ–ï¼šåˆ é™¤äº†éŸ³ç¬¦è´´å›¾å’Œtimeline zoomçš„è°ƒèŠ‚</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 15px;">2026-01-11 1.1.0</p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>æ–°å¢ï¼šåŠ å…¥Z-Spaceæ»‘å—</li>
                <li>ä¿®å¤ï¼šä¿®å¤æŸäº›æµè§ˆå™¨è°ƒè‰²ç›˜é—ªé€€é—®é¢˜</li>
            </ul>

            <p style="color: #aaa; font-size: 12px; margin-top: 15px;">2026-01-10 1.0.0</p>
            <ul style="padding-left: 20px; color: #888; line-height: 1.6;">
                <li>åŸºç¡€åŠŸèƒ½ä¸Šçº¿ï¼šMIDI/Audio å¯¼å…¥</li>
                <li>3D å¯è§†åŒ–æ¸²æŸ“å¼•æ“</li>
            </ul>
        </div>
        <div style="text-align: center; margin-bottom: 15px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); width: 100%;">
            <p style="font-size: 11px; color: #666; margin: 0; line-height: 1.6;">
                Open Source Project<br>
                <span style="color: #888; font-weight: 500;">Author: Jay Chan</span><br>
                <span style="color: #666; font-size: 10px;">Email: 3119929945@qq.com</span>
            </p>
        </div>

        <div class="modal-buttons" style="display: flex; justify-content: center; width: 100%; margin-top: 0;">
            <button class="btn btn-primary" id="closeVersionBtn" style="flex: 1;">å…³é—­</button>
        </div>

    </div>
</div>

<div id="color-picker-modal" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 9999; justify-content: center; align-items: center;">
    <div class="modal-content">
        <h3 style="margin-top:0; margin-bottom: 15px; font-size: 16px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px;">
            é€‰æ‹©é¢œè‰² <span id="cp-target-name" style="font-size: 11px; color: #888; margin-left: 8px;"></span>
        </h3>

        <div id="cp-grid" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; margin-bottom: 20px;">
        </div>

        <div class="form-group" style="display: flex; gap: 10px; align-items: center;">
            <div id="cp-preview" style="width: 36px; height: 36px; border-radius: 6px; background: #fff; border: 1px solid rgba(255,255,255,0.2);"></div>
            <div style="flex: 1;">
                <label style="margin-bottom: 2px;">Hex Code</label>
                <input type="text" id="cp-hex-input" value="#FFFFFF" style="font-family: monospace; letter-spacing: 1px;">
            </div>
        </div>

        <div id="cp-extra-controls" style="display:none; margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 20px;">
            <div style="margin-bottom: 15px;">
                <label style="margin-bottom: 8px; display: block;">é«˜å…‰æ•ˆæœé¢„è§ˆ</label>
                <div style="height: 80px; background: #1a1a1a; border-radius: 6px; overflow:hidden; border: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: center; align-items: center;">
                    <canvas id="cp-3d-preview-canvas"></canvas>
                </div>
            </div>

            <div class="slider-group">
                <span>é«˜å…‰å®½åº¦: <span id="cp-width-val" style="font-family: monospace;">1.0</span></span>
                <input type="range" id="cp-width-slider" min="0.1" max="100.0" step="0.1" value="50.0">
            </div>
        </div>

        <div class="modal-buttons">
            <button class="btn" id="cp-cancel-btn">å–æ¶ˆ</button>
            <button class="btn btn-primary" id="cp-confirm-btn">ç¡®å®š</button>
        </div>
    </div>
</div>

<audio id="audioElement"></audio>

<script type="x-shader/x-vertex" id="vertexShader">
    attribute float aExtraLength;
    varying vec3 vWorldPosition;
    varying vec2 vUv;

    varying vec3 vLocalPos;
    varying float vHalfLength;

    uniform float uPlayheadX;
    uniform float uGlowRadius;
    uniform vec3 uBaseColor;
    uniform vec3 uActiveColor;
    uniform bool uUseTexture;
    uniform sampler2D uMap;

    void main() {
        vUv = uv; // ä¼ é€’ UV
        vec3 newPos = position;

        // æ ¸å¿ƒé€»è¾‘ï¼šåŸºäº aExtraLength æ‹‰ä¼¸éŸ³ç¬¦é•¿åº¦
        if (newPos.x > 0.0) {
            newPos.x += aExtraLength * 0.5;
        } else {
            newPos.x -= aExtraLength * 0.5;
        }

        // ğŸ”¥ æ–°å¢ï¼šä¿å­˜æ‹‰ä¼¸åçš„å±€éƒ¨åæ ‡
        vLocalPos = newPos;
        // ğŸ”¥ æ–°å¢ï¼šè®¡ç®—Xè½´çš„æ€»åŠé•¿ (åŸºç¡€0.5 + æ‹‰ä¼¸çš„ä¸€åŠ)
        vHalfLength = 0.5 + aExtraLength * 0.5;

        // ğŸ”¥ ä¿®å¤æŠ¥é”™çš„å…³é”®ï¼šæ‰‹åŠ¨å¤„ç† instanceMatrix
        // Three.js åœ¨ç¼–è¯‘ ShaderMaterial æ—¶ï¼Œå¦‚æœ object æ˜¯ InstancedMeshï¼Œä¼šè‡ªåŠ¨æ·»åŠ  #define USE_INSTANCING
        #ifdef USE_INSTANCING
            vec4 worldPosition = modelMatrix * instanceMatrix * vec4(newPos, 1.0);
        #else
            // å¦‚æœæ˜¯æ™®é€š Meshï¼Œæ²¡æœ‰ instanceMatrixï¼Œç›´æ¥ä¹˜ modelMatrix
            vec4 worldPosition = modelMatrix * vec4(newPos, 1.0);
        #endif

        vWorldPosition = worldPosition.xyz;

        gl_Position = projectionMatrix * viewMatrix * worldPosition;
    }
</script>

<script type="x-shader/x-fragment" id="fragmentShader">
    varying vec3 vWorldPosition;
    varying vec3 vLocalPos;
    varying float vHalfLength;

    uniform vec3 uBaseColor;
    uniform vec3 uHighlightColor;
    uniform float uPlayheadX;
    uniform float uHighlightWidth;
    uniform float uShowEdges;

    void main() {
        // 1. è®¡ç®—ä¸æ’­æ”¾çº¿çš„è·ç¦»è¡°å‡
        float dist = abs(vWorldPosition.x - uPlayheadX);
        float intensity = exp(-dist * 2.0 / max(0.1, uHighlightWidth));
        vec3 finalColor = mix(uBaseColor, uHighlightColor, intensity);

        // 2. æ£±è§’çº¿æ¸²æŸ“é€»è¾‘
        if (uShowEdges > 0.5) {
            float w = 0.05; // çº¿æ¡ç²—ç»†ç³»æ•°ï¼Œ0.05 è¾ƒé€‚ä¸­

            // æ£€æµ‹å±€éƒ¨åæ ‡æ˜¯å¦ä½äºå„è½´è¾¹ç¼˜
            float edgeX = step(vHalfLength - w, abs(vLocalPos.x));
            float edgeY = step(0.5 - w, abs(vLocalPos.y));
            float edgeZ = step(0.5 - w, abs(vLocalPos.z));

            // æ ¸å¿ƒç®—æ³•ï¼šå½“è‡³å°‘ä¸¤ä¸ªç»´åº¦å¤„äºè¾¹ç¼˜æ—¶ï¼Œåˆ¤å®šä¸ºâ€œæ£±çº¿â€
            if ((edgeX + edgeY + edgeZ) >= 2.0) {
                // æ£±çº¿ï¼šä½¿ç”¨äº®è‰²å¹¶å åŠ ç™½è‰²å‘å…‰æ„Ÿ
                gl_FragColor = vec4(finalColor + vec3(0.1), 0.8);
            } else {
                // å†…éƒ¨å¡«å……ï¼šå¤§å¹…å‡å¼±äº®åº¦ï¼Œäº§ç”Ÿä¸­ç©º/é€æ˜æ„Ÿ
                gl_FragColor = vec4(finalColor * 1.0, 0.8);
            }
        } else {
            // æ™®é€šæ¨¡å¼ (Capsule/Box å¡«å……)
            gl_FragColor = vec4(finalColor, 1.0);
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { Midi } from '@tonejs/midi';
    import * as BufferGeometryUtils from 'https://unpkg.com/three@0.160.0/examples/jsm/utils/BufferGeometryUtils.js';

    // ==========================================
    // 1. å…¨å±€çŠ¶æ€ä¸é…ç½®
    // ==========================================

    let bgMesh = null;
    let bgMaterial = null;
    let bgTexture = null;
    let bgImageAspect = 1;
    let customGeometry = null;

    let sharedAudioCtx = null;
    let starMesh = null; // å…¨å±€æ˜Ÿæ˜Ÿå¯¹è±¡

    let currentHighlightColor = new THREE.Color(1, 1, 1);
    let currentHighlightWidth = 50.0;

    // ğŸ”¥ æ–°å¢ï¼šåŒé€šé“æ¨¡ç³Šä¸“ç”¨å˜é‡
    let blurScene, blurCamera;
    let blurRtX, blurRtY; // ä¸¤ä¸ªæ¸²æŸ“ç›®æ ‡ (Render Targets): Xè½´ç»“æœ, Yè½´ç»“æœ
    let blurMatX, blurMatY; // ä¸¤ä¸ªæè´¨: æ¨ªå‘æ¨¡ç³Š, çºµå‘æ¨¡ç³Š
    let blurMesh; // ç”¨äºç¦»å±æ¸²æŸ“çš„æ¿å­

    let previewScene, previewCamera, previewRenderer, previewControls;
    let previewMeshOriginal = null;  // å·¦è¾¹çš„åŸå§‹æ›¿èº«
    let previewMeshStretched = null; // å³è¾¹çš„æ‹‰ä¼¸æ›¿èº«
    let tempLoadedGeometry = null;   // æš‚å­˜åˆšåŠ è½½è¿›æ¥çš„å‡ ä½•ä½“
    let previewAnimationId = null;

    let tempLoadedMaterial = null;

    function setStarfieldState(visible) {
        // 1. è®¾ç½® 3D æ˜Ÿæ˜Ÿç²’å­å¯è§æ€§
        if (starMesh) starMesh.visible = visible;

        // 2. åŒæ­¥ UI å¼€å…³çŠ¶æ€
        const toggle = document.getElementById('starfieldToggle');
        if (toggle) toggle.checked = visible;

        const vizSection = document.getElementById('visualizer-section');

        if (visible) {
            // å¦‚æœç”¨æˆ·æ²¡æœ‰ä¸Šä¼ è‡ªå®šä¹‰èƒŒæ™¯ï¼Œæ˜¾ç¤ºæ˜Ÿç©ºæ¿å­
            if (!currentBgType) {
                if (bgMaterial && window.starfieldBgTexture) {
                    bgMaterial.uniforms.tMap.value = window.starfieldBgTexture;

                    // é‡ç½®å‚æ•°
                    bgMaterial.uniforms.uOpacity.value = 1.0;
                    bgMaterial.uniforms.uBrightness.value = 0.0;
                    bgMaterial.uniforms.uContrast.value = 1.0;

                    // --- ğŸ”¥ ä¿®å¤æ¤­åœ†å˜å½¢çš„å…³é”® ---
                    // 1. å‘Šè¯‰ç³»ç»Ÿï¼Œå½“å‰è´´å›¾çš„é•¿å®½æ¯”æ˜¯ 1:1 (æ­£æ–¹å½¢)
                    bgImageAspect = 1.0;

                    // 2. å¼ºåˆ¶è®¾ä¸º 'cover' æ¨¡å¼ (ä¿æŒæ¯”ä¾‹é“ºæ»¡)
                    BG_STATE.fit = 'cover';
                    document.getElementById('bg-fit').value = 'cover'; // åŒæ­¥UI

                    // 3. ç«‹å³è§¦å‘ä¸€æ¬¡ UV è®¡ç®—ï¼Œä¿®æ­£æ‹‰ä¼¸
                    updateBackgroundUV();

                    // æ˜¾ç¤º
                    if (bgMesh) bgMesh.visible = true;
                    if (vizSection) vizSection.style.background = "#000000";
                }
            } else {
                // è‡ªå®šä¹‰èƒŒæ™¯
                if (bgMesh) bgMesh.visible = true;
            }
        } else {
            // å…³é—­
            if (!currentBgType) {
                if (bgMesh) bgMesh.visible = false;
                if (vizSection) vizSection.style.background = "#000000";
            }
        }
    }

    const STATE = {
        isPlaying: false,
        currentTime: 0,         // å…¨å±€æ—¶é—´ (ç§’)
        lastFrameTime: 0,
        totalDuration: 60,      // é»˜è®¤è‡³å°‘60ç§’
        pxPerSec: 50,           // æ—¶é—´è½´ç¼©æ”¾: 1ç§’ = 50px
        playbackSpeed: 20,     // 3D åœºæ™¯é€Ÿåº¦ç³»æ•° (ä¸ zoomSlider å…³è”)
        noteThickness: 1.0,
        noteShape: 'capsule',
        tracks: [],             // å­˜å‚¨æ‰€æœ‰è½¨é“å¯¹è±¡
        clips: [],              // å­˜å‚¨æ‰€æœ‰ Clip å¯¹è±¡
        nextTrackId: 1,
        noteHeightScale: 1.5,
        audioGain: 1.5,
        bpm: 120,
        timeSignature: 4, // 4/4 æ‹
        selectedTrackIds: new Set(),
        lastSelectedTrackId: null, // ğŸ”¥ æ–°å¢ï¼šè®°å½•æœ€åä¸€æ¬¡ç‚¹å‡»çš„è½¨é“ï¼ˆé”šç‚¹ï¼‰
        groups: {},
        nextGroupId: 1,
        soloCount: 0,
        zSeparation: 0.3,
    };

    const ResourceMgr = {
        audioCache: new Map(),

        // æ³¨å†Œèµ„æºå¹¶è¿”å›ä¸€ä¸ªå¯å¤ç”¨çš„ Blob URL
        register(fileOrBase64) {
            // å¦‚æœæ˜¯ Base64 å­—ç¬¦ä¸²ï¼Œè½¬ä¸º Blob
            if (typeof fileOrBase64 === 'string' && fileOrBase64.startsWith('data:')) {
                const blob = this.base64ToBlob(fileOrBase64);
                const url = URL.createObjectURL(blob);
                return url;
            }
            // å¦‚æœç›´æ¥æ˜¯ File æˆ– Blob å¯¹è±¡
            return URL.createObjectURL(fileOrBase64);
        },

        base64ToBlob(base64) {
            const parts = base64.split(';base64,');
            const contentType = parts[0].split(':')[1];
            const raw = window.atob(parts[1]);
            const uInt8Array = new Uint8Array(raw.length);
            for (let i = 0; i < raw.length; ++i) uInt8Array[i] = raw.charCodeAt(i);
            return new Blob([uInt8Array], { type: contentType });
        },

        // æ‰‹åŠ¨é‡Šæ”¾å†…å­˜
        revoke(url) {
            if (url && url.startsWith('blob:')) {
                URL.revokeObjectURL(url);
            }
        }
    };

    // æ–°å¢ Group ç±»
    class Group {
        constructor(name, color) {
            this.id = STATE.nextGroupId++;
            this.name = name;
            this.color = color; // ç¼–ç»„çš„ä¸»é¢œè‰²
            this.trackIds = new Set();
        }
    }

    const DOM = {
        headers: document.getElementById('track-headers'),
        lanes: document.getElementById('lanes-container'),
        grid: document.getElementById('gridLines'),
        playhead: document.getElementById('ui-playhead'),
        timelineLanes: document.getElementById('timeline-lanes'),
        audio: document.getElementById('audioElement'),
        playBtn: document.getElementById('playBtn'),
        stopBtn: document.getElementById('stopBtn'),
        sceneZoom: document.getElementById('sceneZoom'),
        loading: document.getElementById('loading'),
        rulerContent: document.getElementById('ruler-content'),
        barRuler: document.getElementById('bar-ruler'),
        timeRuler: document.getElementById('time-ruler'),
        rulerPlayhead: document.getElementById('ruler-playhead'), // ğŸ”¥ æ–°å¢å¼•ç”¨
    };

    // ==========================================
    // 2. ç±»å®šä¹‰ï¼šTrack & Clip
    // ==========================================

    const HistoryMgr = {
        undoStack: [],
        redoStack: [],
        maxLimit: 10,

        add(cmd) {
            // åœ¨æ·»åŠ æ–°æ“ä½œå‰ï¼Œå¦‚æœé‡åšæ ˆä¸ä¸ºç©ºï¼Œéœ€å…ˆé‡Šæ”¾é‡åšæ ˆä¸­çš„ Blob èµ„æº
            this.clearStackResources(this.redoStack);
            this.redoStack = [];

            this.undoStack.push(cmd);

            // å¦‚æœè¶…è¿‡é™åˆ¶ï¼Œå¼¹å‡ºæœ€æ—§çš„æ“ä½œå¹¶é‡Šæ”¾å…¶å…³è”çš„èµ„æº
            if (this.undoStack.length > this.maxLimit) {
                const oldestCmd = this.undoStack.shift();
                this.disposeCommandResources(oldestCmd);
            }
            console.log("History Add:", cmd.type);
        },

        // å…³é”®ï¼šè¯†åˆ«å‘½ä»¤ä¸­åŒ…å«çš„èµ„æºå¹¶é‡Šæ”¾
        disposeCommandResources(cmd) {
            if (!cmd) return;

            // 1. å¦‚æœæ˜¯èƒŒæ™¯å›¾æ›´æ”¹
            if (cmd.type === 'change_background') {
                if (cmd.oldData) ResourceMgr.revoke(cmd.oldData);
                if (cmd.newData) ResourceMgr.revoke(cmd.newData);
            }

            // 2. å¦‚æœæ˜¯éŸ³é¢‘å¯¼å…¥
            if (cmd.type === 'import_audio') {
                if (cmd.oldData?.clips) {
                    cmd.oldData.clips.forEach(c => ResourceMgr.revoke(c.sourceData));
                }
                if (cmd.newData?.clips) {
                    cmd.newData.clips.forEach(c => ResourceMgr.revoke(c.sourceData));
                }
            }

            // 3. å¦‚æœæ˜¯åˆ é™¤è½¨é“
            if (cmd.type === 'delete_track' && cmd.trackData?.clips) {
                cmd.trackData.clips.forEach(c => ResourceMgr.revoke(c.sourceData));
            }

            // 4. å¤„ç† Project JSON (å¦‚æœå­˜å‚¨çš„æ˜¯å¯¹è±¡ï¼ŒJS å¼•æ“ä¼šè‡ªåŠ¨å›æ”¶ï¼Œ
            // ä½†å¦‚æœé‡Œé¢åŒ…å«å¤§é‡ Blob å¼•ç”¨ï¼Œéœ€ç¡®ä¿æ¸…ç†)
            cmd.oldProject = null;
            cmd.newProject = null;
        },

        clearStackResources(stack) {
            stack.forEach(cmd => this.disposeCommandResources(cmd));
        },

        undo() {
            if (this.undoStack.length === 0) return;
            const cmd = this.undoStack.pop();
            this.redoStack.push(cmd);
            this.execute(cmd, true);
        },

        redo() {
            if (this.redoStack.length === 0) return;
            const cmd = this.redoStack.pop();
            this.undoStack.push(cmd);
            this.execute(cmd, false);
        },

        execute(cmd, isUndo) {
            switch (cmd.type) {
                case 'move_clip':
                    const clip = cmd.clip;
                    const targetTime = isUndo ? cmd.oldStart : cmd.newStart;
                    // æ¢å¤æ•°æ®
                    clip.startTime = targetTime;
                    // æ¢å¤è§†å›¾
                    clip.updateDOMPosition();
                    clip.update3DPosition();
                    updateTotalDuration();
                    break;

                case 'change_view':
                    const viewParams = isUndo ? cmd.oldView : cmd.newView;
                    ViewMgr.restore(viewParams);
                    break;

                // ğŸ”¥ æ–°å¢ Case: å·¥ç¨‹åŠ è½½ (æ•´ç›˜æ’¤å›)
                case 'load_project':
                    const projectData = isUndo ? cmd.oldProject : cmd.newProject;
                    // ç›´æ¥è°ƒç”¨ restoreState æ¢å¤æ•´ä¸ªå·¥ç¨‹
                    // æ³¨æ„ï¼šè¿™æ˜¯ä¸€ä¸ªè€—æ—¶æ“ä½œï¼Œå¯èƒ½ä¼šç¨å¾®å¡é¡¿ä¸€ä¸‹
                    ProjectMgr.restoreState(projectData);
                    break;

                case 'change_background':
                    const bgData = isUndo ? cmd.oldData : cmd.newData;
                    const bgType = isUndo ? cmd.oldType : cmd.newType;

                    const bgBase64 = isUndo ? cmd.oldBase64 : cmd.newBase64;
                    storedBgBase64ForSave = bgBase64;

                    if (bgData) {
                        // A. æ¢å¤å›¾ç‰‡
                        applyBackgroundSource(bgData, bgType);
                        currentBgBase64 = bgData;
                        currentBgType = bgType;
                        setStarfieldState(false); // å…³æ˜Ÿæ˜Ÿ
                    } else {
                        // B. æ¢å¤åˆ°æ— èƒŒæ™¯ï¼ˆæ˜Ÿç©ºï¼‰
                        if (bgMesh) bgMesh.visible = false;
                        if (bgMaterial && bgMaterial.uniforms.tMap) bgMaterial.uniforms.tMap.value = null;
                        if (bgVideoElement) {
                            bgVideoElement.pause();
                            bgVideoElement.src = "";
                            bgVideoElement = null;
                        }

                        // æ¸…ç©ºæ ‡è®°
                        currentBgBase64 = null;
                        currentBgType = null;
                        storedBgBase64ForSave = null;
                        bgTexture = null;

                        setStarfieldState(true); // å¼€æ˜Ÿæ˜Ÿ
                        requestAnimationFrame(() => onResize());
                    }
                    break;

                // ğŸ”¥ æ–°å¢ Case 2: éŸ³é¢‘å¯¼å…¥æ’¤å›/é‡åš
                case 'import_audio':
                    const targetData = isUndo ? cmd.oldData : cmd.newData;

                    // 1. å…ˆå½»åº•åˆ é™¤å½“å‰çš„éŸ³é¢‘è½¨é“ (å¦‚æœæœ‰)
                    const currentAudio = STATE.tracks.find(t => t.type === 'audio');
                    if (currentAudio) {
                        deleteTrackContext(currentAudio);
                    }

                    // 2. å¦‚æœç›®æ ‡çŠ¶æ€æœ‰æ•°æ®ï¼Œåˆ™æ¢å¤å®ƒ
                    if (targetData) {
                        // Audio è½¨é“é€šå¸¸æ”¾åœ¨æœ€ä¸Šé¢ (index 0)
                        ProjectMgr.restoreSingleTrack(targetData, 0).then(() => {
                            if (typeof reorderTracks === 'function') reorderTracks();
                        });
                    }
                    break;

                case 'delete_track':
                    // é€»è¾‘ï¼šUndo = æ¢å¤; Redo = åˆ é™¤
                    if (isUndo) {
                        // ä½¿ç”¨ await ç¡®ä¿å¼‚æ­¥æ¢å¤å®Œæˆåå†é‡æ’ (restoreSingleTrack æ˜¯ async çš„)
                        ProjectMgr.restoreSingleTrack(cmd.trackData, cmd.index).then(() => {
                            if (typeof reorderTracks === 'function') reorderTracks();
                        });
                    } else {
                        // é‡æ–°è·å–å¯¹è±¡ï¼ˆå› ä¸ºä¹‹å‰è¢«é”€æ¯äº†ï¼Œå¼•ç”¨å¯èƒ½å¤±æ•ˆï¼Œæˆ–è€… id æ²¡å˜ä½†å¯¹è±¡å˜äº†ï¼‰
                        // ä½†å¦‚æœæ˜¯ restoreSingleTrack æ¢å¤çš„ï¼Œid åº”è¯¥æ˜¯ä¸€è‡´çš„
                        const t = STATE.tracks.find(tr => tr.id === cmd.trackData.id);
                        if(t) deleteTrackContext(t);
                    }
                    break;

                case 'clear_visuals':
                    if (isUndo) {
                        // === æ’¤å›æ¸…é™¤ (æ¢å¤ä»¥å‰çš„æ ·å­) ===
                        console.log("Undo Clear: Restoring visuals...");

                        // currentNoteTexture = cmd.oldTexture;
                        refreshAllMidiMeshes();

                        if (cmd.oldBgData) {
                            // æ¢å¤ä»¥å‰çš„èƒŒæ™¯å›¾
                            applyBackgroundSource(cmd.oldBgData, cmd.oldBgType);
                            currentBgBase64 = cmd.oldBgData;
                            currentBgType = cmd.oldBgType;
                            setStarfieldState(false); // æœ‰å›¾å°±å…³æ˜Ÿæ˜Ÿ
                        } else {
                            // ä»¥å‰å°±æ˜¯æ˜Ÿç©ºï¼Œæ¢å¤æ˜Ÿç©º
                            currentBgBase64 = null;
                            currentBgType = null;
                            setStarfieldState(true);
                            // ğŸ”¥ å¼ºåˆ¶åˆ·æ–°ï¼Œç¡®ä¿é“ºæ»¡å±å¹•
                            requestAnimationFrame(() => onResize());
                        }

                        if (cmd.oldView) {
                            ViewMgr.restore(cmd.oldView);
                        }
                    } else {
                        // === é‡åšæ¸…é™¤ (å†æ¬¡æ‰§è¡Œæ¸…é™¤) ===
                        console.log("Redo Clear: Clearing visuals again...");

                        refreshAllMidiMeshes();

                        if (bgMesh) bgMesh.visible = false;
                        if (bgMaterial && bgMaterial.uniforms.tMap) bgMaterial.uniforms.tMap.value = null;
                        if (bgVideoElement) {
                            bgVideoElement.pause();
                            bgVideoElement.src = "";
                            bgVideoElement = null;
                        }

                        // æ¸…ç©ºæ ‡è®°
                        currentBgBase64 = null;
                        currentBgType = null;

                        ViewMgr.reset();
                        setStarfieldState(true);

                        // ğŸ”¥ å¼ºåˆ¶åˆ·æ–°ï¼Œç¡®ä¿é“ºæ»¡å±å¹•
                        requestAnimationFrame(() => onResize());
                    }
                    break;

                case 'import_tracks':
                    // é€»è¾‘ï¼šUndo = åˆ é™¤è¿™äº›è½¨é“ (ä½†åœ¨åˆ é™¤å‰è¦ä¿å­˜æ•°æ®ä»¥ä¾¿ Redo); Redo = æ¢å¤è¿™äº›è½¨é“
                    if (isUndo) {
                        // 1. åˆå§‹åŒ–æ•°æ®å­˜å‚¨ (å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ’¤é”€)
                        if (!cmd.tracksData) cmd.tracksData = [];

                        // 2. éå†è¦æ’¤é”€çš„è½¨é“ ID
                        cmd.trackIds.forEach(id => {
                            const t = STATE.tracks.find(tr => tr.id === id);
                            if (t) {
                                // ğŸ”¥ å…³é”®ï¼šåœ¨åˆ é™¤å‰ï¼ŒæŠŠæ•°æ®ä¿å­˜åˆ° cmd é‡Œï¼Œä¾› Redo ä½¿ç”¨
                                const data = serializeTrack(t);
                                // ä¿å­˜æ•°æ®å’Œå®ƒå½“å‰çš„ç´¢å¼•ä½ç½®
                                cmd.tracksData.push({ data: data, index: STATE.tracks.indexOf(t) });

                                // æ‰§è¡Œåˆ é™¤
                                deleteTrackContext(t);
                            }
                        });
                    } else {
                        // Redo: ä½¿ç”¨ä¹‹å‰ Undo æ—¶ä¿å­˜çš„æ•°æ®æ¥æ¢å¤
                        if (cmd.tracksData && cmd.tracksData.length > 0) {
                            // æŒ‰ç´¢å¼•æ’åºï¼Œä¿è¯æ¢å¤é¡ºåº
                            cmd.tracksData.sort((a,b) => a.index - b.index).forEach(item => {
                                ProjectMgr.restoreSingleTrack(item.data, item.index);
                            });
                            // æ¢å¤åé‡æ’
                            if (typeof reorderTracks === 'function') reorderTracks();
                        }
                    }
                    break;

                case 'change_color':
                    const track = STATE.tracks.find(t => t.id === cmd.trackId);
                    if (track) {
                        const color = isUndo ? cmd.oldColor : cmd.newColor;
                        track.ownColor = color;
                        const input = track.headerEl.querySelector('.track-color-picker');
                        if(input) input.value = color;
                        track.refreshColor();
                    }
                    break;

                case 'change_group_color':
                    const changes = cmd.changes; // è¿™æ˜¯ä¸€ä¸ªæ•°ç»„ï¼ŒåŒ…å«æ‰€æœ‰å—å½±å“çš„ç»„ä¿¡æ¯
                    changes.forEach(item => {
                        const group = STATE.groups[item.groupId];
                        if (group) {
                            // æ¢å¤æ—§é¢œè‰² æˆ– åº”ç”¨æ–°é¢œè‰²
                            group.color = isUndo ? item.oldColor : item.newColor;

                            // åˆ·æ–°è¯¥ç»„ä¸‹æ‰€æœ‰è½¨é“çš„é¢œè‰²
                            group.trackIds.forEach(tid => {
                                const t = STATE.tracks.find(trk => trk.id === tid);
                                if (t) t.refreshColor();
                            });
                        }
                    });
                    break;
            }
        }
    };

    const ColorPickerPreview3D = {
        canvas: null, renderer: null, scene: null, camera: null, material: null,
        initialized: false,
        scanTime: 0,

        init() {
            if (this.initialized) return;
            this.canvas = document.getElementById('cp-3d-preview-canvas');

            const width = 360;
            const height = 80;

            this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, alpha: true, antialias: true });
            this.renderer.setSize(width, height);
            this.renderer.setPixelRatio(window.devicePixelRatio);

            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x000000);

            const aspect = width / height;
            const viewSize = 10;
            this.camera = new THREE.OrthographicCamera(
                -viewSize * aspect / 2, viewSize * aspect / 2,
                viewSize / 2, -viewSize / 2,
                0.1, 100
            );
            this.camera.position.set(0, 0, 10);
            this.camera.lookAt(0, 0, 0);

            // --- ç»Ÿä¸€åçš„ Shader ---
            this.material = new THREE.ShaderMaterial({
                uniforms: {
                    uBaseColor: { value: new THREE.Color(0x222222) },
                    uHighlightColor: { value: new THREE.Color(0xffffff) },
                    uHighlightWidth: { value: 50.0 },
                    uPlayheadX: { value: 0.0 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * instanceMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * viewMatrix * worldPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vWorldPosition;
                    uniform vec3 uBaseColor;
                    uniform vec3 uHighlightColor;
                    uniform float uHighlightWidth;
                    uniform float uPlayheadX;

                    void main() {
                        float dist = abs(vWorldPosition.x - uPlayheadX);

                        // ä¸ä¸»åœºæ™¯å®Œå…¨ä¸€è‡´çš„ç®—æ³•
                        float intensity = exp(-dist * 2.0 / max(0.1, uHighlightWidth));

                        vec3 finalColor = mix(uBaseColor, uHighlightColor, intensity);
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
            });

            // åˆ›å»ºé”™è½çš„éŸ³ç¬¦å¸ƒå±€
            const geometry = new THREE.PlaneGeometry(1, 0.6);
            const count = 20;
            const mesh = new THREE.InstancedMesh(geometry, this.material, count);

            const dummy = new THREE.Object3D();
            let index = 0;
            const rows = [1.5, 0.5, -0.5, -1.5];

            rows.forEach((y) => {
                let currentX = -8 + Math.random() * 2;
                while (currentX < 8 && index < count) {
                    const length = 1.5 + Math.random() * 2.5;
                    const gap = 0.5 + Math.random() * 1.0;
                    dummy.position.set(currentX + length / 2, y, 0);
                    dummy.scale.set(length, 1, 1);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(index++, dummy.matrix);
                    currentX += length + gap;
                }
            });

            this.scene.add(mesh);
            this.initialized = true;
            this.animate();
        },

        update(colorHex, widthVal) {
            if (!this.initialized || !this.material) return;

            const floatWidth = parseFloat(widthVal);
            this.material.uniforms.uHighlightColor.value.set(colorHex);
            this.material.uniforms.uHighlightWidth.value = floatWidth;
        },

        animate() {
            requestAnimationFrame(() => this.animate());
            const modal = document.getElementById('color-picker-modal');
            if (modal && modal.style.display !== 'none' && this.material) {
                this.scanTime += 0.02;
                const limit = 6.0;
                this.material.uniforms.uPlayheadX.value = Math.sin(this.scanTime) * limit;
                this.renderer.render(this.scene, this.camera);
            }
        }
    };

    // ==========================================
    // ğŸ¨ é€šç”¨é¢œè‰²ç›˜ç®¡ç†å™¨
    // ==========================================
    // ==========================================
    // ğŸ¨ é€šç”¨é¢œè‰²ç›˜ç®¡ç†å™¨ (å·²æ›´æ–°æ”¯æŒæ‰©å±•æ§ä»¶)
    // ==========================================
    const ColorPickerMgr = {
        modal: document.getElementById('color-picker-modal'),
        grid: document.getElementById('cp-grid'),
        input: document.getElementById('cp-hex-input'),
        preview: document.getElementById('cp-preview'),
        title: document.getElementById('cp-target-name'),

        // æ–°å¢ï¼šæ‰©å±•æ§ä»¶çš„å¼•ç”¨
        extraControls: document.getElementById('cp-extra-controls'),
        widthSlider: document.getElementById('cp-width-slider'),
        widthValDisplay: document.getElementById('cp-width-val'),

        onChange: null,
        onConfirm: null,
        // æ–°å¢ï¼šå®½åº¦å˜åŒ–å›è°ƒ
        onWidthChange: null,
        tempColor: '#ffffff',
        // æ–°å¢ï¼šæ ‡è®°æ˜¯å¦å¤„äºé«˜å…‰ç¼–è¾‘æ¨¡å¼
        isHighlightMode: false,

        presets: [
            '#ff453a', '#ff9f0a', '#ffd60a', '#30d158', '#64d2ff', '#0a84ff',
            '#5e5ce6', '#bf5af2', '#ff375f', '#ac8e68', '#98989d', '#86868b',
            '#ffffff', '#888888', '#555555', '#2a2a2a', '#1c1c1e', '#000000',
            '#e0aaff', '#9d4edd', '#240046', '#a2d2ff', '#bde0fe', '#ffafcc'
        ],

        init() {
            // 1. åˆå§‹åŒ– 3D é¢„è§ˆå¼•æ“
            ColorPickerPreview3D.init();

            // 2. ç”Ÿæˆè‰²å— (ä¿æŒä¸å˜)
            this.grid.innerHTML = '';
            this.presets.forEach(color => {
                const el = document.createElement('div');
                el.className = 'color-swatch';
                el.style.backgroundColor = color;
                el.onclick = () => this.selectColor(color);
                this.grid.appendChild(el);
            });

            // 3. ç»‘å®šåŸºç¡€äº‹ä»¶ (ä¿æŒä¸å˜)
            document.getElementById('cp-cancel-btn').addEventListener('click', () => this.close());
            document.getElementById('cp-confirm-btn').addEventListener('click', () => this.confirm());
            this.input.addEventListener('input', (e) => {
                const val = e.target.value;
                if (/^#[0-9A-F]{6}$/i.test(val)) {
                    this.selectColor(val, false);
                }
            });
            this.modal.addEventListener('click', (e) => {
                if (e.target === this.modal) this.close();
            });

            // 4. æ–°å¢ï¼šç»‘å®šæ»‘å—äº‹ä»¶
            this.widthSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                // æ›´æ–°æ˜¾ç¤ºæ•°å€¼
                this.widthValDisplay.innerText = val.toFixed(1);

                // æ›´æ–° Modal å†…çš„ 3D é¢„è§ˆ
                if (this.isHighlightMode) {
                    ColorPickerPreview3D.update(this.tempColor, val);
                }

                // è§¦å‘å¤–éƒ¨å›è°ƒï¼Œæ›´æ–°ä¸»åœºæ™¯
                if (this.onWidthChange) {
                    this.onWidthChange(val);
                }
            });
        },

        /**
         * æ‰“å¼€é¢œè‰²ç›˜
         * @param {string} initialColor - åˆå§‹é¢œè‰² hex
         * @param {string} title - æ ‡é¢˜åç¼€
         * @param {function} onConfirm - ç¡®å®šå›è°ƒ
         * @param {function} onChange - é¢œè‰²å®æ—¶é¢„è§ˆå›è°ƒ
         * @param {object} extraConfig - (æ–°å¢) é¢å¤–é…ç½®å¯¹è±¡ { isHighlight: bool, initialWidth: float, onWidthChange: func }
         */
        open(initialColor, title, onConfirm, onChange = null, extraConfig = null) {
            this.tempColor = initialColor;
            this.onConfirm = onConfirm;
            this.onChange = onChange;
            this.title.innerText = title || "";

            // --- å¤„ç†æ‰©å±•é…ç½® ---
            if (extraConfig && extraConfig.isHighlight) {
                this.isHighlightMode = true;
                // æ˜¾ç¤ºæ‰©å±•åŒºåŸŸ
                this.extraControls.style.display = 'block';
                // è®¾ç½®æ»‘å—åˆå§‹å€¼
                const initWidth = extraConfig.initialWidth || 1.0;
                this.widthSlider.value = initWidth;
                this.widthValDisplay.innerText = initWidth.toFixed(1);
                this.onWidthChange = extraConfig.onWidthChange;

                // æ‰“å¼€æ—¶ç«‹å³æ›´æ–°ä¸€æ¬¡ 3D é¢„è§ˆ
                ColorPickerPreview3D.update(this.tempColor, initWidth);
                // é‡æ–°è°ƒæ•´æ¸²æŸ“å™¨å¤§å°ä»¥é€‚åº”å®¹å™¨ (é˜²æ­¢é¦–æ¬¡æ‰“å¼€å°ºå¯¸ä¸å¯¹)
                ColorPickerPreview3D.renderer.setSize(360, 80);

            } else {
                this.isHighlightMode = false;
                // éšè—æ‰©å±•åŒºåŸŸ
                this.extraControls.style.display = 'none';
                this.onWidthChange = null;
            }
            // -----------------------

            this.modal.style.display = 'flex';
            this.selectColor(initialColor);
        },

        selectColor(color, updateInput = true) {
            this.tempColor = color;
            this.preview.style.backgroundColor = color;
            if (updateInput) this.input.value = color;

            Array.from(this.grid.children).forEach(child => {
                // ç®€å•æ¸…é™¤ active çŠ¶æ€
                child.classList.remove('active');
            });

            // å¦‚æœåœ¨é«˜å…‰æ¨¡å¼ï¼Œé¢œè‰²æ”¹å˜æ—¶ä¹Ÿè¦æ›´æ–° 3D é¢„è§ˆ
            if (this.isHighlightMode) {
                ColorPickerPreview3D.update(this.tempColor, this.widthSlider.value);
            }

            if (this.onChange) {
                this.onChange(this.tempColor);
            }
        },

        confirm() {
            if (this.onConfirm) {
                // å¦‚æœæ˜¯é«˜å…‰æ¨¡å¼ï¼Œç¡®è®¤æ—¶å¯èƒ½éœ€è¦æŠŠæœ€ç»ˆå®½åº¦ä¹Ÿä¼ å‡ºå»(å¦‚æœéœ€è¦è®°å½•å†å²)
                // ç›®å‰åªä¼ äº†é¢œè‰²ï¼Œå®½åº¦æ˜¯å®æ—¶æ›´æ–°çš„
                this.onConfirm(this.tempColor);
            }
            this.close();
        },

        close() {
            this.modal.style.display = 'none';
            this.onConfirm = null;
            this.onChange = null;
            this.onWidthChange = null;
            this.isHighlightMode = false;
        }
    };

    // åœ¨æœ€åº•éƒ¨çš„ initController() ä¸­è°ƒç”¨åˆå§‹åŒ–
    // ColorPickerMgr.init();

    const BG_STATE = {
        opacity: 1.0,
        blur: 0,
        brightness: 100,
        contrast: 100,
        fit: 'cover'
    };

    let currentBgBase64 = null;
    let currentBgType = null;
    let storedBgBase64ForSave = null;

    // è¾…åŠ©å‡½æ•°ï¼šåº”ç”¨æ ·å¼åˆ°å½“å‰èƒŒæ™¯å…ƒç´ 
    function applyBackgroundStyles() {
        const layer = document.getElementById('bg-layer');
        // è·å– layer ä¸‹çš„ img æˆ– video
        const el = layer.querySelector('img, video');
        if (!el) return;

        // 1. åº”ç”¨ CSS æ»¤é•œ
        el.style.opacity = BG_STATE.opacity;
        el.style.filter = `blur(${BG_STATE.blur}px) brightness(${BG_STATE.brightness}%) contrast(${BG_STATE.contrast}%)`;

        // 2. åº”ç”¨å¡«å……æ¨¡å¼
        el.style.objectFit = BG_STATE.fit;
    }

    // è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°å¼¹çª—é‡Œçš„æ•°å€¼æ˜¾ç¤º
    function updateBgUI() {
        document.getElementById('bg-opacity').value = BG_STATE.opacity;
        document.getElementById('val-opacity').innerText = BG_STATE.opacity;

        document.getElementById('bg-blur').value = BG_STATE.blur;
        document.getElementById('val-blur').innerText = BG_STATE.blur + 'px';

        document.getElementById('bg-brightness').value = BG_STATE.brightness;
        document.getElementById('val-bright').innerText = BG_STATE.brightness + '%';

        document.getElementById('bg-contrast').value = BG_STATE.contrast;
        document.getElementById('val-contrast').innerText = BG_STATE.contrast + '%';

        document.getElementById('bg-fit').value = BG_STATE.fit;
    }

    // âœ¨ æ–°å¢ï¼šåˆ›å»ºæ˜Ÿç©ºå‡½æ•° (å¸¦åœ†å½¢å…‰æ™•è´´å›¾)
    function initStarfield() {
        const starGeo = new THREE.BufferGeometry();
        const starCount = 40000; // æ˜Ÿæ˜Ÿæ•°é‡
        const posArray = new Float32Array(starCount * 3);

        for(let i = 0; i < starCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 2000;
        }

        starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

        // ğŸ¨ 1. ç”¨ä»£ç ç”»ä¸€ä¸ªåœ†å½¢çš„æ¸å˜è´´å›¾ (æ— éœ€å¤–éƒ¨å›¾ç‰‡)
        const canvas = document.createElement('canvas');
        canvas.width = 64; // ç¨å¾®å¤§ä¸€ç‚¹ï¼Œç”»è´¨æ›´å¥½
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        // åˆ›å»ºå¾„å‘æ¸å˜ï¼šä¸­é—´ç™½ -> è¾¹ç¼˜é€æ˜
        const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');   // ä¸­å¿ƒæœ€äº®
        gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)'); // æ ¸å¿ƒå…‰æ™•
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)'); // å¤–éƒ¨å…‰æ™•
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');          // è¾¹ç¼˜å®Œå…¨é€æ˜

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);

        const starTexture = new THREE.CanvasTexture(canvas);

        // ğŸ¨ 2. è®¾ç½®æè´¨
        const starMat = new THREE.PointsMaterial({
            size: 4.0,             // ğŸ”¥ ç¨å¾®è°ƒå¤§ä¸€ç‚¹ï¼Œå½•åˆ¶å‡ºæ¥æ‰ä¸ä¼šæ˜¯å•åƒç´ å™ªç‚¹
            map: starTexture,
            color: 0xffffff,
            transparent: true,
            opacity: 1.0,          // ä¿æŒé«˜ä¸é€æ˜åº¦
            sizeAttenuation: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        starMesh = new THREE.Points(starGeo, starMat);
        starMesh.frustumCulled = false;
        scene.add(starMesh);

        const bgCanvas = document.createElement('canvas');
        bgCanvas.width = 512;
        bgCanvas.height = 512;
        const bgCtx = bgCanvas.getContext('2d');

        // æ¸å˜ (ä¹‹å‰çš„é¢œè‰²)
        const bgGrad = bgCtx.createRadialGradient(256, 256, 0, 256, 256, 480);
        bgGrad.addColorStop(0.0, '#586b85');
        bgGrad.addColorStop(0.4, '#253045');
        bgGrad.addColorStop(1.0, '#000000');

        bgCtx.fillStyle = bgGrad;
        bgCtx.fillRect(0, 0, 512, 512);

        // --- ğŸ”¥ å…³é”®ä¼˜åŒ–ï¼šæ·»åŠ æŠ–åŠ¨ (Dithering) å»é™¤è‰²é˜¶ ---
        const imageData = bgCtx.getImageData(0, 0, 512, 512);
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            // ç”Ÿæˆ -1.5 åˆ° +1.5 ä¹‹é—´çš„éšæœºå™ªéŸ³
            // è¿™ä¸ªæ•°å€¼å¾ˆå°ï¼Œä¸å½±å“è§‚æ„Ÿï¼Œä½†è¶³ä»¥æ‰“ç ´è‰²é˜¶
            const noise = (Math.random() - 0.5) * 3;

            data[i]     = Math.max(0, Math.min(255, data[i] + noise));     // R
            data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise)); // G
            data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise)); // B
            // Alpha ä¸åŠ¨
        }
        bgCtx.putImageData(imageData, 0, 0);
        // ------------------------------------------------

        window.starfieldBgTexture = new THREE.CanvasTexture(bgCanvas);
        window.starfieldBgTexture.encoding = THREE.sRGBEncoding;

        // ä¼˜åŒ–è´´å›¾è¿‡æ»¤æ¨¡å¼ï¼Œè¿›ä¸€æ­¥å¹³æ»‘
        window.starfieldBgTexture.minFilter = THREE.LinearFilter;
        window.starfieldBgTexture.magFilter = THREE.LinearFilter;
    }

    function deleteTrackContext(track) {
        if (!track) return;

        // --- æ–°å¢ï¼šéŸ³é¢‘æ¸…ç†é€»è¾‘ ---
        // æ£€æŸ¥è¯¥è½¨é“æ˜¯å¦åŒ…å«å½“å‰çš„æ´»åŠ¨éŸ³é¢‘ Clip
        track.clips.forEach(c => {
            if (STATE.activeAudioClip === c) {
                console.log("æ­£åœ¨åˆ é™¤æ´»åŠ¨éŸ³é¢‘è½¨é“ï¼Œåœæ­¢æ’­æ”¾...");

                // 1. åœæ­¢æ’­æ”¾
                if (STATE.isPlaying) togglePlay();

                // 2. æš‚åœéŸ³é¢‘å…ƒç´ 
                DOM.audio.pause();

                // 3. ç§»é™¤æºï¼Œé˜²æ­¢ç»§ç»­å‘å£°
                DOM.audio.removeAttribute('src');
                DOM.audio.load(); // å¼ºåˆ¶åˆ·æ–°éŸ³é¢‘å…ƒç´ çŠ¶æ€

                // 4. æ¸…é™¤å…¨å±€å¼•ç”¨
                STATE.activeAudioClip = null;
            }
            c.destroy();
            const globalIdx = STATE.clips.indexOf(c);
            if (globalIdx > -1) {
                STATE.clips.splice(globalIdx, 1);
            }
        });
        // -------------------------

        // 2. æ¸…ç† DOM
        if (track.headerEl) track.headerEl.remove();
        if (track.laneEl) track.laneEl.remove();

        // 3. ä»å…¨å±€æ•°ç»„ç§»é™¤
        const idx = STATE.tracks.indexOf(track);
        if (idx > -1) {
            STATE.tracks.splice(idx, 1);
        }

        // 4. æ¸…ç†é€‰ä¸­çŠ¶æ€
        STATE.selectedTrackIds.delete(track.id);

        // 5. åˆ·æ–°
        updateTotalDuration();
    }

    class Track {
        constructor(name, type) {
            this.id = STATE.nextTrackId++;
            this.name = name;
            this.type = type;

            // ğŸ”¥ ä¿®æ”¹è¿™é‡Œï¼šæ ¹æ®ç±»å‹åˆ†é…ä¸åŒçš„ç°åº¦
            if (this.type === 'audio') {
                this.ownColor = '#888888'; // Audio: ä¸­ç°è‰² (é…åˆé€æ˜åº¦é€€å±…èƒŒæ™¯)
            } else {
                this.ownColor = '#E0E0E0'; // MIDI: äº®é“¶è‰² (ä½œä¸ºè§†è§‰ä¸»ä½“)
            }

            this.groupId = null;
            this.clips = [];

            this.headerEl = null;
            this.laneEl = null;
            this.isMuted = false;
            this.isSoloed = false;

            this.renderUI();
        }
        // ... (åç»­ä»£ç ä¿æŒä¸å˜)

        get color() {
            return this.getEffectiveColor();
        }

        // ğŸ”¥ æ ¸å¿ƒï¼šè·å–æœ‰æ•ˆé¢œè‰²ã€‚å¦‚æœæœ‰ç¼–ç»„ï¼Œä¼˜å…ˆç”¨ç¼–ç»„é¢œè‰²
        getEffectiveColor() {
            if (this.groupId && STATE.groups[this.groupId]) {
                return STATE.groups[this.groupId].color;
            }
            return this.ownColor;
        }

        setMute(state) {
            this.isMuted = state;
            const btn = this.headerEl.querySelector('.mute-btn');
            if (btn) btn.classList.toggle('active-mute', this.isMuted);

            // æ¯æ¬¡ Mute çŠ¶æ€æ”¹å˜ï¼Œåˆ·æ–°å¯è§æ€§å’ŒéŸ³é‡
            updateAllTracksVisibility();
        }

        setSolo(state) {
            // åªæœ‰å½“çŠ¶æ€çœŸæ­£å‘ç”Ÿæ”¹å˜æ—¶ï¼Œæ‰æ›´æ–°å…¨å±€è®¡æ•°
            if (this.isSoloed !== state) {
                this.isSoloed = state;
                // æ›´æ–°å…¨å±€è®¡æ•°ï¼šå¼€å¯åˆ™åŠ 1ï¼Œå…³é—­åˆ™å‡1
                STATE.soloCount += this.isSoloed ? 1 : -1;

                const btn = this.headerEl.querySelector('.solo-btn');
                if (btn) btn.classList.toggle('active-solo', this.isSoloed);
            }
        }

        renderUI() {
            // 1. åˆ›å»º Header å®¹å™¨
            const headerDiv = document.createElement('div');
            headerDiv.className = 'track-header';
            headerDiv.style.position = 'relative';

            // 2. åˆ›å»ºç¼–ç»„æŒ‡ç¤ºæ¡
            const groupIndicator = document.createElement('div');
            groupIndicator.className = 'group-indicator';
            groupIndicator.id = `group-ind-${this.id}`;
            headerDiv.appendChild(groupIndicator);

            // ============================================================
            // ğŸ”¥ ä¿®å¤ç‚¹ï¼šå¿…é¡»å…ˆå®šä¹‰ contentDivï¼Œæ‰èƒ½æ“ä½œå®ƒ
            // ============================================================
            const contentDiv = document.createElement('div');

            // 3. è®¾ç½® HTML ç»“æ„ (åŒ…å«é¢œè‰²æŒ‰é’®çš„å ä½ç¬¦ .track-color-slot)
            contentDiv.innerHTML = `
                <div class="track-name" title="${this.name}">${this.name}</div>
                <div class="track-controls">
                    <div class="track-color-slot"></div>
                    <button class="btn-sm mute-btn" title="Mute">M</button>
                    <button class="btn-sm solo-btn" title="Solo">S</button>
                    <span style="font-size:10px; color:#888;">${this.type.toUpperCase()}</span>
                </div>
            `;

            // 4. å°†å†…å®¹åŠ å…¥ Header
            headerDiv.appendChild(contentDiv);
            DOM.headers.appendChild(headerDiv);

            this.headerEl = headerDiv;
            this.nameEl = headerDiv.querySelector('.track-name');

            // 5. åˆ›å»º Lane (è½¨é“æ¡)
            const laneDiv = document.createElement('div');
            laneDiv.className = 'track-lane';
            laneDiv.id = `lane-${this.id}`;
            DOM.lanes.appendChild(laneDiv);
            this.laneEl = laneDiv;

            // ============================================================
            // ğŸ”¥ é¢œè‰²æŒ‰é’®é€»è¾‘ (ColorPickerMgr)
            // ============================================================

            // åˆ›å»ºé¢œè‰²è§¦å‘å™¨æŒ‰é’®
            const colorTrigger = document.createElement('div');
            colorTrigger.className = 'color-trigger-btn';
            colorTrigger.style.backgroundColor = this.ownColor;
            colorTrigger.title = "æ›´æ”¹è½¨é“é¢œè‰²";

            // å…³é”®ï¼šæ‰¾åˆ°åˆšæ‰é¢„ç•™çš„æ’æ§½ï¼ŒæŠŠæŒ‰é’®æ’è¿›å»
            const slot = contentDiv.querySelector('.track-color-slot');
            if (slot) {
                slot.appendChild(colorTrigger);
            }

            // ç»‘å®šäº‹ä»¶
            colorTrigger.addEventListener('mousedown', (e) => e.stopPropagation());
            colorTrigger.addEventListener('click', (e) => {
                e.stopPropagation();

                const oldColor = this.ownColor;

                ColorPickerMgr.open(
                    this.ownColor,
                    ` - ${this.name}`,
                    (finalColor) => {
                        // Confirm å›è°ƒ
                        if (finalColor !== oldColor) {
                            HistoryMgr.add({
                                type: 'change_color',
                                trackId: this.id,
                                oldColor: oldColor,
                                newColor: finalColor
                            });
                        }
                    },
                    (previewColor) => {
                        // Preview å›è°ƒ
                        this.ownColor = previewColor;
                        colorTrigger.style.backgroundColor = previewColor;

                        // è”åŠ¨ï¼šå¦‚æœå·²ç¼–ç»„ï¼Œè‡ªåŠ¨è§£æ•£
                        if (this.groupId) {
                            if (STATE.groups[this.groupId]) {
                                STATE.groups[this.groupId].trackIds.delete(this.id);
                            }
                            this.groupId = null;
                        }
                        this.refreshColor();
                        if (!STATE.isPlaying) {
                            renderer.render(scene, camera);
                        }
                    }
                );
            });

            // ============================================================
            // ä¸‹é¢æ˜¯åŸæœ‰çš„é€‰ä¸­ã€Muteã€Solo äº‹ä»¶ç»‘å®š...
            // ============================================================

            // B. ç‚¹å‡»é€‰ä¸­é€»è¾‘ (Left Click)
            headerDiv.addEventListener('mousedown', (e) => {
                // ... (ä¿æŒä½ åŸæœ‰çš„é€‰ä¸­é€»è¾‘ä¸å˜) ...
                if (e.target.tagName === 'BUTTON' || e.target.classList.contains('color-trigger-btn')) {
                    return;
                }
                if (e.button !== 0) return;
                // é˜²æ­¢ç‚¹å‡»é¢œè‰²é€‰æ‹©å™¨æˆ–è¾“å…¥æ¡†æ—¶è§¦å‘è½¨é“é€‰ä¸­
                if (e.target.tagName === 'INPUT') return;

                e.preventDefault();

                if (e.shiftKey) {
                    if (STATE.lastSelectedTrackId !== null) {
                        selectTrackRange(STATE.lastSelectedTrackId, this.id);
                    } else {
                        selectSingleTrack(this.id);
                    }
                }
                else if (e.ctrlKey || e.metaKey) {
                    toggleTrackSelection(this.id);
                }
                else {
                    selectSingleTrack(this.id);
                }
            });

            // C. å³é”®èœå•
            headerDiv.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (!STATE.selectedTrackIds.has(this.id)) {
                    selectSingleTrack(this.id);
                }
                showContextMenu(e.clientX, e.clientY);
            });

            // Mute / Solo æŒ‰é’®é€»è¾‘
            const muteBtn = contentDiv.querySelector('.mute-btn');
            const soloBtn = contentDiv.querySelector('.solo-btn');

            soloBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (STATE.selectedTrackIds.has(this.id)) {
                    const targetSoloState = !this.isSoloed;
                    STATE.selectedTrackIds.forEach(id => {
                        const track = STATE.tracks.find(t => t.id === id);
                        if (track) track.setSolo(targetSoloState);
                    });
                } else {
                    this.setSolo(!this.isSoloed);
                }
                updateAllTracksVisibility();
            });

            muteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (STATE.selectedTrackIds.has(this.id)) {
                    const targetMuteState = !this.isMuted;
                    STATE.selectedTrackIds.forEach(id => {
                        const track = STATE.tracks.find(t => t.id === id);
                        if (track) track.setMute(targetMuteState);
                    });
                } else {
                    this.setMute(!this.isMuted);
                }
                updateAllTracksVisibility();
            });
        }

        // åˆ·æ–°é¢œè‰²æ˜¾ç¤ºï¼ˆClip å’Œ 3D å¯¹è±¡ï¼‰
        refreshColor() {
            const finalColor = this.getEffectiveColor();

            // 1. æ›´æ–°å·¦ä¾§æŒ‡ç¤ºæ¡ (å¦‚æœæœ‰ç¼–ç»„)
            const ind = this.headerEl.querySelector('.group-indicator');
            if (this.groupId) {
                ind.style.backgroundColor = finalColor;
            } else {
                ind.style.backgroundColor = 'transparent';
            }

            // 2. æ›´æ–°è¯¥è½¨é“ä¸‹æ‰€æœ‰ Clip çš„é¢œè‰²
            this.clips.forEach(clip => {
                clip.updateColor(finalColor);
            });
            if (typeof renderer !== 'undefined' && !STATE.isPlaying) {
                renderer.render(scene, camera);
            }
        }

        addClip(start, duration, data, name, sourceFile = null) {
            const clip = new Clip(this, start, duration, data, name, sourceFile);
            this.clips.push(clip);
            STATE.clips.push(clip);

            clip.updateColor(this.getEffectiveColor());
            return clip;
        }

        clearClips() {
            // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šæ¸…é™¤ Clip æ—¶ï¼Œå¿…é¡»åŒæ­¥ä»å…¨å±€ STATE.clips ä¸­ç§»é™¤ ğŸ”¥ğŸ”¥ğŸ”¥
            this.clips.forEach(c => {
                c.destroy(); // é”€æ¯ DOM å’Œ 3D èµ„æº

                // ä»å…¨å±€ç¼“å­˜ä¸­å‰”é™¤ï¼Œé˜²æ­¢æ»‘å—è°ƒèŠ‚æ—¶â€œåƒµå°¸å¤æ´»â€
                const globalIdx = STATE.clips.indexOf(c);
                if (globalIdx > -1) {
                    STATE.clips.splice(globalIdx, 1);
                }
            });

            // æ¸…ç©ºå½“å‰è½¨é“çš„å¼•ç”¨
            this.clips = [];
        }

        // ğŸ”¥ æ–°å¢ï¼šç”¨äºæ›´æ–°è½¨é“åç§°çš„æ–¹æ³•
        setName(newName) {
            if (!newName) return;
            this.name = newName;
            if (this.nameEl) {
                this.nameEl.innerText = newName;
                this.nameEl.title = newName;
            }
        }
    }

    class Clip {
        constructor(track, start, duration, data, name, sourceFile = null) {
            this.track = track;
            this.startTime = start;
            this.duration = duration;
            this.data = data;
            this.name = name;
            this.sourceFile = sourceFile;
            this.trimOffset = 0;
            this.dom = null;
            this.mesh = null;

            // ç¼©ç•¥å›¾ Canvas å¼•ç”¨
            this.canvas = null;

            this.renderDOM();
            this.build3D();
        }

        renderDOM() {
            const el = document.createElement('div');
            el.className = 'clip';
            // ç§»é™¤æ–‡å­—ç›´æ¥æ˜¾ç¤ºï¼Œæ”¹ä¸ºæ‚¬æµ®æ˜¾ç¤ºï¼Œæˆ–è€…æ”¾åœ¨ corner
            el.title = this.name;
            el.style.backgroundColor = hexToRgba(this.track.color, 0.3); // èƒŒæ™¯ç¨å¾®é€æ˜ä¸€ç‚¹ï¼Œä¸ºäº†çœ‹æ¸…æ³¢å½¢
            el.style.borderColor = this.track.color;

            // 1. åˆ›å»ºåå­—æ ‡ç­¾ (ç»å¯¹å®šä½åœ¨å·¦ä¸Šè§’)
            const nameLabel = document.createElement('span');
            nameLabel.className = 'clip-name';
            nameLabel.innerText = this.name;
            nameLabel.style.position = 'absolute';
            nameLabel.style.left = '5px';
            nameLabel.style.top = '2px';
            nameLabel.style.fontSize = '10px';
            nameLabel.style.color = '#fff';
            nameLabel.style.zIndex = '2';
            el.appendChild(nameLabel);

            // 2. åˆ›å»º Canvas ç”¨äºç»˜åˆ¶æ³¢å½¢/éŸ³ç¬¦
            const canvas = document.createElement('canvas');
            canvas.style.position = 'absolute';
            canvas.style.left = '0';
            canvas.style.top = '0';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.zIndex = '1';
            el.appendChild(canvas);
            this.canvas = canvas;

            this.updateDOMPosition();

            document.getElementById(`lane-${this.track.id}`).appendChild(el);
            this.dom = el;

            // æ¸²æŸ“å®Œ DOM åç«‹å³ç»˜åˆ¶ç¼©ç•¥å›¾
            // ä½¿ç”¨ setTimeout ç¡®ä¿ DOM å·²ç»æŒ‚è½½ï¼Œèƒ½è·å–åˆ°å®½é«˜
            setTimeout(() => this.drawThumbnail(), 0);

            el.addEventListener('mousedown', (e) => this.initDrag(e));
        }

        updateDOMPosition() {
            if (!this.dom) return;
            const width = this.duration * STATE.pxPerSec;
            const height = 60; // è½¨é“é«˜åº¦ï¼Œæˆ–è€…åŠ¨æ€è·å–

            this.dom.style.left = (this.startTime * STATE.pxPerSec) + 'px';
            this.dom.style.width = width + 'px';

            // åªæœ‰å½“å®½åº¦å‘ç”Ÿæ˜¾è‘—å˜åŒ–æ—¶æ‰é‡ç»˜ï¼ŒèŠ‚çœæ€§èƒ½
            // åœ¨è¿™é‡Œæˆ‘ä»¬ç®€å•å¤„ç†ï¼šæ¯æ¬¡ Zoom æ”¹å˜ä½ç½®æ—¶ï¼Œå¯èƒ½éœ€è¦é‡è®¾ canvas åˆ†è¾¨ç‡
            if (this.canvas) {
                // è®¾ç½® Canvas çš„ç‰©ç†åˆ†è¾¨ç‡ (é¿å…æ¨¡ç³Š)
                this.canvas.width = width;
                this.canvas.height = height;
                // é‡ç»˜å†…å®¹
                this.drawThumbnail();
            }
        }

        drawThumbnail() {
            if (!this.canvas) return;
            const ctx = this.canvas.getContext('2d');
            const width = this.canvas.width;
            const height = this.canvas.height;
            const color = this.track.color;

            ctx.clearRect(0, 0, width, height);

            if (this.track.type === 'midi') {
                this.drawMidiThumbnail(ctx, width, height, color);
            } else if (this.track.type === 'audio') {
                this.drawAudioThumbnail(ctx, width, height, color);
            }
        }

        drawMidiThumbnail(ctx, width, height, color) {
            if (!this.data.notes) return;

            // 1. è®¡ç®—éŸ³é«˜èŒƒå›´ï¼Œä»¥ä¾¿å°†éŸ³ç¬¦æ˜ å°„åˆ° Canvas é«˜åº¦
            let minPitch = 127, maxPitch = 0;
            // å¦‚æœæƒ³ç»Ÿä¸€æ‰€æœ‰ Clip çš„è§†é‡ï¼Œå¯ä»¥å†™æ­» minPitch=21 (A0), maxPitch=108 (C8)
            // è¿™é‡Œä½¿ç”¨"è‡ªé€‚åº” Clip å†…å®¹"çš„ç¼©æ”¾
            this.data.notes.forEach(n => {
                if (n.midi < minPitch) minPitch = n.midi;
                if (n.midi > maxPitch) maxPitch = n.midi;
            });
            // å¢åŠ ä¸€ç‚¹ padding
            const range = Math.max(12, maxPitch - minPitch); // è‡³å°‘ä¿ç•™ä¸€ä¸ªå…«åº¦çš„èŒƒå›´
            minPitch -= 2;

            ctx.fillStyle = color;

            // 2. ç»˜åˆ¶æ¯ä¸€ä¸ªéŸ³ç¬¦
            this.data.notes.forEach(note => {
                // Xè½´ï¼šç›¸å¯¹æ—¶é—´
                const x = (note.time / this.duration) * width;
                const w = (note.duration / this.duration) * width;

                // Yè½´ï¼šéŸ³é«˜ (é«˜éŸ³åœ¨ä¸Šï¼Œä½éŸ³åœ¨ä¸‹ï¼ŒCanvas 0 æ˜¯é¡¶éƒ¨ï¼Œæ‰€ä»¥è¦åè¿‡æ¥)
                // normalizedPitch: 0.0 ~ 1.0
                const normalizedPitch = (note.midi - minPitch) / range;
                const h = height / range * 2; // éŸ³ç¬¦å—é«˜åº¦ï¼Œç¨å¾®åŠ åšä¸€ç‚¹
                const y = height - (normalizedPitch * height) - h;

                // ç»˜åˆ¶çŸ©å½¢ (ç¡®ä¿æœ€å°å®½åº¦ä¸º 1px ä»¥ä¾¿å¯è§)
                ctx.fillRect(x, y, Math.max(1, w), Math.max(2, h));
            });
        }

        drawAudioThumbnail(ctx, width, height, color) {
            // éŸ³é¢‘æ•°æ®é€šå¸¸å¾ˆå¤§ï¼Œéœ€è¦é™é‡‡æ ·
            const rawData = this.data.getChannelData(0); // è·å–å·¦å£°é“
            const step = Math.ceil(rawData.length / width); // æ¯ä¸ªåƒç´ ä»£è¡¨å¤šå°‘ä¸ªé‡‡æ ·ç‚¹
            const amp = height / 2;

            ctx.fillStyle = color;
            ctx.beginPath();

            // ç»˜åˆ¶æ³¢å½¢ï¼šç®€æ˜“ç‰ˆ (ç»˜åˆ¶å‡æ–¹æ ¹æˆ–å³°å€¼)
            for (let i = 0; i < width; i++) {
                let min = 1.0;
                let max = -1.0;

                // æ‰¾å‡ºå½“å‰åƒç´ å¯¹åº”çš„æ—¶é—´çª—å£å†…çš„æœ€å¤§æœ€å°å€¼
                let startIndex = i * step;
                for (let j = 0; j < step; j++) {
                    const datum = rawData[startIndex + j];
                    if (datum < min) min = datum;
                    if (datum > max) max = datum;
                }

                // å°† -1~1 æ˜ å°„åˆ° Canvas é«˜åº¦
                const yLow = (1 + min) * amp;
                const yHigh = (1 + max) * amp;

                // ç»˜åˆ¶ä¸€æ¡ç«–çº¿ä»£è¡¨æ³¢å³°æ³¢è°·
                ctx.fillRect(i, height - yHigh, 1, yHigh - yLow);
            }
        }

        updateColor(color) {
            if(this.dom) {
                this.dom.style.backgroundColor = hexToRgba(color, 0.5);
                this.dom.style.borderColor = color;
            }
            this.drawThumbnail();

            if (this.mesh) {
                // å¦‚æœæ˜¯ MIDI (ShaderMaterial)
                if (this.track.type === 'midi') {
                    // æ³¨æ„ï¼šInstancedMesh çš„æè´¨åœ¨ mesh.material
                    const mat = this.mesh.material;
                    if (mat && mat.uniforms) {
                        // ç›´æ¥ä½¿ç”¨ .set() æ–¹æ³•æ›´æ–°ï¼Œè¿™æ ·ä¸ä¼šä¸¢å¤±å¼•ç”¨
                        mat.uniforms.uBaseColor.value.set(color).multiplyScalar(0.8);
                        mat.uniforms.uActiveColor.value.set(color).multiplyScalar(1.5).addScalar(0.3);
                        // æ ‡è®°æè´¨éœ€è¦æ›´æ–°ï¼ˆå¯é€‰ï¼Œé€šå¸¸æ›´æ–° value å³å¯ï¼‰
                    }
                }
                // å¦‚æœæ˜¯ Audio (MeshBasicMaterial)
                else {
                    const mat = this.mesh.children[0].material;
                    if (mat) mat.color.set(color);
                }
            }
        }

        initDrag(e) {
            e.preventDefault();
            e.stopPropagation(); // é˜²æ­¢å†’æ³¡åˆ° timeline è§¦å‘ scrubbing

            const startX = e.clientX;
            const startLeft = parseFloat(this.dom.style.left) || 0;

            // ğŸ”¥ è®°å½•å¼€å§‹æ—¶çš„çŠ¶æ€ (ç”¨äº Undo)
            const originalStartTime = this.startTime;

            const onMove = (mv) => {
                const deltaPx = mv.clientX - startX;
                let newLeft = startLeft + deltaPx;
                if(newLeft < 0) newLeft = 0;

                this.startTime = newLeft / STATE.pxPerSec;
                this.dom.style.left = newLeft + 'px';
                this.update3DPosition();
                updateTotalDuration();
            };

            const onUp = () => {
                window.removeEventListener('mousemove', onMove);
                window.removeEventListener('mouseup', onUp);

                // ğŸ”¥ æ‹–æ‹½ç»“æŸï¼šå¦‚æœæ—¶é—´å˜äº†ï¼ŒåŠ å…¥å†å²
                if (Math.abs(this.startTime - originalStartTime) > 0.01) {
                    HistoryMgr.add({
                        type: 'move_clip',
                        clip: this, // ä¿å­˜å¼•ç”¨
                        oldStart: originalStartTime,
                        newStart: this.startTime
                    });
                }
            };

            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onUp);
        }

        // --- 3D æ„å»ºé€»è¾‘ ---
        build3D() {
            if (this.track.type === 'midi') {
                this.buildMidiMesh();
            } else if (this.track.type === 'audio') {
                this.buildAudioMesh();
            }
            if (this.mesh) {
                // æˆ‘ä»¬éœ€è¦é‡æ–°è®¡ç®—å½“å‰ Clip æ˜¯å¦åº”è¯¥å¯è§
                const hasSolo = STATE.tracks.some(t => t.isSoloed);
                let shouldBeVisible = true;
                if (hasSolo) {
                    shouldBeVisible = this.track.isSoloed && !this.track.isMuted;
                } else {
                    shouldBeVisible = !this.track.isMuted;
                }
                this.mesh.visible = shouldBeVisible;
            }
        }

        buildMidiMesh() {
            // æ¸…ç†æ—§çš„
            if (this.mesh) { scene.remove(this.mesh); }

            const notes = this.data.notes;
            if (!notes || notes.length === 0) return;

            let geometry;

            // ... (ä¿æŒåŸæœ¬çš„å½¢çŠ¶åˆ¤æ–­ switch case ä»£ç ä¸å˜) ...
            switch (STATE.noteShape) {
                case 'box': geometry = new THREE.BoxGeometry(1, 1, 1); break;
                case 'box-line': geometry = new THREE.BoxGeometry(1, 1, 1); break;
                case 'cylinder': geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16); geometry.rotateZ(Math.PI / 2); break;
                case 'hexagon': geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 6); geometry.rotateZ(Math.PI / 2); break;
                case 'diamond': geometry = new THREE.OctahedronGeometry(0.5); break;
                case 'torus': geometry = new THREE.TorusGeometry(0.4, 0.15, 8, 20); break;
                case 'knot': geometry = new THREE.TorusKnotGeometry(0.35, 0.1, 32, 8); break;
                case 'cone': geometry = new THREE.ConeGeometry(0.5, 1, 16); geometry.rotateZ(Math.PI / 2); break;
                case 'custom':
                    geometry = customGeometry ? customGeometry.clone() : new THREE.SphereGeometry(0.5, 16, 16);
                    break;
                case 'capsule':
                default: geometry = new THREE.SphereGeometry(0.5, 16, 16); break;
            }

            geometry.boundingSphere = new THREE.Sphere(new THREE.Vector3(), 10000000);

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uPlayheadX: { value: 0 },
                    uGlowRadius: { value: 35.0 },
                    uBaseColor: { value: new THREE.Color(this.track.color).multiplyScalar(0.8) },
                    uActiveColor: { value: new THREE.Color(this.track.color).multiplyScalar(1.5).addScalar(0.3) },
                    uHighlightColor: { value: currentHighlightColor },
                    uHighlightWidth: { value: currentHighlightWidth },
                    uShowEdges: { value: STATE.noteShape === 'box-line' ? 1.0 : 0.0 }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                transparent: true,
                side: THREE.DoubleSide,
                depthTest: true,
                depthWrite: true
            });

            const mesh = new THREE.InstancedMesh(geometry, material, notes.length);
            mesh.frustumCulled = false;
            const extraLengths = new Float32Array(notes.length);
            const dummy = new THREE.Object3D();

            const minPitch = 21;
            const pitchRange = 88;
            const heightStep = (60 / pitchRange) * STATE.noteHeightScale;

            // ğŸ”¥ ä¼˜åŒ–ï¼šç›´æ¥è¯»å–ç¼“å­˜çš„æ’åï¼Œä¸å†é‡å¤è®¡ç®—
            const myRank = this.track.zRank || 0;
            const zStep = STATE.zSeparation;
            const zOffset = myRank * zStep;

            notes.forEach((note, i) => {
                const noteTime = note.time;
                const duration = note.duration;

                const x = (noteTime * STATE.playbackSpeed) + (duration * STATE.playbackSpeed / 2);
                const centerOffset = 30 * STATE.noteHeightScale;
                const y = (note.midi - minPitch) * heightStep - centerOffset;

                const width3D = duration * STATE.playbackSpeed;
                const thickness = 0.8 * heightStep * STATE.noteThickness;

                // åº”ç”¨ä½ç½® (ç›´æ¥ä½¿ç”¨ zOffset)
                dummy.position.set(x, y, zOffset);
                dummy.scale.set(thickness, thickness, thickness * 0.9);

                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);

                let extraLen = (width3D / thickness) - 1.0;
                extraLengths[i] = Math.max(0, extraLen);
            });

            geometry.setAttribute('aExtraLength', new THREE.InstancedBufferAttribute(extraLengths, 1));

            // ğŸ”¥ è®¡ç®—åŒ…å›´çƒï¼Œå¼€å¯å‰”é™¤
            mesh.geometry.computeBoundingSphere();
            // ç”±äºæ˜¯ InstancedMeshï¼Œæˆ‘ä»¬éœ€è¦æ‰‹åŠ¨æ‰©å¤§åŒ…å›´çƒä»¥è¦†ç›–æ‰€æœ‰å®ä¾‹
            // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„ä¼°ç®—æ–¹æ³•ï¼Œè¦†ç›–æ•´é¦–æ­Œçš„é•¿åº¦
            const durationX = this.duration * STATE.playbackSpeed;
            const centerX = this.startTime * STATE.playbackSpeed + durationX / 2;
            const radius = Math.max(durationX, 2000); // ä¼°ç®—åŠå¾„

            mesh.boundingSphere = new THREE.Sphere(new THREE.Vector3(centerX, 0, 0), radius);
            mesh.frustumCulled = true; // âœ… å¼€å¯å‰”é™¤

            this.mesh = mesh; // ç›´æ¥èµ‹å€¼
            scene.add(this.mesh);
            this.update3DPosition();
        }

        buildAudioMesh() {
            // 1. æ¸…ç†æ—§æ¨¡å‹
            if (this.mesh) {
                this.mesh.traverse((child) => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    }
                });
                scene.remove(this.mesh);
            }

            const rawData = this.data.getChannelData(0);
            const visualWidth = this.duration * STATE.playbackSpeed;

            const density = 0.4;
            let samples = Math.floor(visualWidth * density);
            samples = Math.max(10, Math.min(50000, samples));
            const step = Math.floor(rawData.length / samples);

            // ==========================================
            // æ ·å¼é…ç½®
            // ==========================================
            const baseMidiHeight = 60 * STATE.noteHeightScale;
            const maxAmp = baseMidiHeight / 2;
            const finalScale = maxAmp * STATE.audioGain;

            // ğŸ”¥ çº¿æ¡ç²—ç»†ï¼šé€šè¿‡è¿™é‡Œæ§åˆ¶çº¿çš„è§†è§‰å®½åº¦
            // 0.2 ~ 0.8 æ¯”è¾ƒåˆé€‚ï¼Œè¶Šå¤§çº¿è¶Šç²—
            const lineWidth = 0.2;

            // 2. åˆ›å»ºä¸€ä¸ªåŸºç¡€å‡ ä½•ä½“ (é•¿æ–¹ä½“æŸ±å­)
            // å®½=1, é«˜=1, æ·±=1 (ç¨åé€šè¿‡ç¼©æ”¾æ¥è°ƒæ•´é«˜åº¦)
            const geometry = new THREE.BoxGeometry(1, 1, 1);

            // 3. æè´¨ (ä¸å†éœ€è¦é€æ˜åº¦æ¥æŠ—é”¯é½¿äº†ï¼Œå®å¿ƒçš„æœ€å¥½çœ‹)
            const material = new THREE.MeshBasicMaterial({
                color: this.track.color,
                transparent: true,      // å¿…é¡»å¼€å¯é€æ˜
                opacity: 0.25,          // é™ä½ä¸é€æ˜åº¦ (0.2 - 0.3 æ•ˆæœè¾ƒå¥½)
                depthWrite: false,      // å…³é—­æ·±åº¦å†™å…¥ï¼Œè®©æ³¢å½¢çœ‹èµ·æ¥æ›´åƒâ€œå¹½çµâ€èƒŒæ™¯
                side: THREE.DoubleSide
            });

            // 4. åˆ›å»ºå®ä¾‹åŒ–ç½‘æ ¼ (ä¸€æ¬¡æ€§æ¸²æŸ“ samples ä¸ªæŸ±å­)
            const mesh = new THREE.InstancedMesh(geometry, material, samples);
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // æ ‡è®°ä¸ºåŠ¨æ€ï¼Œè™½ç„¶è¿™é‡Œåªè®¾ç½®ä¸€æ¬¡

            const dummy = new THREE.Object3D();

            for (let i = 0; i < samples; i++) {
                const index = Math.min(i * step, rawData.length - 1);
                let val = rawData[index];

                if (isNaN(val) || !isFinite(val)) val = 0;

                // é™åˆ¶æŒ¯å¹…
                val = val * finalScale;
                const limit = baseMidiHeight * 0.5;
                val = Math.max(-limit, Math.min(limit, val));

                // è®¡ç®— X è½´ä½ç½®
                const x = (i / samples) * (this.duration * STATE.playbackSpeed);

                // è®¡ç®—æ€»é«˜åº¦ (ä¸Šä¸‹æŒ¯å¹…æ€»å’Œ = val * 2)
                // åªè¦ç»å¯¹å€¼å¤ªå°ï¼Œå°±ç»™ä¸€ä¸ªæœ€å°é«˜åº¦ï¼Œé˜²æ­¢çœ‹ä¸è§
                const totalHeight = Math.max(0.2, Math.abs(val * 2));

                // ğŸ”¥ æ ¸å¿ƒå˜æ¢é€»è¾‘
                // 1. ä½ç½®: x, 0, -15 (ä¸­å¿ƒç‚¹åœ¨ 0ï¼Œå‘ä¸Šä¸‹å»¶ä¼¸)
                dummy.position.set(x, 0, -15);

                // 2. ç¼©æ”¾: xæ–¹å‘=çº¿å®½, yæ–¹å‘=é«˜åº¦, zæ–¹å‘=åšåº¦
                // STATE.playbackSpeed / 20 æ˜¯ä¸ºäº†è®©çº¿å®½éšç¼©æ”¾ç¨å¾®é€‚é…ï¼Œæˆ–è€…ç›´æ¥å†™æ­» lineWidth
                dummy.scale.set(lineWidth, totalHeight, 0.5);

                dummy.updateMatrix();

                // è®¾ç½®ç¬¬ i ä¸ªæŸ±å­çš„çŸ©é˜µ
                mesh.setMatrixAt(i, dummy.matrix);
            }

            mesh.instanceMatrix.needsUpdate = true;
            mesh.frustumCulled = false;

            this.mesh = new THREE.Group();
            this.mesh.add(mesh);

            scene.add(this.mesh);
            this.update3DPosition();
        }

        update3DPosition() {
            if (this.mesh) {
                // 3D åœºæ™¯é‡Œçš„ä½ç½® = Clip å¼€å§‹æ—¶é—´ * æ’­æ”¾é€Ÿåº¦
                this.mesh.position.x = this.startTime * STATE.playbackSpeed;
            }
        }

        rebuildMesh() {
            // é¢œè‰²æ”¹å˜æ—¶è°ƒç”¨
            this.build3D();
        }

        // åœ¨ class Clip ä¸­
        destroy() {
            if (this.dom) this.dom.remove();

            if (this.mesh) {
                // é€’å½’éå†æ‰€æœ‰å­å¯¹è±¡
                this.mesh.traverse((child) => {
                    if (child.isMesh || child.isLine || child.isLineSegments) {
                        // 1. é‡Šæ”¾å‡ ä½•ä½“ (æ˜¾å­˜å¤§å¤´)
                        if (child.geometry) {
                            child.geometry.dispose();
                        }

                        // 2. é‡Šæ”¾æè´¨å’Œè´´å›¾
                        if (child.material) {
                            // å¤„ç†æè´¨æ•°ç»„
                            const mats = Array.isArray(child.material) ? child.material : [child.material];

                            mats.forEach(m => {
                                // é‡Šæ”¾æè´¨æœ¬èº«
                                m.dispose();

                                // ğŸ”¥ å…³é”®ï¼šé‡Šæ”¾æè´¨ä¸Šçš„è´´å›¾ (Texture)
                                // å¦‚æœä¸é‡Šæ”¾è¿™ä¸ªï¼Œæ˜¾å­˜ä¼šä¸€ç›´æ¶¨
                                for (const key of Object.keys(m)) {
                                    const val = m[key];
                                    if (val && val.isTexture) {
                                        val.dispose();
                                    }
                                }

                                // é‡Šæ”¾ ShaderMaterial çš„ uniforms é‡Œçš„è´´å›¾
                                if (m.uniforms) {
                                    for (const key of Object.keys(m.uniforms)) {
                                        const val = m.uniforms[key].value;
                                        if (val && val.isTexture) {
                                            val.dispose();
                                        }
                                    }
                                }
                            });
                        }
                    }
                });

                // ä»åœºæ™¯ç§»é™¤
                scene.remove(this.mesh);
            }

            // é‡Šæ”¾ç¼©ç•¥å›¾ Canvas å†…å­˜
            if (this.canvas) {
                this.canvas.width = 0;
                this.canvas.height = 0;
                this.canvas = null;
            }

            // æ–­å¼€å¼•ç”¨
            this.mesh = null;
            this.dom = null;
            this.data = null; // é‡Šæ”¾éŸ³é¢‘/MIDIæ•°æ®å¼•ç”¨
        }
    }

    function selectSingleTrack(id) {
        STATE.selectedTrackIds.clear();
        STATE.selectedTrackIds.add(id);

        STATE.lastSelectedTrackId = id; // ğŸ”¥ è®°å½•é”šç‚¹

        updateSelectionUI();
    }

    // ==========================================
    // ğŸ’¾ State Persistence (Modified bindToggle)
    // ==========================================

    function bindToggle(headerId, contentId, defaultDisplay, storageKey) {
        const header = document.getElementById(headerId);
        const content = document.getElementById(contentId);

        if (header && content) {
            // 1. Check LocalStorage on Load
            // If user previously closed it, 'none' will be returned.
            // If it's the first visit, savedState is null, so we use defaultDisplay.
            const savedState = localStorage.getItem(storageKey);
            const initialState = savedState !== null ? savedState : defaultDisplay;

            // Apply initial state
            content.style.display = initialState;
            header.style.opacity = initialState === 'none' ? '0.7' : '1';

            // 2. Click Event
            header.addEventListener('click', () => {
                if (content.style.display === 'none') {
                    // Expand
                    content.style.display = defaultDisplay;
                    header.style.opacity = '1';
                } else {
                    // Collapse
                    content.style.display = 'none';
                    header.style.opacity = '0.7';
                }

                // 3. Save new state to LocalStorage
                localStorage.setItem(storageKey, content.style.display);
            });
        }
    }

    // Bind Top-Right Panel (View Parameters)
    // Key: 'mv_viz_panel_state'
    bindToggle('viz-header', 'viz-content', 'block', 'mv_viz_panel_state');

    // Bind Top-Left Panel (Shortcuts)
    // Key: 'mv_shortcut_panel_state'
    bindToggle('shortcut-header', 'shortcut-content', 'grid', 'mv_shortcut_panel_state');

    // ğŸ”¥ æ ¸å¿ƒï¼šèŒƒå›´é€‰æ‹©é€»è¾‘
    function selectTrackRange(startId, endId) {
        // 1. æ‰¾åˆ°ä¸¤ä¸ªè½¨é“åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•ä½ç½®
        const startIndex = STATE.tracks.findIndex(t => t.id === startId);
        const endIndex = STATE.tracks.findIndex(t => t.id === endId);

        if (startIndex === -1 || endIndex === -1) return;

        // 2. ç¡®å®šèŒƒå›´çš„æœ€å°å’Œæœ€å¤§ç´¢å¼•
        const min = Math.min(startIndex, endIndex);
        const max = Math.max(startIndex, endIndex);

        // 3. ç»å…¸çš„ Shift é€‰æ‹©é€»è¾‘é€šå¸¸ä¼šæ¸…é™¤ä¹‹å‰çš„é›¶æ•£é€‰æ‹©ï¼Œåªä¿ç•™è¿™æ®µèŒƒå›´
        // å¦‚æœä½ å¸Œæœ›ä¿ç•™ä¹‹å‰çš„é€‰æ‹©ï¼Œå¯ä»¥æ³¨é‡Šæ‰ä¸‹é¢è¿™è¡Œ
        STATE.selectedTrackIds.clear();

        // 4. å¾ªç¯é€‰ä¸­èŒƒå›´å†…æ‰€æœ‰è½¨é“
        for (let i = min; i <= max; i++) {
            STATE.selectedTrackIds.add(STATE.tracks[i].id);
        }

        updateSelectionUI();

        // æ³¨æ„ï¼šShiftæ“ä½œé€šå¸¸ä¸æ›´æ–° lastSelectedTrackIdï¼Œ
        // æˆ–è€…æ›´æ–°ä¸ºå½“å‰ç‚¹å‡»çš„ï¼Œè¿™å–å†³äºä½ ä¹ æƒ¯å“ªç§æ“ä½œæµã€‚
        // è¿™é‡Œæˆ‘ä»¬æš‚ä¸æ›´æ–°é”šç‚¹ï¼Œè¿™æ ·ä½ å¯ä»¥è¿ç»­ Shift+ç‚¹å‡»æ¥è°ƒæ•´èŒƒå›´è¾¹ç•Œã€‚
    }

    document.getElementById('clearTextureBtn').addEventListener('click', () => {
        // ğŸ”¥ ä¿®æ­£ç‚¹ 1ï¼šæŠŠ getCurrentWorldParams() æ”¹ä¸º getCurrentSpherical()
        // æ£€æŸ¥æ˜¯å¦æœ‰ä¸œè¥¿å¯ä»¥æ¸…é™¤ (åŒ…æ‹¬æ£€æŸ¥è§†è§’æ˜¯å¦æ˜¯é»˜è®¤å€¼)
        const currentView = ViewMgr.getCurrentSpherical();
        const isViewDefault = JSON.stringify(currentView) === JSON.stringify(ViewMgr.defaults);

        const hasVisuals = currentBgBase64 || !isViewDefault;

        if (hasVisuals) {
            // ğŸ”¥ 1. è®°å½•å†å²
            HistoryMgr.add({
                type: 'clear_visuals',
                // ä¿å­˜æ—§çš„è§†è§‰æ•°æ®
                oldBgData: currentBgBase64,
                oldBgType: currentBgType,
                // ğŸ”¥ ä¿®æ­£ç‚¹ 2ï¼šè¿™é‡Œä¹Ÿè¦æ”¹ä¸º getCurrentSpherical()
                oldView: currentView
            });

            // ... (ä¸­é—´çš„æ¸…é™¤ä»£ç ä¿æŒä¸å˜) ...
            currentHighlightColor.setHex(0xffffff);
            const hlInput = document.getElementById('highlightColorInput');
            if(hlInput) hlInput.value = "#ffffff";

            STATE.clips.forEach(clip => {
                if (clip.mesh && clip.track.type === 'midi') {
                    clip.mesh.children.forEach(child => {
                        if (child.material && child.material.uniforms) {
                            child.material.uniforms.uHighlightColor.value.setHex(0xffffff);
                        }
                    });
                }
            });
            refreshAllMidiMeshes();

            // --- æ¸…é™¤èƒŒæ™¯ ---
            if (bgMesh) bgMesh.visible = false;
            if (bgMaterial && bgMaterial.uniforms.tMap) bgMaterial.uniforms.tMap.value = null;
            if (bgVideoElement) {
                bgVideoElement.pause();
                bgVideoElement.src = "";
                bgVideoElement.load();
                bgVideoElement = null;
            }
            currentBgBase64 = null;
            currentBgType = null;
            bgTexture = null;

            // --- 3. é‡ç½®è§†è§’ ---
            ViewMgr.reset();

            const starToggle = document.getElementById('starfieldToggle');
            if (starToggle) {
                // åˆå§‹åŒ–ï¼šé»˜è®¤å¼€å¯
                setStarfieldState(true);

                starToggle.addEventListener('change', (e) => {
                    setStarfieldState(e.target.checked);
                });
            }

            setStarfieldState(true);

            requestAnimationFrame(() => {
                onResize();
            });

            console.log("å·²æ¸…é™¤è§†è§‰æ•ˆæœåŠè§†è§’ (å¯æŒ‰ Ctrl+Z æ’¤å›)");
        }
    });

    function initPreviewSystem() {
        const container = document.getElementById('preview-canvas-container');
        const width = container.clientWidth;
        const height = container.clientHeight;

        // 1. åˆå§‹åŒ–ç‹¬ç«‹åœºæ™¯
        previewScene = new THREE.Scene();
        previewScene.background = new THREE.Color(0x111111);

        // æ·»åŠ è¾…åŠ©ç½‘æ ¼ (Grid)
        const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
        previewScene.add(gridHelper);

        // æ·»åŠ åæ ‡è½´è¾…åŠ© (çº¢X ç»¿Y è“Z)
        const axesHelper = new THREE.AxesHelper(3);
        previewScene.add(axesHelper);

        // 2. ç›¸æœº
        previewCamera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
        previewCamera.position.set(0, 5, 10);
        previewCamera.lookAt(0, 0, 0);

        // 3. ç¯å…‰ (ä¸ºäº†çœ‹æ¸…æ¨¡å‹ç»“æ„)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        previewScene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        previewScene.add(dirLight);

        // 4. æ¸²æŸ“å™¨
        previewRenderer = new THREE.WebGLRenderer({ antialias: true });
        previewRenderer.setSize(width, height);
        container.appendChild(previewRenderer.domElement);

        // 5. ç®€å•çš„è½¨é“æ§åˆ¶
        previewControls = new OrbitControls(previewCamera, previewRenderer.domElement);
        previewControls.enableDamping = true;

        // 6. ç»‘å®šæ»‘å—äº‹ä»¶
        ['rot-x', 'rot-y', 'rot-z'].forEach(id => {
            document.getElementById(id).addEventListener('input', updatePreviewRotation);
        });

        // 7. ç»‘å®šæŒ‰é’®
        document.getElementById('cancelPreviewBtn').addEventListener('click', closePreviewModal);
        document.getElementById('confirmImportBtn').addEventListener('click', confirmImportModel);

        // çª—å£å¤§å°å˜åŒ–ç›‘å¬
        const resizeObserver = new ResizeObserver(() => {
            if(container.clientWidth > 0) {
                previewCamera.aspect = container.clientWidth / container.clientHeight;
                previewCamera.updateProjectionMatrix();
                previewRenderer.setSize(container.clientWidth, container.clientHeight);
            }
        });
        resizeObserver.observe(container);
    }

    function openPreviewModal(geometry, material) {
        document.getElementById('model-preview-modal').style.display = 'flex';
        if (!previewRenderer) initPreviewSystem();

        tempLoadedGeometry = geometry.clone();
        tempLoadedMaterial = material; // ğŸ”¥ ä¿å­˜æè´¨

        // ... é‡ç½®æ»‘å— ...

        createPreviewMeshes(geometry, material); // ä¼ é€’ä¸‹å»
        animatePreview();
    }

    function closePreviewModal() {
        document.getElementById('model-preview-modal').style.display = 'none';
        cancelAnimationFrame(previewAnimationId);
        // æ¸…ç†å†…å­˜
        if(previewMeshOriginal) {
            previewScene.remove(previewMeshOriginal);
            previewMeshOriginal = null;
        }
        if(previewMeshStretched) {
            previewScene.remove(previewMeshStretched);
            previewMeshStretched = null;
        }
    }

    function createPreviewMeshes(geometry, material) {
        // ... æ¸…ç†æ—§ Mesh ...
        if (previewMeshOriginal) previewScene.remove(previewMeshOriginal);
        if (previewMeshStretched) previewScene.remove(previewMeshStretched);

        // --- 1. å·¦ä¾§ï¼šä½¿ç”¨åŸå§‹æè´¨ (å¦‚æœæœ‰) ---
        let matOriginal;
        let mapTexture = null;

        if (material) {
            matOriginal = material; // ç›´æ¥ç”¨åŸå§‹æè´¨
            if (material.map) mapTexture = material.map; // æå–è´´å›¾
        } else {
            matOriginal = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
        }

        previewMeshOriginal = new THREE.Mesh(geometry, matOriginal);
        previewMeshOriginal.position.set(-2, 0, 0);
        previewScene.add(previewMeshOriginal);

        // --- 2. å³ä¾§ï¼šæ¨¡æ‹Ÿæ‹‰ä¼¸ ---
        const useTextureChecked = document.getElementById('preview-use-texture').checked;

        // åªæœ‰å½“æœ‰è´´å›¾ ä¸” å‹¾é€‰äº†ä¿ç•™æè´¨æ—¶ï¼Œæ‰å¯ç”¨
        const enableTexture = useTextureChecked && (mapTexture !== null);

        // å¯ç”¨å¤é€‰æ¡†çŠ¶æ€æ›´æ–°
        const checkbox = document.getElementById('preview-use-texture');
        checkbox.disabled = !mapTexture; // å¦‚æœæ²¡è´´å›¾ï¼Œç¦ç”¨å¤é€‰æ¡†
        if (!mapTexture) checkbox.checked = false;

        const matStretched = new THREE.ShaderMaterial({
            uniforms: {
                uPlayheadX: { value: 0 },
                uGlowRadius: { value: 10.0 },
                uBaseColor: { value: new THREE.Color(0xff00ff).multiplyScalar(0.5) }, // é»˜è®¤ç´«
                uActiveColor: { value: new THREE.Color(0xff00ff).addScalar(0.2) },
                // ğŸ”¥ ä¼ å…¥è´´å›¾
                uUseTexture: { value: enableTexture },
                uMap: { value: mapTexture || null }
            },
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            side: THREE.DoubleSide
        });

        previewMeshStretched = new THREE.Mesh(geometry.clone(), matStretched);
        previewMeshStretched.position.set(2, 0, 0);

        const count = previewMeshStretched.geometry.attributes.position.count;
        const extraLengths = new Float32Array(count).fill(4.0);
        previewMeshStretched.geometry.setAttribute('aExtraLength', new THREE.BufferAttribute(extraLengths, 1));

        previewScene.add(previewMeshStretched);
    }

    function updatePreviewRotation() {
        if (!tempLoadedGeometry) return;

        const rx = THREE.MathUtils.degToRad(document.getElementById('rot-x').value);
        const ry = THREE.MathUtils.degToRad(document.getElementById('rot-y').value);
        const rz = THREE.MathUtils.degToRad(document.getElementById('rot-z').value);

        // é‡æ–°ä»åŸå§‹æ•°æ®å…‹éš†ï¼Œé¿å…æ—‹è½¬ç´¯ç§¯
        const newGeo = tempLoadedGeometry.clone();

        // åº”ç”¨æ—‹è½¬çŸ©é˜µåˆ°å‡ ä½•ä½“ (Bake Rotation)
        newGeo.rotateX(rx);
        newGeo.rotateY(ry);
        newGeo.rotateZ(rz);

        // æ›´æ–°å·¦è¾¹é¢„è§ˆ
        previewMeshOriginal.geometry.dispose();
        previewMeshOriginal.geometry = newGeo;

        // æ›´æ–°å³è¾¹
        const stretchedGeo = newGeo.clone();
        // ... é‡æ–°ç»‘å®š aExtraLength ...
        const count = stretchedGeo.attributes.position.count;
        const extraLengths = new Float32Array(count).fill(4.0);
        stretchedGeo.setAttribute('aExtraLength', new THREE.BufferAttribute(extraLengths, 1));

        previewMeshStretched.geometry.dispose();
        previewMeshStretched.geometry = stretchedGeo;

        // ğŸ”¥ ç¡®ä¿å³ä¾§æè´¨çš„ uniform çŠ¶æ€æ˜¯æœ€æ–°çš„
        const useTexture = document.getElementById('preview-use-texture').checked;
        const map = tempLoadedMaterial ? tempLoadedMaterial.map : null;

        previewMeshStretched.material.uniforms.uUseTexture.value = useTexture && !!map;
        previewMeshStretched.material.uniforms.uMap.value = map;
    }

    function animatePreview() {
        previewAnimationId = requestAnimationFrame(animatePreview);
        previewControls.update();
        previewRenderer.render(previewScene, previewCamera);

        // è®©å³è¾¹çš„æ‹‰ä¼¸ä½“ç¼“æ…¢æ—‹è½¬å±•ç¤º
        if(previewMeshStretched) {
            // previewMeshStretched.rotation.y += 0.01;
        }
    }

    function confirmImportModel() {
        // è·å–å½“å‰ geometry (å·²ç»åŒ…å«äº†æ—‹è½¬)
        const finalGeometry = previewMeshOriginal.geometry.clone();

        // åº”ç”¨åˆ°å…¨å±€
        customGeometry = finalGeometry;
        STATE.noteShape = 'custom';

        // æ›´æ–° UI
        const shapeSelect = document.getElementById('noteShapeSelect');
        if (shapeSelect) shapeSelect.value = 'custom';

        // åˆ·æ–°ä¸»åœºæ™¯
        STATE.clips.forEach(c => {
            if (c.track.type === 'midi') c.build3D();
        });
        updateAllTracksVisibility();

        closePreviewModal();
        alert("æ¨¡å‹å·²åº”ç”¨ï¼");
    }

    function toggleTrackSelection(id) {
        if (STATE.selectedTrackIds.has(id)) {
            STATE.selectedTrackIds.delete(id);
            // å–æ¶ˆé€‰ä¸­æ—¶ï¼Œé€šå¸¸ä¸æ›´æ–°é”šç‚¹ï¼Œæˆ–è€…è®¾ä¸º nullï¼Œè§†ä¹ æƒ¯è€Œå®š
        } else {
            STATE.selectedTrackIds.add(id);
            STATE.lastSelectedTrackId = id; // ğŸ”¥ é€‰ä¸­æ—¶è®°å½•é”šç‚¹
        }
        updateSelectionUI();
    }

    function updateSelectionUI() {
        STATE.tracks.forEach(t => {
            if (STATE.selectedTrackIds.has(t.id)) {
                t.headerEl.classList.add('selected');
            } else {
                t.headerEl.classList.remove('selected');
            }
        });
    }

    // --- ç¼–ç»„æ“ä½œ ---
    function createGroupForSelection() {
        if (STATE.selectedTrackIds.size === 0) return;

        // 1. åˆ›å»ºæ–°ç¼–ç»„ (é»˜è®¤é¢œè‰²éšæœºæˆ–å›ºå®š)
        const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16);
        const newGroup = new Group("Group " + STATE.nextGroupId, randomColor);
        STATE.groups[newGroup.id] = newGroup;

        // 2. å°†é€‰ä¸­çš„è½¨é“åŠ å…¥ç¼–ç»„
        STATE.selectedTrackIds.forEach(trackId => {
            const track = STATE.tracks.find(t => t.id === trackId);
            if (track) {
                // å¦‚æœå·²ç»åœ¨åˆ«çš„ç»„ï¼Œå…ˆé€€ç»„ï¼ˆç®€åŒ–é€»è¾‘ï¼šä¸æ”¯æŒåµŒå¥—ï¼‰
                if (track.groupId) {
                    const oldGroup = STATE.groups[track.groupId];
                    if(oldGroup) oldGroup.trackIds.delete(trackId);
                }

                track.groupId = newGroup.id;
                newGroup.trackIds.add(trackId);
                track.refreshColor(); // ğŸ”¥ ç«‹å³å˜è‰²
            }
        });

        console.log("Created Group:", newGroup);
    }

    function ungroupSelection() {
        STATE.selectedTrackIds.forEach(trackId => {
            const track = STATE.tracks.find(t => t.id === trackId);
            if (track && track.groupId) {
                const group = STATE.groups[track.groupId];
                if (group) group.trackIds.delete(trackId);

                track.groupId = null;
                track.refreshColor(); // ğŸ”¥ æ¢å¤å›è‡ªå·±çš„é¢œè‰²
            }
        });
    }

    function setGroupColor(color) {
        // æ‰¾åˆ°æ‰€æœ‰æ¶‰åŠçš„ç¼–ç»„ ID
        const affectedGroupIds = new Set();
        STATE.selectedTrackIds.forEach(tid => {
            const t = STATE.tracks.find(trk => trk.id === tid);
            if (t && t.groupId) affectedGroupIds.add(t.groupId);
        });

        // æ›´æ–°è¿™äº›ç¼–ç»„çš„é¢œè‰²
        affectedGroupIds.forEach(gid => {
            const group = STATE.groups[gid];
            if (group) {
                group.color = color;
                // åˆ·æ–°è¯¥ç»„ä¸‹æ‰€æœ‰è½¨é“
                group.trackIds.forEach(tid => {
                    const t = STATE.tracks.find(trk => trk.id === tid);
                    if (t) t.refreshColor();
                });
            }
        });
    }

    // è¾…åŠ©: Hex to Rgba
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // ==========================================
    // 3. 3D åœºæ™¯åˆå§‹åŒ– (Visualizer)
    // ==========================================
    let scene, camera, renderer, controls;
    let cameraTargetX = 0;

    function init3D() {
        const wrapper = document.getElementById('canvas-wrapper');
        let width = Math.max(2, wrapper.clientWidth);
        let height = Math.max(2, wrapper.clientHeight);

        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 50, 1000);

        camera = new THREE.PerspectiveCamera(45, width / height, 1, 5000);
        camera.position.set(0, 0, 200);

        scene.add(camera);

        renderer = new THREE.WebGLRenderer({
            antialias: true,
            powerPreference: "high-performance",
            alpha: true
        });

        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.setClearColor(0x000000, 0);
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        wrapper.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 0, 0);

        wrapper.addEventListener('dblclick', (e) => {
            // æ£€æµ‹ Command (Mac) æˆ– Ctrl (Win)
            if (e.metaKey || e.ctrlKey) {
                e.preventDefault();

                // 1. è·å–å½“å‰çŠ¶æ€ (ä½œä¸ºæ—§çŠ¶æ€)
                const oldParams = ViewMgr.getCurrentSpherical();

                // 2. è·å–é»˜è®¤çŠ¶æ€ (ä½œä¸ºæ–°çŠ¶æ€)
                const newParams = ViewMgr.defaults; // { radius: 80, theta: 0, phi: -30, targetX: 0, targetY: 0 }

                // 3. æ‰§è¡Œé‡ç½®
                ViewMgr.reset();

                // 4. ğŸ”¥ è®°å½•å†å² (å…è®¸ Ctrl+Z æ’¤å›)
                // åªæœ‰å½“å½“å‰çŠ¶æ€å’Œé»˜è®¤çŠ¶æ€ä¸ä¸€æ ·æ—¶æ‰è®°å½•ï¼Œé¿å…é‡å¤è®°å½•æ— æ•ˆå†å²
                if (JSON.stringify(oldParams) !== JSON.stringify(newParams)) {
                    HistoryMgr.add({
                        type: 'change_view',
                        oldView: oldParams,
                        newView: newParams
                    });
                    console.log("è§†è§’å·²é‡ç½® (å¯æ’¤å›)");
                }
            }
        });

        initBlurSystem(width, height);

        // ==========================================
        // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šShader æ”¯æŒæ¨¡ç³Šå’Œé€æ˜
        // ==========================================
        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform sampler2D tMap; // è¿™é‡Œæ¥æ”¶çš„å°†æ˜¯å·²ç»æ¨¡ç³Šå¥½çš„çº¹ç†
            uniform float uOpacity;
            uniform float uBrightness;
            uniform float uContrast;
            uniform vec2 uUvScale;
            uniform vec2 uUvOffset;

            varying vec2 vUv;

            void main() {
                // UV å˜æ¢ (Cover/Contain)
                vec2 centerUv = (vUv - 0.5) * uUvScale + 0.5 + uUvOffset;

                // è¾¹ç•Œæ£€æŸ¥
                if (centerUv.x < 0.0 || centerUv.x > 1.0 || centerUv.y < 0.0 || centerUv.y > 1.0) {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                    return;
                }

                // ç›´æ¥é‡‡æ · (å› ä¸ºæ¨¡ç³Šå·²ç»åœ¨ç¦»å±æ¸²æŸ“é‡Œåšå®Œäº†)
                vec4 color = texture2D(tMap, centerUv);

                // åº”ç”¨å¯¹æ¯”åº¦
                color.rgb = (color.rgb - 0.5) * uContrast + 0.5;
                // åº”ç”¨äº®åº¦
                color.rgb += uBrightness;
                // åº”ç”¨é€æ˜åº¦
                gl_FragColor = vec4(color.rgb, uOpacity);
            }
        `;

        bgMaterial = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                tMap: { value: null },
                uOpacity: { value: 1.0 },
                uBrightness: { value: 0.0 },
                uContrast: { value: 1.0 },
                uUvScale: { value: new THREE.Vector2(1, 1) },
                uUvOffset: { value: new THREE.Vector2(0, 0) }
            },
            depthTest: false,
            depthWrite: false,
            side: THREE.DoubleSide,
            transparent: true
        });

        const geometry = new THREE.PlaneGeometry(1, 1);
        bgMesh = new THREE.Mesh(geometry, bgMaterial);
        bgMesh.position.z = -1000;
        bgMesh.visible = false;

        bgMesh.renderOrder = -999;

        camera.add(bgMesh);

        initStarfield();

        updateBackgroundSize();

        window.addEventListener('resize', onResize);
        animate();
    }

    function normalizeGeometry(geometry) {
        // 1. è®¡ç®—åŒ…å›´ç›’
        geometry.computeBoundingBox();
        const box = geometry.boundingBox;

        // 2. è®¡ç®—ä¸­å¿ƒç‚¹å¹¶åç§»ï¼Œä½¿å…¶å±…ä¸­åˆ° (0,0,0)
        const center = new THREE.Vector3();
        box.getCenter(center);
        geometry.translate(-center.x, -center.y, -center.z);

        // 3. è®¡ç®—æœ€å¤§å°ºå¯¸ï¼Œå°†å…¶ç¼©æ”¾åˆ° 1.0 å¤§å°
        // è¿™æ ·æ‰èƒ½é€‚é…æˆ‘ä»¬çš„ noteThickness å’Œ Shader
        const size = new THREE.Vector3();
        box.getSize(size);
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 1.0 / (maxDim || 1); // é˜²æ­¢é™¤ä»¥0

        geometry.scale(scale, scale, scale);

        // 4. æ—‹è½¬ä¿®æ­£ (å¯é€‰)ï¼šæœ‰äº›æ¨¡å‹å¯¼å…¥æ—¶æ˜¯è¶´ç€çš„ï¼Œè¿™é‡Œç»Ÿä¸€è®©å®ƒæœå‘ X è½´
        // å¦‚æœä½ çš„æ¨¡å‹é•¿å¾—å¥‡æ€ªï¼Œå¯èƒ½éœ€è¦è°ƒæ•´è¿™é‡Œï¼Œæˆ–è€…è®©ç”¨æˆ·è‡ªå·±å¤„ç†
        // geometry.rotateY(Math.PI / 2);

        return geometry;
    }

    const BLUR_SCALE = 0.5;

    function initBlurSystem(width, height) {
        width = Math.max(1, Math.floor(width * BLUR_SCALE));  // ğŸ”¥ å¼ºåˆ¶ç¼©å°
        height = Math.max(1, Math.floor(height * BLUR_SCALE));
        // 1. åˆ›å»ºç‹¬ç«‹çš„åœºæ™¯å’Œç›¸æœºï¼Œç”¨äºå¹•åå¤„ç†
        blurScene = new THREE.Scene();
        blurCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // 2. åˆ›å»ºä¸¤ä¸ªæ¸²æŸ“ç›®æ ‡ (Ping-Pong Buffer)
        // ä½¿ç”¨ Half Float ä»¥æ”¯æŒæ›´å¥½çš„è‰²å½©ç²¾åº¦ (é˜²è‰²å¸¦)ï¼Œå¦‚æœä¸æ”¯æŒä¼šè‡ªåŠ¨é™çº§
        const rtPars = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
            type: THREE.HalfFloatType // å…³é”®ï¼šé«˜ç²¾åº¦é˜²æ–­å±‚
        };

        // ä¸ºäº†æ€§èƒ½ï¼Œæ¨¡ç³Šç¼“å†²åŒºå¯ä»¥æ˜¯å±å¹•åˆ†è¾¨ç‡çš„ 1/2ï¼Œè‚‰çœ¼å‡ ä¹çœ‹ä¸å‡ºåŒºåˆ«ä½†å¿«4å€
        // è¿™é‡Œæš‚æ—¶ç”¨å…¨åˆ†è¾¨ç‡ä»¥ä¿è¯æœ€é«˜ç”»è´¨
        blurRtX = new THREE.WebGLRenderTarget(width, height, rtPars);
        blurRtY = new THREE.WebGLRenderTarget(width, height, rtPars);

        // 3. é€šç”¨çš„ 1D é«˜æ–¯æ¨¡ç³Š Shader
        const blurVertex = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1.0);
            }
        `;

        const blurFragment = `
            uniform sampler2D tMap;
            uniform vec2 uResolution;
            uniform vec2 uDirection; // (1,0) æ˜¯æ¨ªå‘, (0,1) æ˜¯çºµå‘
            uniform float uBlur;     // æ¨¡ç³ŠåŠå¾„
            varying vec2 vUv;

            // æ ‡å‡†é«˜æ–¯æƒé‡å…¬å¼
            float gaussian(float x, float sigma) {
                return 0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;
            }

            void main() {
                vec4 sum = vec4(0.0);
                float totalWeight = 0.0;

                // åŠ¨æ€ Sigma: æ¨¡ç³ŠåŠå¾„çš„ 1/2
                float sigma = max(uBlur * 0.5, 0.01);

                // é‡‡æ ·èŒƒå›´ï¼šæ ¹æ®æ¨¡ç³Šç¨‹åº¦åŠ¨æ€å†³å®šï¼Œè¿™é‡Œé™åˆ¶æœ€å¤§å¾ªç¯æ¬¡æ•°ä¿è¯æ€§èƒ½
                // èŒƒå›´ -20 åˆ° +20 (41æ¬¡é‡‡æ ·)ï¼Œé…åˆåŒé€šé“ç­‰æ•ˆäº 41x41 = 1681æ¬¡é‡‡æ ·ï¼
                float range = min(uBlur, 40.0);

                for(float i = -10.0; i <= 10.0; i++) {
                    if (abs(i) > range) continue; // è¶…å‡ºåŠå¾„è·³è¿‡

                    // æ ¸å¿ƒï¼šæ²¿ç€ uDirection æ–¹å‘åç§»
                    vec2 offset = vec2(i) * uDirection;
                    vec2 uvOffset = offset / uResolution;

                    float weight = gaussian(i, sigma);

                    sum += texture2D(tMap, vUv + uvOffset) * weight;
                    totalWeight += weight;
                }

                gl_FragColor = sum / totalWeight;
            }
        `;

        // 4. åˆ›å»ºæ¨ªå‘æè´¨
        blurMatX = new THREE.ShaderMaterial({
            vertexShader: blurVertex,
            fragmentShader: blurFragment,
            uniforms: {
                tMap: { value: null },
                uResolution: { value: new THREE.Vector2(width, height) },
                uDirection: { value: new THREE.Vector2(1, 0) }, // æ¨ªå‘
                uBlur: { value: 0 }
            },
            depthTest: false,
            depthWrite: false
        });

        // 5. åˆ›å»ºçºµå‘æè´¨
        blurMatY = blurMatX.clone();
        blurMatY.uniforms.uDirection.value.set(0, 1); // çºµå‘

        // 6. åˆ›å»ºä¸€ä¸ªå…¨å±å››è¾¹å½¢ç”¨äºæ¸²æŸ“
        blurMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), blurMatX);
        blurScene.add(blurMesh);
    }

    function updateBackgroundSize() {
        if (!bgMesh || !camera) return;

        // 1. è®¡ç®—ç›¸æœºåœ¨ z=-1000 å¤„çš„è§†é”¥ä½“å°ºå¯¸
        // å…¬å¼ï¼šheight = 2 * tan(fov / 2) * distance
        const distance = 1000;
        const vFOV = THREE.MathUtils.degToRad(camera.fov); // è½¬å¼§åº¦
        const height = 2 * Math.tan(vFOV / 2) * distance;
        const width = height * camera.aspect;

        // 2. è°ƒæ•´æ¿å­å¤§å°ä»¥å¡«æ»¡å±å¹•
        bgMesh.scale.set(width, height, 1);

        // 3. é¡ºä¾¿æ›´æ–°ä¸€ä¸‹è´´å›¾çš„ UV ç¼©æ”¾ (å¤„ç† Cover/Contain)
        updateBackgroundUV();
    }

    function onResize(source, overrideW, overrideH) {
        // 1. å½•åˆ¶æ—¶ç¦æ­¢è°ƒæ•´
        if (ExportMgr && ExportMgr.isRecording) return;

        const isDrag = (source === 'drag');
        const container = document.getElementById('visualizer-section');
        const wrapper = document.getElementById('canvas-wrapper');

        if (container) {
            // ä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„é¢„è®¡ç®—å®½é«˜
            const availW = overrideW || container.clientWidth;
            const availH = overrideH || container.clientHeight;

            if (availW > 0 && availH > 0) {
                let finalW, finalH;
                const hasImportedBg = currentBgType !== null;

                if (hasImportedBg) {
                    // === æ¨¡å¼ A: é€‚åº”èƒŒæ™¯æ¯”ä¾‹ ===
                    const targetRatio = bgImageAspect;
                    const containerRatio = availW / availH;
                    if (containerRatio > targetRatio) {
                        finalH = availH;
                        finalW = availH * targetRatio;
                    } else {
                        finalW = availW;
                        finalH = availW / targetRatio;
                    }
                } else {
                    // === æ¨¡å¼ B: é“ºæ»¡æ•´ä¸ªåŒºåŸŸ (æ˜Ÿç©ºæ¨¡å¼) ===
                    finalW = availW;
                    finalH = availH;
                }

                finalW = Math.max(2, Math.floor(finalW));
                finalH = Math.max(2, Math.floor(finalH));

                wrapper.style.width = finalW + 'px';
                wrapper.style.height = finalH + 'px';

                if (camera && renderer) {
                    // 1. æ›´æ–°ç›¸æœºå’Œæ¸²æŸ“å™¨å°ºå¯¸
                    camera.aspect = finalW / finalH;
                    camera.updateProjectionMatrix();

                    renderer.setSize(finalW, finalH);
                    renderer.domElement.style.width = finalW + 'px';
                    renderer.domElement.style.height = finalH + 'px';

                    // 2. åŒæ­¥æ¨¡ç³Šå’ŒèƒŒæ™¯
                    if (blurRtX) blurRtX.setSize(finalW * BLUR_SCALE, finalH * BLUR_SCALE);
                    if (blurRtY) blurRtY.setSize(finalW * BLUR_SCALE, finalH * BLUR_SCALE);
                    if (blurMatX) blurMatX.uniforms.uResolution.value.set(finalW * BLUR_SCALE, finalH * BLUR_SCALE);
                    if (blurMatY) blurMatY.uniforms.uResolution.value.set(finalW * BLUR_SCALE, finalH * BLUR_SCALE);

                    updateBackgroundSize();

                    // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šç«‹åˆ»æ¸²æŸ“ä¸€å¸§ï¼ğŸ”¥ğŸ”¥ğŸ”¥
                    // è¿™èƒ½é˜²æ­¢ setSize æ¸…ç©ºç”»å¸ƒåå‡ºç°â€œé—ªé»‘â€æˆ–â€œæ¶ˆå¤±â€çš„æƒ…å†µ
                    renderer.render(scene, camera);
                }
                updateGridBackground();
            }
        }

        if (!isDrag && STATE.totalDuration > 0) {
            autoFitZoom(STATE.totalDuration);
            updatePlayhead();
        }
    }

    function updateBackgroundUV() {
        if (!bgMaterial || !bgMaterial.uniforms.tMap.value) return;

        const screenAspect = camera.aspect;
        const imageAspect = bgImageAspect;
        const fitMode = BG_STATE.fit; // 'cover', 'contain', 'fill'

        let scaleX = 1;
        let scaleY = 1;

        if (fitMode === 'fill') {
            scaleX = 1;
            scaleY = 1;
        }
        else if (fitMode === 'contain') {
            // å®Œæ•´æ˜¾ç¤ºï¼šä»¥é•¿è¾¹ä¸ºå‡†
            if (screenAspect > imageAspect) {
                // å±å¹•æ›´å®½ï¼Œå·¦å³ç•™é»‘ï¼Œå›¾ç‰‡ X è½´éœ€è¦ç¼©å°æ˜¾ç¤ºï¼ˆå³ UV X è½´èŒƒå›´å˜å¤§ï¼‰
                scaleX = screenAspect / imageAspect;
            } else {
                scaleY = imageAspect / screenAspect;
            }
        }
        else { // 'cover' (é»˜è®¤)
            // é“ºæ»¡è£å‰ªï¼šä»¥çŸ­è¾¹ä¸ºå‡†
            if (screenAspect > imageAspect) {
                // å±å¹•æ›´å®½ï¼Œä¸ºäº†é“ºæ»¡ï¼Œéœ€è¦æˆªæ‰ä¸Šä¸‹ï¼ˆå³ UV Y è½´èŒƒå›´å˜å°ï¼‰
                scaleY = imageAspect / screenAspect;
            } else {
                scaleX = screenAspect / imageAspect;
            }
        }

        bgMaterial.uniforms.uUvScale.value.set(scaleX, scaleY);
    }

    // ==========================================
    // 4. ä¸»é€»è¾‘æ§åˆ¶
    // ==========================================

    function initScrubbing() {
        // å®šä¹‰æ ¸å¿ƒå®šä½é€»è¾‘ï¼šè¾“å…¥é¼ æ ‡äº‹ä»¶ï¼Œè®¡ç®—æ—¶é—´å¹¶è·³è½¬
        const updateScrub = (e) => {
            // ä»¥ timelineLanes ä¸ºåŸºå‡†è®¡ç®— X åæ ‡
            const rect = DOM.timelineLanes.getBoundingClientRect();

            // è®¡ç®—é¼ æ ‡ç›¸å¯¹äºå®¹å™¨å·¦ä¾§çš„åç§» + å®¹å™¨å½“å‰çš„æ»šåŠ¨è·ç¦»
            const offsetX = e.clientX - rect.left + DOM.timelineLanes.scrollLeft;

            // è½¬æ¢ä¸ºæ—¶é—´ (é˜²æ­¢è´Ÿæ•°)
            const time = Math.max(0, offsetX / STATE.pxPerSec);

            // æ‰§è¡Œè·³è½¬
            seekTo(time);
        };

        // é€šç”¨çš„æŒ‰ä¸‹å¤„ç†å‡½æ•°
        const onMouseDown = (e) => {
            // 1. å¦‚æœç‚¹å‡»çš„æ˜¯ Clip (äº‹ä»¶å—)ï¼Œåˆ™å¿½ç•¥ï¼Œè®© Clip è‡ªå·±çš„æ‹–æ‹½é€»è¾‘å¤„ç†
            if (e.target.closest('.clip')) return;

            // 2. ğŸ”¥ å…³é”®ï¼šç¦æ­¢æµè§ˆå™¨é»˜è®¤è¡Œä¸ºï¼ˆé˜²æ­¢æ‹–å‡ºæ®‹å½±ã€é€‰ä¸­æ–‡å­—ï¼‰
            e.preventDefault();

            // 3. ç«‹å³è·³è½¬ä¸€æ¬¡ï¼ˆç‚¹å‡»å³å®šä½ï¼‰
            updateScrub(e);

            // 4. å®šä¹‰æ‹–åŠ¨è¿‡ç¨‹
            const onMouseMove = (moveEvent) => {
                // åœ¨ window ä¸Šç›‘å¬ï¼Œè¿™æ ·é¼ æ ‡æ‹–å‡ºæµè§ˆå™¨å¤–ä¹Ÿèƒ½å“åº”
                updateScrub(moveEvent);
            };

            // 5. å®šä¹‰æŠ¬èµ·è¿‡ç¨‹
            const onMouseUp = () => {
                window.removeEventListener('mousemove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);
            };

            // æŒ‚è½½å…¨å±€ç›‘å¬
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
        };

        // ä¸ºâ€œæ ‡å°ºâ€å’Œâ€œè½¨é“åŒºåŸŸâ€éƒ½ç»‘å®šè¿™ä¸ªé€»è¾‘
        // ä½¿ç”¨ capture: false ç¡®ä¿å†’æ³¡é€»è¾‘æ­£å¸¸
        DOM.timelineLanes.addEventListener('mousedown', onMouseDown);
        DOM.rulerContent.addEventListener('mousedown', onMouseDown);
    }

    function updateAllTracksVisibility() {
        const hasSolo = STATE.soloCount > 0;

        STATE.tracks.forEach(track => {
            let visible = true;

            if (hasSolo) {
                // å¦‚æœæœ‰ Soloï¼Œåªæœ‰æ ‡è®°äº† Solo ä¸”æ²¡è¢« Mute çš„æ‰æ˜¾ç¤ºå›¾æ¡ˆ
                visible = track.isSoloed && !track.isMuted;
            } else {
                // å¦‚æœæ²¡æœ‰ Soloï¼Œåªè¦æ²¡è¢« Mute å°±æ˜¾ç¤ºå›¾æ¡ˆ
                visible = !track.isMuted;
            }

            // 1. æ›´æ–° 3D åœºæ™¯å¯è§æ€§ï¼ˆåªå½±å“è§†è§‰å›¾æ¡ˆï¼‰
            track.clips.forEach(clip => {
                if (clip.mesh) {
                    clip.mesh.visible = visible;
                }
            });

            // 2. æ›´æ–°æ—¶é—´è½´ UI ç°åº¦ï¼ˆè§†è§‰æç¤ºï¼‰
            if (track.laneEl) {
                track.laneEl.style.opacity = visible ? "1" : "0.3";
            }

            // ğŸ”¥ é‡è¦ï¼šåˆ æ‰æˆ–æ³¨é‡Šæ‰åŸæœ¬åœ¨è¿™é‡Œçš„ DOM.audio.muted = !visible é€»è¾‘
            // è¿™æ ·éŸ³é¢‘å°±ä¼šå§‹ç»ˆæ’­æ”¾ï¼Œä¸å— Mute/Solo æŒ‰é’®çš„è§†è§‰éšè—å½±å“
        });
    }

    // ğŸ”¥ æ–°å¢ï¼šè‡ªåŠ¨è®¡ç®—å¹¶åº”ç”¨åˆé€‚çš„ Zoom å€¼
    function autoFitZoom(duration) {
        if (!duration || duration <= 0) return;

        // è·å–æ—¶é—´è½´å¯è§†åŒºåŸŸçš„å®½åº¦
        const containerWidth = DOM.timelineLanes.clientWidth;

        // è®¡ç®—ç†æƒ³æ¯”ä¾‹ï¼šè®©å†…å®¹å æ®çº¦ 90% çš„å®½åº¦ (ç•™ä¸€ç‚¹ä½™åœ°)
        let idealPxPerSec = (containerWidth * 0.9) / duration;

        // é™åˆ¶èŒƒå›´åœ¨ Slider çš„æœ€å°å€¼(1)å’Œæœ€å¤§å€¼(200)ä¹‹é—´
        // ä½ å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´è¿™é‡Œçš„ min/max
        idealPxPerSec = Math.max(1, Math.min(200, idealPxPerSec));

        // åº”ç”¨æ•°å€¼
        STATE.pxPerSec = idealPxPerSec;

        // åŒæ­¥æ›´æ–° Slider UI
        if (DOM.timelineZoom) {
            DOM.timelineZoom.value = idealPxPerSec;
        }

        // è§¦å‘è§†å›¾åˆ·æ–°
        updateGridBackground();
        updateTotalDuration(); // è¿™ä¸€æ­¥å¾ˆé‡è¦ï¼Œå®ƒä¼šé‡ç®—å®¹å™¨æ€»å®½
        STATE.clips.forEach(c => c.updateDOMPosition()); // è¿™ä¸€æ­¥é‡ç»˜ Clip
        updatePlayhead();
    }

    // å…¨å±€å˜é‡å­˜å‚¨è§†é¢‘å…ƒç´ ï¼Œæ–¹ä¾¿åœ¨ animate ä¸­æ›´æ–°
    // å…¨å±€å˜é‡ç”¨äºæ§åˆ¶è§†é¢‘æ’­æ”¾
    let bgVideoElement = null;

    function processBackgroundFile(file) {
        if (!file) return;

        // æ˜¾ç¤º Loadingï¼Œå› ä¸ºè½¬æ¢ Base64 å¯èƒ½éœ€è¦ä¸€ç‚¹æ—¶é—´ï¼ˆç‰¹åˆ«æ˜¯å¤§å›¾ç‰‡ï¼‰
        if(DOM.loading) DOM.loading.style.display = 'flex';

        const reader = new FileReader();

        reader.onload = (e) => {
            const base64Data = e.target.result; // è¿™é‡Œæ‹¿åˆ°äº† Base64

            // --- 1. å‡†å¤‡å†å²è®°å½•æ—§æ•°æ® ---
            const oldBgBlob = currentBgBase64;
            const oldBgType = currentBgType;
            const oldBgBase64 = storedBgBase64ForSave; // è®°å½•æ—§çš„ Base64

            // --- 2. æ³¨å†Œ Blob ç”¨äºæ¸²æŸ“ (æ€§èƒ½ä¼˜åŒ–) ---
            const newBgUrl = ResourceMgr.register(file);
            const newBgType = file.type.startsWith('video/') ? 'video' : 'image';

            // --- 3. æ›´æ–°å…¨å±€çŠ¶æ€ ---
            currentBgBase64 = newBgUrl;       // è¿è¡Œæ—¶ç”¨ Blob
            currentBgType = newBgType;
            storedBgBase64ForSave = base64Data; // ä¿å­˜æ—¶ç”¨ Base64

            // --- 4. åº”ç”¨èƒŒæ™¯ ---
            applyBackgroundSource(newBgUrl, newBgType);

            // --- 5. è®°å½•å†å² ---
            HistoryMgr.add({
                type: 'change_background',
                // æ¸²æŸ“ç”¨çš„ Blob
                oldData: oldBgBlob,
                oldType: oldBgType,
                newData: newBgUrl,
                newType: newBgType,
                // ä¿å­˜ç”¨çš„ Base64 ğŸ”¥
                oldBase64: oldBgBase64,
                newBase64: base64Data
            });

            if(DOM.loading) DOM.loading.style.display = 'none';
        };

        // å¼€å§‹è¯»å–æ–‡ä»¶
        reader.readAsDataURL(file);
    }

    // ğŸ”¥ ä¿®å¤ï¼šå°† onResize ç§»å…¥åŠ è½½å›è°ƒä¸­ï¼Œç¡®ä¿è·å¾—æ­£ç¡®çš„å›¾ç‰‡é•¿å®½æ¯”
    function applyBackgroundSource(url, type) {
        const loader = new THREE.TextureLoader();

        // å†…éƒ¨è¾…åŠ©ï¼šåº”ç”¨çº¹ç†
        const applyTexture = (texture, aspect) => {
            texture.encoding = THREE.sRGBEncoding;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;

            bgTexture = texture;
            bgImageAspect = aspect;

            if (bgMaterial) {
                bgMaterial.uniforms.tMap.value = texture;
                bgMesh.visible = true;
                updateBackgroundUV();
            }

            // âœ¨ å…³é”®ä¿®å¤ï¼šå›¾ç‰‡åŠ è½½å®Œã€é•¿å®½æ¯”æ›´æ–°åï¼Œå†è§¦å‘ä¸€æ¬¡ Resize
            requestAnimationFrame(() => {
                onResize();
            });
        };

        if (type === 'image') {
            const img = new Image();
            img.src = url;
            img.onload = () => {
                const aspect = img.width / img.height;
                loader.load(url, (tex) => applyTexture(tex, aspect));
            };
        }
        else if (type === 'video') {
            const video = document.createElement('video');
            video.src = url;
            video.loop = true;
            video.muted = true;
            video.playsInline = true;
            video.play().then(() => {
                const aspect = video.videoWidth / video.videoHeight;
                bgVideoElement = video;
                const tex = new THREE.VideoTexture(video);
                applyTexture(tex, aspect);
            }).catch(e => console.error("Video play error:", e));
        }
    }



    function initController() {
        ColorPickerMgr.init();

        const versionModal = document.getElementById('version-modal');
        const logoBtn = document.getElementById('app-logo');
        const closeVerBtn = document.getElementById('closeVersionBtn');

        if (logoBtn && versionModal) {
            logoBtn.addEventListener('click', () => {
                versionModal.style.display = 'flex';
            });
        }

        if (closeVerBtn) {
            closeVerBtn.addEventListener('click', () => {
                versionModal.style.display = 'none';
            });
        }

        // ç‚¹å‡»å¼¹çª—èƒŒæ™¯å…³é—­
        if (versionModal) {
            versionModal.addEventListener('click', (e) => {
                if (e.target === versionModal) {
                    versionModal.style.display = 'none';
                }
            });
        }

        const starToggle = document.getElementById('starfieldToggle');
        if (starToggle) {
            starToggle.addEventListener('change', (e) => {
                // ğŸ”¥ ä¿®å¤ï¼šè°ƒç”¨å°è£…å¥½çš„å‡½æ•°ï¼Œè¿™æ ·æ‰èƒ½åŒæ—¶åˆ‡æ¢ 3D æ˜Ÿæ˜Ÿå’Œ DOM èƒŒæ™¯è‰²
                setStarfieldState(e.target.checked);
            });
        }

        // åˆ›å»ºé»˜è®¤è½¨é“
        const defaultAudioTrack = new Track("Audio", "audio");
        STATE.tracks.push(defaultAudioTrack);

        const defaultMidiTrack = new Track("MIDI", "midi");
        STATE.tracks.push(defaultMidiTrack);

        const alignBtn = document.getElementById('autoAlignBtn');
        if (alignBtn) {
            alignBtn.addEventListener('click', autoAlignAudioToMidi);
        }

        const bgModal = document.getElementById('bg-settings-modal');

        // 1. MIDI
        const btnMidi = document.getElementById('btn-midi');
        const inputMidi = document.getElementById('midiInput');
        if (btnMidi && inputMidi) {
            btnMidi.addEventListener('click', () => inputMidi.click());
        }

        // 2. Audio
        const btnAudio = document.getElementById('btn-audio');
        const inputAudio = document.getElementById('audioInput');
        if (btnAudio && inputAudio) {
            btnAudio.addEventListener('click', () => inputAudio.click());
        }

        // 3. èƒŒæ™¯
        const btnBg = document.getElementById('btn-bg');
        const inputBg = document.getElementById('bgInput');
        if (btnBg && inputBg) {
            btnBg.addEventListener('click', () => inputBg.click());
        }

        const btnHl = document.getElementById('btn-highlight-color');
        const hlPreview = document.getElementById('hl-color-preview');

        if (btnHl) {
            btnHl.addEventListener('click', () => {
                const curHex = '#' + currentHighlightColor.getHexString();

                ColorPickerMgr.open(
                    curHex,
                    " - Playback Highlight",
                    (finalColor) => {
                        // ç¡®è®¤å›è°ƒ (è¿™é‡Œä¸éœ€è¦åšé¢å¤–æ“ä½œï¼Œå› ä¸ºå®æ—¶é¢„è§ˆå·²ç»ç”Ÿæ•ˆ)
                        // å¦‚æœéœ€è¦æ”¯æŒæ’¤é”€/é‡åšåŠŸèƒ½ï¼Œå¯ä»¥åœ¨è¿™é‡Œè®°å½•æœ€ç»ˆçŠ¶æ€
                    },
                    (previewColor) => {
                        // --- é¢œè‰²å®æ—¶é¢„è§ˆå›è°ƒ ---
                        currentHighlightColor.set(previewColor);
                        hlPreview.style.backgroundColor = previewColor;

                        // éå†æ‰€æœ‰ Clip æ›´æ–° Shader çš„é¢œè‰² Uniform
                        STATE.clips.forEach(clip => {
                            if (clip.mesh && clip.track.type === 'midi') {
                                // ğŸ”¥ğŸ”¥ğŸ”¥ ä¿®å¤å¼€å§‹ï¼šç›´æ¥æ£€æŸ¥ clip.mesh.material ğŸ”¥ğŸ”¥ğŸ”¥
                                // MIDI çš„ mesh æ˜¯ InstancedMeshï¼Œç›´æ¥æŒæœ‰ materialï¼Œæ²¡æœ‰ children
                                if (clip.mesh.material && clip.mesh.material.uniforms) {
                                    clip.mesh.material.uniforms.uHighlightColor.value.copy(currentHighlightColor);
                                }
                                // ä¸ºäº†å…¼å®¹æ€§ï¼ˆå¦‚æœæœªæ¥æ”¹æˆ Groupï¼‰ï¼Œä¹Ÿå¯ä»¥ä¿ç•™ children æ£€æŸ¥ï¼Œä½†å¿…é¡»å…ˆæ£€æŸ¥è‡ªèº«
                                else if (clip.mesh.children && clip.mesh.children.length > 0) {
                                    clip.mesh.children.forEach(child => {
                                        if (child.material && child.material.uniforms) {
                                            child.material.uniforms.uHighlightColor.value.copy(currentHighlightColor);
                                        }
                                    });
                                }
                                // ğŸ”¥ğŸ”¥ğŸ”¥ ä¿®å¤ç»“æŸ ğŸ”¥ğŸ”¥ğŸ”¥
                            }
                        });
                    },
                    // ============================================
                    // ğŸ”¥ æ–°å¢ï¼šä¼ å…¥æ‰©å±•é…ç½®å¯¹è±¡
                    // ============================================
                    {
                        isHighlight: true, // æ ‡è®°ä¸ºé«˜å…‰æ¨¡å¼
                        initialWidth: currentHighlightWidth, // ä¼ å…¥å½“å‰å…¨å±€å®½åº¦å€¼
                        onWidthChange: (newWidth) => {
                            // --- å®½åº¦å®æ—¶é¢„è§ˆå›è°ƒ ---
                            // 1. æ›´æ–°å…¨å±€å˜é‡
                            currentHighlightWidth = newWidth;

                            // 2. éå†æ‰€æœ‰ Clip æ›´æ–° Shader çš„å®½åº¦ Uniform
                            STATE.clips.forEach(clip => {
                                if (clip.mesh && clip.track.type === 'midi') {
                                    // ğŸ”¥ğŸ”¥ğŸ”¥ ä¿®å¤å¼€å§‹ï¼šå®½åº¦è°ƒèŠ‚é€»è¾‘åŒä¸Š ğŸ”¥ğŸ”¥ğŸ”¥
                                    if (clip.mesh.material && clip.mesh.material.uniforms) {
                                        clip.mesh.material.uniforms.uHighlightWidth.value = currentHighlightWidth;
                                    }
                                    else if (clip.mesh.children && clip.mesh.children.length > 0) {
                                        clip.mesh.children.forEach(child => {
                                            if (child.material && child.material.uniforms) {
                                                child.material.uniforms.uHighlightWidth.value = currentHighlightWidth;
                                            }
                                        });
                                    }
                                    // ğŸ”¥ğŸ”¥ğŸ”¥ ä¿®å¤ç»“æŸ ğŸ”¥ğŸ”¥ğŸ”¥
                                }
                            });
                        }
                    }
                );
            });
        }

        const menuColorBtn = document.getElementById('menu-color');

        menuColorBtn.addEventListener('click', () => {
            // éšè—èœå•
            document.getElementById('context-menu').style.display = 'none';

            // --- 1. é¢„å…ˆè®¡ç®—å—å½±å“çš„ç¼–ç»„ï¼Œå¹¶ä¿å­˜å®ƒä»¬çš„â€œæ—§é¢œè‰²â€ ---
            // è¿™ä¸€æ­¥å¿…é¡»åœ¨æ‰“å¼€è°ƒè‰²ç›˜ä¹‹å‰åšï¼Œå› ä¸ºå®æ—¶é¢„è§ˆä¼šæ”¹å˜å½“å‰é¢œè‰²
            const affectedGroupsState = [];
            const affectedGroupIds = new Set();

            STATE.selectedTrackIds.forEach(tid => {
                const t = STATE.tracks.find(trk => trk.id === tid);
                if (t && t.groupId) affectedGroupIds.add(t.groupId);
            });

            affectedGroupIds.forEach(gid => {
                const group = STATE.groups[gid];
                if (group) {
                    affectedGroupsState.push({
                        groupId: gid,
                        oldColor: group.color // ğŸ”¥ è®°å½•æ­¤åˆ»çš„æ—§é¢œè‰²
                    });
                }
            });

            // --- 2. å†³å®šè°ƒè‰²ç›˜æ‰“å¼€æ—¶çš„é»˜è®¤é¢œè‰² ---
            let initialColor = '#ffffff';
            // å¦‚æœæœ‰å—å½±å“çš„ç»„ï¼Œå°±ç”¨ç¬¬ä¸€ä¸ªç»„çš„é¢œè‰²ä½œä¸ºé»˜è®¤å€¼ (è§£å†³é‡ç½®å›ç™½è‰²çš„é—®é¢˜)
            if (affectedGroupsState.length > 0) {
                initialColor = affectedGroupsState[0].oldColor;
            }

            // --- 3. æ‰“å¼€è°ƒè‰²ç›˜ ---
            ColorPickerMgr.open(
                initialColor,
                " - Group Color",
                (finalColor) => {
                    // === A. ç¡®è®¤å›è°ƒ ===

                    // 1. å†æ¬¡ç¡®ä¿åº”ç”¨æœ€ç»ˆé¢œè‰² (é˜²æ­¢é¢„è§ˆæ²¡è·‘å®Œ)
                    setGroupColor(finalColor);

                    // 2. ğŸ”¥ ç”Ÿæˆå†å²è®°å½• (Issue #2)
                    // æˆ‘ä»¬å°†ä¹‹å‰å­˜å¥½çš„ affectedGroupsState ä¸æ–°çš„ finalColor ç»“åˆ
                    const changes = affectedGroupsState.map(state => ({
                        groupId: state.groupId,
                        oldColor: state.oldColor,
                        newColor: finalColor
                    }));

                    if (changes.length > 0) {
                        HistoryMgr.add({
                            type: 'change_group_color',
                            changes: changes
                        });
                        console.log("ç¼–ç»„é¢œè‰²ä¿®æ”¹å·²è®°å½•ï¼Œå¯æ’¤å›ã€‚");
                    }
                },
                (previewColor) => {
                    // === B. å®æ—¶é¢„è§ˆå›è°ƒ ===
                    // æ­¤æ—¶ STATE.groups é‡Œçš„é¢œè‰²å·²ç»è¢«ä¿®æ”¹äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨ä¸Šé¢å¿…é¡»æå‰ä¿å­˜ oldColor
                    setGroupColor(previewColor);
                }
            );
        });

        // 1. æ‰“å¼€å¼¹çª—
        document.getElementById('bgSettingsBtn').addEventListener('click', () => {
            bgModal.style.display = 'flex';
            updateBgUI(); // æ‰“å¼€æ—¶åŒæ­¥ UI
        });

        // 2. å…³é—­å¼¹çª—
        document.getElementById('closeBgSettingsBtn').addEventListener('click', () => {
            bgModal.style.display = 'none';
        });

        // ... åœ¨ initController å†… ...

        const bgInputs = [
            { id: 'bg-opacity',    labelId: 'val-opacity',  key: 'opacity',    suffix: '' },
            { id: 'bg-blur',       labelId: 'val-blur',     key: 'blur',       suffix: 'px' }, // ç¡®ä¿ Blur åœ¨è¿™é‡Œ
            { id: 'bg-brightness', labelId: 'val-bright',   key: 'brightness', suffix: '%' },
            { id: 'bg-contrast',   labelId: 'val-contrast', key: 'contrast',   suffix: '%' }
        ];

        bgInputs.forEach(item => {
            const inputEl = document.getElementById(item.id);
            const labelEl = document.getElementById(item.labelId);

            if (inputEl) {
                inputEl.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    BG_STATE[item.key] = val;
                    if (labelEl) labelEl.innerText = val + item.suffix;

                    // ğŸ”¥ æ›´æ–° Shader Uniforms
                    if (bgMaterial) {
                        if (item.key === 'opacity') {
                            bgMaterial.uniforms.uOpacity.value = val;
                        }
                        else if (item.key === 'blur') {
                            // bgMaterial.uniforms.uBlur.value = val;
                        }
                        else if (item.key === 'brightness') {
                            // UI æ˜¯ 0% ~ 200%ï¼Œé»˜è®¤ 100%ã€‚ Shader éœ€è¦åç§»é‡ã€‚
                            bgMaterial.uniforms.uBrightness.value = (val - 100) / 100;
                        }
                        else if (item.key === 'contrast') {
                            // UI æ˜¯ 0% ~ 200%ï¼Œé»˜è®¤ 100%ã€‚ Shader ä¹˜æ•°ã€‚
                            bgMaterial.uniforms.uContrast.value = val / 100;
                        }
                    }

                    // å¡«å……æ¨¡å¼å˜åŒ–ä¹Ÿéœ€è¦æ›´æ–°
                    if (item.key === 'fit') updateBackgroundUV();
                });
            }
        });

        // å¡«å……æ¨¡å¼ç›‘å¬
        document.getElementById('bg-fit').addEventListener('change', (e) => {
            BG_STATE.fit = e.target.value;
            updateBackgroundUV();
        });

        updateGridBackground();

        // ğŸ”¥ 1. åˆå§‹åŒ–æ—¶æ¸²æŸ“æ ‡å°º
        renderRulers();

        let isSyncing = false;

        // 1. å³ä¾§ä¸»åŠ¨æ»šåŠ¨ -> å¸¦åŠ¨å·¦ä¾§å’Œä¸Šæ–¹
        DOM.timelineLanes.addEventListener('scroll', () => {
            if (!isSyncing) {
                window.requestAnimationFrame(() => {
                    // å‚ç›´åŒæ­¥å·¦ä¾§
                    DOM.headers.scrollTop = DOM.timelineLanes.scrollTop;
                    // æ°´å¹³åŒæ­¥ä¸Šæ–¹æ ‡å°º
                    DOM.rulerContent.scrollLeft = DOM.timelineLanes.scrollLeft;
                    isSyncing = false;
                });
                isSyncing = true;
            }
        }, { passive: true }); // passive: true æå‡æ»šåŠ¨æ€§èƒ½

        // 2. å·¦ä¾§è¢«åŠ¨åŒºåŸŸ -> ç›‘å¬æ»šè½®äº‹ä»¶ï¼Œæ‰‹åŠ¨é©±åŠ¨å³ä¾§æ»šåŠ¨
        DOM.headers.addEventListener('wheel', (e) => {
            e.preventDefault(); // é˜»æ­¢æµè§ˆå™¨é»˜è®¤è¡Œä¸º

            // å°†å·¦ä¾§çš„æ»šè½®åŠ¨ä½œâ€œè½¬å‘â€ç»™å³ä¾§
            DOM.timelineLanes.scrollTop += e.deltaY;
            DOM.timelineLanes.scrollLeft += e.deltaX; // å¦‚æœä½ æœ‰æ¨ªå‘è§¦æ‘¸æ¿ï¼Œè¿™ä¹Ÿæ”¯æŒ
        }, { passive: false });

        // ğŸ”¥ æ–°å¢ï¼šç‚¹å‡»æ ‡å°ºåŒºåŸŸä¹Ÿèƒ½è·³è½¬æ—¶é—´ (Seek)
        DOM.rulerContent.addEventListener('mousedown', (e) => {
            // è®¡ç®—ç‚¹å‡»ä½ç½®ç›¸å¯¹äºæ ‡å°ºå†…å®¹çš„ X åæ ‡
            const rect = DOM.rulerContent.getBoundingClientRect();
            // å¿…é¡»åŠ ä¸Š scrollLeftï¼Œå› ä¸ºæ ‡å°ºæ˜¯å¯ä»¥æ»šåŠ¨çš„
            const offsetX = e.clientX - rect.left + DOM.rulerContent.scrollLeft;

            const time = offsetX / STATE.pxPerSec;
            seekTo(time);

            // (å¯é€‰) å¦‚æœä½ æƒ³æ”¯æŒâ€œåœ¨æ ‡å°ºä¸Šæ‹–åŠ¨ scrubbingâ€
            // å¯ä»¥å¤ç”¨ç±»ä¼¼äº Clip æ‹–æ‹½çš„é€»è¾‘ï¼Œç›‘å¬ mousemove
        });

        // äº‹ä»¶ç›‘å¬
        DOM.playBtn.addEventListener('click', togglePlay);
        DOM.stopBtn.addEventListener('click', stopPlay);

        // âœ… ç»‘å®šæ–°çš„ Input é€»è¾‘
        document.getElementById('midiInput').addEventListener('change', (e) => processMidiFile(e.target.files[0]));
        document.getElementById('audioInput').addEventListener('change', (e) => processAudioFile(e.target.files[0]));

        // 2. ç»‘å®šæŒ‰é’®ç‚¹å‡»äº‹ä»¶ (è°ƒç”¨ä¸Šé¢çš„å‡½æ•°)
        document.getElementById('bgInput').addEventListener('change', (e) => {
            processBackgroundFile(e.target.files[0]);
        });

        document.getElementById('thicknessSlider').addEventListener('input', (e) => {
            // 0.1 åˆ° 2.0 å€
            STATE.noteThickness = parseInt(e.target.value) / 100;
            // é‡å»º 3D åœºæ™¯
            STATE.clips.forEach(c => c.build3D());
            updateAllTracksVisibility(); // ğŸ”¥ ç¡®ä¿é‡å»ºååˆ·æ–°å¯è§æ€§
        });

        document.getElementById('heightSlider').addEventListener('input', (e) => {
            STATE.noteHeightScale = parseInt(e.target.value) / 100;
            // é‡å»ºæ‰€æœ‰ Clip çš„ 3D æ¨¡å‹
            STATE.clips.forEach(c => c.build3D());
            updateAllTracksVisibility(); // ğŸ”¥ ç¡®ä¿é‡å»ºååˆ·æ–°å¯è§æ€§
        });

        document.getElementById('zSpaceSlider').addEventListener('input', (e) => {
            // æ»‘å—å€¼ 0-200ï¼Œé™¤ä»¥ 10 å¾—åˆ° 0.0 - 20.0 çš„èŒƒå›´
            STATE.zSeparation = parseInt(e.target.value) / 10;

            updateTrackZRanks();

            // é‡å»ºæ‰€æœ‰ MIDI æ¨¡å‹çš„ 3D å½¢æ€
            STATE.clips.forEach(c => c.build3D());
            updateAllTracksVisibility();
        });

        // åœ¨ initController å‡½æ•°å†…éƒ¨

        DOM.sceneZoom.addEventListener('input', (e) => {
            // 1. è·å–æ—§é€Ÿåº¦å’Œæ–°é€Ÿåº¦
            const oldSpeed = STATE.playbackSpeed;
            const newSpeed = parseInt(e.target.value);

            STATE.playbackSpeed = newSpeed;

            // 2. æ ¸å¿ƒä¿®å¤ï¼šè®¡ç®—ç¼©æ”¾å¯¼è‡´çš„ä¸­å¿ƒç‚¹ä½ç§»å·®
            // åªæœ‰åŸºäº currentTime è®¡ç®—ï¼Œæ‰èƒ½ä¿è¯ä»¥"æ’­æ”¾å¤´"ä¸ºä¸­å¿ƒç¼©æ”¾
            const oldFocusX = STATE.currentTime * oldSpeed;
            const newFocusX = STATE.currentTime * newSpeed;
            const delta = newFocusX - oldFocusX;

            // 3. é‡å»º 3D ç‰©ä½“ (ä¿æŒä¸å˜)
            STATE.clips.forEach(c => c.build3D());
            updateAllTracksVisibility(); // ğŸ”¥ ç¡®ä¿é‡å»ºååˆ·æ–°å¯è§æ€§

            // 4. ç«‹å³ä¿®æ­£ç›¸æœºå’Œæ§åˆ¶å™¨çš„ä½ç½®
            camera.position.x += delta;
            controls.target.x += delta;

            // 5. ğŸ”¥ å…³é”®ï¼šåŒæ­¥å…¨å±€è¿½è¸ªå˜é‡
            // è¿™å‘Šè¯‰ animate() å¾ªç¯ï¼š"ç›¸æœºå·²ç»åˆ°æ–°ä½ç½®äº†ï¼Œä¸‹ä¸€å¸§ä¸è¦å†é‡å¤è®¡ç®—è¿™ä¸ªä½ç§»äº†"
            cameraTargetX = newFocusX;
        });

        // æ—¶é—´è½´ç‚¹å‡»è·³è½¬
        DOM.timelineLanes.addEventListener('mousedown', (e) => {
            // å¦‚æœç‚¹å‡»çš„æ˜¯ clipï¼Œä¸è¦è·³è½¬
            if(e.target.classList.contains('clip') || e.target.classList.contains('clip-name')) return;

            const rect = DOM.timelineLanes.getBoundingClientRect();
            const offsetX = e.clientX - rect.left + DOM.timelineLanes.scrollLeft;
            const time = offsetX / STATE.pxPerSec;
            seekTo(time);
        });

        DOM.timelineLanes.addEventListener('scroll', () => {
            DOM.headers.scrollTop = DOM.timelineLanes.scrollTop;
        });

        window.addEventListener('keydown', (e) => {
            const target = e.target;
            const tag = target.tagName.toUpperCase();

            // ============================================================
            // ğŸ”¥ æ ¸å¿ƒä¿®å¤ 1ï¼šæ›´ç²¾å‡†çš„â€œæ­£åœ¨æ‰“å­—â€æ£€æµ‹
            // ============================================================
            // åªåœ¨ç”¨æˆ·çœŸæ­£éœ€è¦æ‰“å­—çš„æ—¶å€™ï¼ˆæ–‡æœ¬æ¡†ã€æ•°å­—æ¡†ã€å¤‡æ³¨æ¡†ï¼‰æ‰å±è”½å¿«æ·é”®
            // å…è®¸ input[type="range"] (æ»‘å—), input[type="color"], button ç­‰å“åº”å…¨å±€å¿«æ·é”®
            const isTyping = (
                tag === 'TEXTAREA' ||
                target.isContentEditable ||
                (tag === 'INPUT' && (target.type === 'text' || target.type === 'number' || target.type === 'password' || target.type === 'search'))
            );

            if (isTyping) {
                // å¦‚æœæ­£åœ¨æ‰“å­—ï¼Œä¸è¦è§¦å‘ DAW çš„å¿«æ·é”®ï¼Œä½†è¦å…è®¸ ESC é€€å‡ºç„¦ç‚¹
                if (e.code === 'Escape') target.blur();
                return;
            }

            if (e.code === 'Escape') {
                // 1. å®šä¹‰æ‰€æœ‰å¼¹çª—çš„ ID åˆ—è¡¨
                const modalIds = [
                    'export-modal',
                    'save-project-modal',
                    'bg-settings-modal',
                    'view-settings-modal',
                    'model-preview-modal',
                    'version-modal',
                    'context-menu' // å³é”®èœå•
                ];

                // 2. éå†éšè—
                modalIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = 'none';
                });

                // 3. ç‰¹æ®Šå¤„ç†é¢œè‰²é€‰æ‹©å™¨ (è°ƒç”¨ close æ–¹æ³•ä»¥æ¸…ç†å†…éƒ¨å›è°ƒçŠ¶æ€)
                if (typeof ColorPickerMgr !== 'undefined') {
                    ColorPickerMgr.close();
                }

                // 4. ç‰¹æ®Šå¤„ç†æ¨¡å‹é¢„è§ˆ (æ¸…ç†åŠ¨ç”»å¾ªç¯)
                if (typeof closePreviewModal === 'function') {
                    closePreviewModal();
                }
            }

            // 5. ä¿å­˜ç›¸å…³å¿«æ·é”®
            if ((e.ctrlKey || e.metaKey) && e.code === 'KeyS') {
                e.preventDefault(); // é˜»æ­¢æµè§ˆå™¨é»˜è®¤çš„ä¿å­˜å¼¹çª—

                if (e.shiftKey) {
                    // ğŸ”¥ æƒ…å†µ A: Shift + Ctrl + S (æˆ– Shift + Cmd + S) -> å¼ºåˆ¶å¦å­˜ä¸º (Save As)
                    // ç”Ÿæˆé»˜è®¤æ–‡ä»¶å
                    const defaultName = `SeeMusic_Project_${new Date().toLocaleDateString().replace(/\//g, '-')}`;
                    // è°ƒç”¨å¦å­˜ä¸ºé€»è¾‘
                    ProjectMgr.executeSave(defaultName);
                    console.log("è§¦å‘å¦å­˜ä¸º (Save As)");
                } else {
                    // ğŸ”¥ æƒ…å†µ B: Ctrl + S (æˆ– Cmd + S) -> æ™ºèƒ½ä¿å­˜ (Quick Save)
                    // å¦‚æœæœ‰å¥æŸ„åˆ™è¦†ç›–ï¼Œæ²¡æœ‰åˆ™å¦å­˜ä¸º
                    ProjectMgr.quickSave();
                }
            }

            // --- M é”®ï¼šMute é€‰ä¸­è½¨é“ ---
            if (e.code === 'KeyM') {
                if (STATE.selectedTrackIds.size > 0) {
                    const firstId = Array.from(STATE.selectedTrackIds)[0];
                    const firstTrack = STATE.tracks.find(t => t.id === firstId);
                    const targetMute = !firstTrack.isMuted;

                    STATE.selectedTrackIds.forEach(id => {
                        const t = STATE.tracks.find(track => track.id === id);
                        if (t) t.setMute(targetMute);
                    });
                    updateAllTracksVisibility();
                }
            }

            // --- S é”®ï¼šSolo é€‰ä¸­è½¨é“ ---
            if (e.code === 'KeyS') {
                if (STATE.selectedTrackIds.size > 0) {
                    const firstId = Array.from(STATE.selectedTrackIds)[0];
                    const firstTrack = STATE.tracks.find(t => t.id === firstId);
                    const targetSolo = !firstTrack.isSoloed;

                    STATE.selectedTrackIds.forEach(id => {
                        const t = STATE.tracks.find(track => track.id === id);
                        if (t) t.setSolo(targetSolo);
                    });
                    updateAllTracksVisibility();
                }
            }

            // ============================================================
            // ğŸ”¥ æ ¸å¿ƒä¿®å¤ 2ï¼šæ’­æ”¾æ§åˆ¶ (ç©ºæ ¼é”®) ç»ˆææŠ¢ç„¦ç‚¹
            // ============================================================
            if(e.code === 'Space') {
                // 1. é˜»æ­¢æµè§ˆå™¨é»˜è®¤è¡Œä¸º (é˜²æ­¢æ»šåŠ¨é¡µé¢ã€é˜²æ­¢è§¦å‘æŒ‰é’®ç‚¹å‡»)
                e.preventDefault();
                e.stopPropagation();

                // 2. ğŸ”¥ğŸ”¥ğŸ”¥ å¼ºåˆ¶ç§»é™¤ç„¦ç‚¹ (Blur) ğŸ”¥ğŸ”¥ğŸ”¥
                // æ— è®ºå½“å‰ç„¦ç‚¹æ˜¯åœ¨ Button ä¸Šï¼Œè¿˜æ˜¯åœ¨ Range æ»‘å—ä¸Šï¼Œç»Ÿç»Ÿç§»é™¤ï¼
                // è¿™æ ·ç©ºæ ¼é”®å°±åªå±äºâ€œæ’­æ”¾/æš‚åœâ€ï¼Œç»ä¸ä¼šè¯¯è§¦å…¶ä»–æ§ä»¶
                if (document.activeElement && document.activeElement !== document.body) {
                    document.activeElement.blur();
                }

                togglePlay();
            }

            // 3. åˆ é™¤ (Delete / Backspace)
            if (e.code === 'Backspace' || e.code === 'Delete') {
                if (STATE.selectedTrackIds.size > 0) {
                    e.preventDefault();

                    const tracksToDelete = [];
                    STATE.selectedTrackIds.forEach(id => {
                        const t = STATE.tracks.find(x => x.id === id);
                        if(t) tracksToDelete.push(t);
                    });

                    tracksToDelete.forEach(t => {
                        const trackData = serializeTrack(t);
                        const index = STATE.tracks.indexOf(t);

                        HistoryMgr.add({
                            type: 'delete_track',
                            trackData: trackData,
                            index: index
                        });

                        deleteTrackContext(t);
                    });
                }
            }

            // 4. æ’¤é”€ä¸é‡åš (Ctrl+Z / Ctrl+Y)
            if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.code === 'KeyZ') {
                e.preventDefault();
                HistoryMgr.undo();
            }
            if ((e.ctrlKey || e.metaKey) && e.code === 'KeyY') {
                e.preventDefault();
                HistoryMgr.redo();
            }
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.code === 'KeyZ') {
                e.preventDefault();
                HistoryMgr.redo();
            }
        });

        const sliders = ['sceneZoom', 'thicknessSlider', 'heightSlider'];
        sliders.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                // 1. é˜»æ­¢ mousedown å†’æ³¡ï¼Œé˜²æ­¢è§¦å‘çˆ¶çº§ç‚¹å‡»é€»è¾‘
                el.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                });

                // 2. ã€å…³é”®ã€‘é˜»æ­¢ dragstartã€‚
                // å¦‚æœä¸åŠ è¿™ä¸ªï¼Œå¿«é€Ÿæ‹–åŠ¨æ—¶æµè§ˆå™¨ä¼šä»¥ä¸ºä½ åœ¨æ‹–æ‹½å›¾ç‰‡ï¼Œä»è€Œä¸­æ–­æ»‘å—æ“ä½œã€‚
                el.addEventListener('dragstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });

                // 3. é’ˆå¯¹è§¦æ‘¸å±/è§¦æ§æ¿çš„ä¿®å¤
                el.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                }, { passive: false });
            }
        });

        // ğŸ”¥ æ ¸å¿ƒä¿®å¤ 2ï¼šåˆå§‹åŒ–æ—¶ä¹ŸåŒæ­¥ä¸€ä¸‹ 3D Zoom å’Œå…¶ä»–æ»‘å—
        if (DOM.sceneZoom) {
            STATE.playbackSpeed = parseInt(DOM.sceneZoom.value);
        }
        updateGridBackground();

        const menu = document.getElementById('context-menu');
        const menuGroup = document.getElementById('menu-group');
        const menuUngroup = document.getElementById('menu-ungroup');

        const shapeSelect = document.getElementById('noteShapeSelect');
        const modelInput = document.getElementById('customModelInput');

        if (shapeSelect) {
            shapeSelect.addEventListener('keydown', (e) => e.stopPropagation());

            shapeSelect.addEventListener('change', (e) => {
                const val = e.target.value;

                if (val === 'custom') {
                    // å¦‚æœé€‰äº†è‡ªå®šä¹‰ï¼Œè§¦å‘æ–‡ä»¶é€‰æ‹©
                    modelInput.click();
                    // æš‚æ—¶åˆ‡å›ä¸Šä¸€ä¸ªçŠ¶æ€ï¼Œé˜²æ­¢è¿˜æ²¡é€‰æ–‡ä»¶å°±å´©äº†ï¼ˆå¯é€‰ä¼˜åŒ–ï¼‰
                } else {
                    STATE.noteShape = val;
                    refreshAllMidiMeshes();
                }
            });
        }

        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        if (modelInput) {
            modelInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // æ˜¾ç¤ºåŠ è½½ä¸­...
                const loader = new GLTFLoader();
                const reader = new FileReader();

                reader.onload = (ev) => {
                    loader.parse(ev.target.result, '', (gltf) => {

                        // 1. å‡†å¤‡ä¸€ä¸ªæ•°ç»„å­˜æ”¾æ‰€æœ‰é›¶ä»¶
                        const geometries = [];

                        // 2. å¼ºåˆ¶æ›´æ–°ä¸€ä¸‹æ¨¡å‹çš„ä¸–ç•ŒçŸ©é˜µï¼Œç¡®ä¿é›¶ä»¶ä½ç½®æ­£ç¡®
                        gltf.scene.updateMatrixWorld(true);

                        // 3. éå†æ‰€æœ‰å­å¯¹è±¡
                        gltf.scene.traverse((child) => {
                            if (child.isMesh) {
                                // å…‹éš†å‡ ä½•ä½“
                                const geo = child.geometry.clone();

                                // ğŸ”¥ å…³é”®æ­¥éª¤ï¼šåº”ç”¨è¯¥é›¶ä»¶åœ¨æ¨¡å‹ä¸­çš„ä½ç½®/æ—‹è½¬/ç¼©æ”¾
                                // å¦‚æœä¸åŠ è¿™è¡Œï¼Œæ‰€æœ‰æŒ‰é”®éƒ½ä¼šå †åœ¨åŸç‚¹(0,0,0)
                                geo.applyMatrix4(child.matrixWorld);

                                // æ”¶é›†èµ·æ¥
                                geometries.push(geo);
                            }
                        });

                        if (geometries.length > 0) {
                            // ğŸ”¥ 4. ä½¿ç”¨å·¥å…·å°†æ‰€æœ‰é›¶ä»¶åˆå¹¶æˆä¸€ä¸ªå·¨å¤§çš„å‡ ä½•ä½“
                            // useGroups: false è¡¨ç¤ºæˆ‘ä»¬ä¸éœ€è¦ä¿ç•™å¤šæè´¨åˆ†ç»„ï¼ˆå› ä¸ºåæ­£è¦å˜æˆå‘å…‰éŸ³ç¬¦ï¼‰
                            let mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries, false);

                            // 5. å±…ä¸­å¹¶æ ‡å‡†åŒ–å¤§å° (å¤ç”¨ä½ ä¹‹å‰çš„é€»è¾‘)
                            mergedGeometry = normalizeGeometry(mergedGeometry);

                            // 6. æ•æ‰ç¬¬ä¸€ä¸ªæè´¨ç”¨äºé¢„è§ˆ (å¯é€‰ï¼Œå–ç¬¬ä¸€ä¸ªé›¶ä»¶çš„æè´¨)
                            // é•¿ç¬›é€šå¸¸æè´¨éƒ½ä¸€æ ·ï¼Œå–ç¬¬ä¸€ä¸ªå°±è¡Œ
                            let foundMaterial = null;
                            gltf.scene.traverse(c => {
                                if (!foundMaterial && c.isMesh) foundMaterial = c.material;
                            });

                            // 7. æ‰“å¼€é¢„è§ˆçª—å£
                            openPreviewModal(mergedGeometry, foundMaterial);

                        } else {
                            alert("é”™è¯¯ï¼šæ¨¡å‹ä¸­æ²¡æœ‰å‘ç°ä»»ä½• Mesh å‡ ä½•ä½“ã€‚");
                        }
                    }, (err) => {
                        console.error(err);
                        alert("æ¨¡å‹è§£æå¤±è´¥ï¼Œå¯èƒ½æ˜¯æ–‡ä»¶æŸåã€‚");
                    });
                };
                reader.readAsArrayBuffer(file);
                e.target.value = '';
            });
        }

        const resetBtn = document.getElementById('resetViewBtn');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                // 1. æ¢å¤ DOM å…ƒç´ çš„å€¼åˆ°é»˜è®¤ (å‚è€ƒ HTML ä¸­çš„ value)
                // DOM.timelineZoom.value = 50;
                DOM.sceneZoom.value = 8;
                document.getElementById('heightSlider').value = 250;
                document.getElementById('thicknessSlider').value = 150;

                if (shapeSelect) {
                    shapeSelect.value = 'capsule';
                    STATE.noteShape = 'capsule';
                }

                // 2. æ‰‹åŠ¨è§¦å‘ input äº‹ä»¶ï¼Œåˆ©ç”¨å·²æœ‰çš„ç›‘å¬å™¨å»æ›´æ–° STATE å’Œ 3D è§†å›¾
                // è¿™æ ·ä¸éœ€è¦é‡å†™æ›´æ–°é€»è¾‘
                [DOM.timelineZoom, DOM.sceneZoom, document.getElementById('heightSlider'), document.getElementById('thicknessSlider')].forEach(el => {
                    el.dispatchEvent(new Event('input'));
                });

                STATE.clips.forEach(c => { if (c.track.type === 'midi') c.build3D(); });

                // 3. é¢å¤–ç¡®ä¿ç½‘æ ¼æ›´æ–°
                updateGridBackground();
            });
        }

        // éšè—èœå• (ç‚¹å‡»ç©ºç™½å¤„)
        window.addEventListener('click', () => {
            menu.style.display = 'none';
        });

        // ç»‘å®šèœå•åŠ¨ä½œ
        menuGroup.addEventListener('click', () => {
            createGroupForSelection();
            menu.style.display = 'none';
        });

        menuUngroup.addEventListener('click', () => {
            ungroupSelection();
            menu.style.display = 'none';
        });

        initScrubbing();

        ViewMgr.init();
    }

    // --- ç»ˆæç‰ˆ ViewMgr (çƒåæ ‡ + è§’åº¦ä¿®æ­£ + Xå¹³ç§») ---
    const ViewMgr = {
        // é»˜è®¤å€¼ï¼šè·ç¦»80ï¼Œæ°´å¹³0åº¦ï¼Œå‚ç›´-30åº¦(ç›¸å½“äºåŸæ¥çš„60åº¦ä¿¯è§†)
        defaults: { radius: 200, theta: 0, phi: 0, targetX: 0, targetY: 0 },

        init() {
            this.modal = document.getElementById('view-settings-modal');
            this.inputs = {
                radius: document.getElementById('cam-radius'),
                theta: document.getElementById('cam-theta'),
                phi: document.getElementById('cam-phi'),
                targetX: document.getElementById('target-off-x'), // æ–°å¢
                targetY: document.getElementById('target-off-y')
            };

            // ç»‘å®šäº‹ä»¶ (ä¿æŒä¸å˜)
            document.getElementById('viewSettingsBtn').addEventListener('click', () => {
                this.modal.style.display = 'flex';
                this.forceSync();
            });
            document.getElementById('closeViewSettingsBtn').addEventListener('click', () => {
                this.modal.style.display = 'none';
            });
            // å›è½¦é”®
            Object.values(this.inputs).forEach(el => {
                if(el) el.addEventListener('keydown', e => {
                    if(e.key === 'Enter') this.applyFromUIToScene();
                });
            });
            // å¯¼å…¥å¯¼å‡º
            document.getElementById('exportViewBtn').addEventListener('click', () => this.exportToFile());
            const fileInput = document.getElementById('viewParamInput');
            document.getElementById('importViewBtn').addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                if (e.target.files[0]) this.importFromFile(e.target.files[0]);
                e.target.value = '';
            });
        },

        // ğŸ”¥ è·å–é€»è¾‘ (åœºæ™¯ -> UI)
        getCurrentSpherical() {
            if (!camera || !controls) return null;

            // 1. ç›¸å¯¹å‘é‡
            const offset = new THREE.Vector3().copy(camera.position).sub(controls.target);
            const spherical = new THREE.Spherical().setFromVector3(offset);

            // 2. è§’åº¦ä¿®æ­£
            // Three.js: 0=é¡¶, 90=å¹³, 180=åº•
            // ç”¨æˆ·ä¹ æƒ¯: -90=é¡¶, 0=å¹³, 90=åº• (æˆ–è€…åè¿‡æ¥)
            // è¿™é‡Œæˆ‘ä»¬è¦è®© "90åº¦(æ°´å¹³)" æ˜¾ç¤ºä¸º "0åº¦" -> å…¬å¼: æ˜¾ç¤ºå€¼ = çœŸå®å€¼ - 90
            const displayPhi = THREE.MathUtils.radToDeg(spherical.phi) - 90;
            const displayTheta = THREE.MathUtils.radToDeg(spherical.theta);

            // 3. è®¡ç®—ç›¸å¯¹ Target X
            // cameraTargetX æ˜¯å…¨å±€å˜é‡ï¼Œä»£è¡¨æ’­æ”¾å¤´çš„ç†è®ºä½ç½®
            // controls.target.x æ˜¯å½“å‰ç›¸æœºçš„çœ‹å‘ç‚¹
            // å®ƒä»¬çš„å·®å€¼å°±æ˜¯ç”¨æˆ·çš„ "Pan Offset X"
            const relTargetX = controls.target.x - (typeof cameraTargetX !== 'undefined' ? cameraTargetX : 0);

            return {
                radius: spherical.radius,
                theta: displayTheta,
                phi: displayPhi,
                targetX: relTargetX,
                targetY: controls.target.y
            };
        },

        // å®æ—¶æ›´æ–°å¼¹çª— UI
        updateLiveUI() {
            if (!this.modal || this.modal.style.display === 'none') return;
            const s = this.getCurrentSpherical();
            if (!s) return;

            const active = document.activeElement;
            const safeUpdate = (el, val) => { if (active !== el) el.value = val; };

            safeUpdate(this.inputs.radius, s.radius.toFixed(1));
            safeUpdate(this.inputs.theta,  s.theta.toFixed(1));
            safeUpdate(this.inputs.phi,    s.phi.toFixed(1)); // å·²ç»æ˜¯ä¿®æ­£è¿‡çš„è§’åº¦
            safeUpdate(this.inputs.targetX, s.targetX.toFixed(1));
            safeUpdate(this.inputs.targetY, s.targetY.toFixed(1));
        },

        forceSync() {
            const s = this.getCurrentSpherical();
            if(!s) return;
            this.inputs.radius.value = s.radius.toFixed(1);
            this.inputs.theta.value = s.theta.toFixed(1);
            this.inputs.phi.value = s.phi.toFixed(1);
            this.inputs.targetX.value = s.targetX.toFixed(1);
            this.inputs.targetY.value = s.targetY.toFixed(1);
        },

        // ğŸ”¥ åº”ç”¨é€»è¾‘ (UI -> åœºæ™¯)
        applyFromUIToScene() {
            if (!camera || !controls) return;

            const r = parseFloat(this.inputs.radius.value);
            const t = parseFloat(this.inputs.theta.value);
            const p = parseFloat(this.inputs.phi.value);
            const tx = parseFloat(this.inputs.targetX.value);
            const ty = parseFloat(this.inputs.targetY.value);

            // 1. è¿˜åŸè§’åº¦ (UI + 90 = çœŸå®Phi)
            const realPhi = p + 90;

            // 2. è½¬å›çƒåæ ‡
            // é™åˆ¶ Phi é˜²æ­¢ä¸‡å‘èŠ‚æ­»é” (0.001 ~ 179.999)
            const clampedPhi = Math.max(0.1, Math.min(179.9, realPhi));

            const spherical = new THREE.Spherical(
                r,
                THREE.MathUtils.degToRad(clampedPhi),
                THREE.MathUtils.degToRad(t)
            );

            const newOffset = new THREE.Vector3().setFromSpherical(spherical);

            // 3. åº”ç”¨ Target åç§»
            // Target X = æ’­æ”¾å¤´åŸºå‡†(cameraTargetX) + ç”¨æˆ·åç§»(tx)
            const baseX = (typeof cameraTargetX !== 'undefined' ? cameraTargetX : controls.target.x);
            controls.target.set(baseX + tx, ty, 0);

            // 4. åº”ç”¨ Camera ä½ç½®
            camera.position.copy(controls.target).add(newOffset);

            controls.update();
            document.activeElement.blur();
        },

        // åœ¨ ViewMgr å¯¹è±¡å†…éƒ¨ï¼š

        async exportToFile() {
            const s = this.getCurrentSpherical();
            const data = {
                name: "SeeMusic Spherical View",
                timestamp: new Date().toISOString(),
                params: s
            };
            const jsonStr = JSON.stringify(data, null, 2);

            // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šå°è¯•è°ƒç”¨ç³»ç»ŸåŸç”Ÿçš„"å¦å­˜ä¸º"çª—å£
            if (window.showSaveFilePicker) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: `View_Preset.json`, // é»˜è®¤æ–‡ä»¶å
                        types: [{
                            description: 'SeeMusic View Preset',
                            accept: {'application/json': ['.json']},
                        }],
                    });

                    // å†™å…¥æ–‡ä»¶
                    const writable = await handle.createWritable();
                    await writable.write(jsonStr);
                    await writable.close();

                    alert("é¢„è®¾ä¿å­˜æˆåŠŸï¼");
                    return; // æˆåŠŸåç›´æ¥ç»“æŸ
                } catch (err) {
                    // å¦‚æœç”¨æˆ·ç‚¹å‡»äº†å–æ¶ˆï¼Œä»€ä¹ˆéƒ½ä¸åš
                    if (err.name === 'AbortError') return;
                    console.warn("ä¿å­˜æ–‡ä»¶å‡ºé”™ï¼Œå°è¯•é™çº§ä¸ºè‡ªåŠ¨ä¸‹è½½:", err);
                }
            }

            // å¤‡ç”¨æ–¹æ¡ˆ (å…¼å®¹æ—§æµè§ˆå™¨)ï¼šè‡ªåŠ¨ä¸‹è½½
            const blob = new Blob([jsonStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `View_Preset.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        },

        importFromFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const json = JSON.parse(e.target.result);
                    if (json.params && json.params.radius !== undefined) {

                        // ğŸ”¥ ä¿®æ”¹ï¼šè®°å½•å†å²
                        const oldView = this.getCurrentSpherical(); // 1. ç•™åº•
                        this.restore(json.params);                  // 2. åº”ç”¨

                        HistoryMgr.add({                            // 3. å­˜æ¡£
                            type: 'change_view',
                            oldView: oldView,
                            newView: json.params
                        });
                        alert("è§†è§’é¢„è®¾å·²åŠ è½½");
                    } else {
                        alert("æ ¼å¼é”™è¯¯");
                    }
                } catch (err) { alert("JSON è§£æå¤±è´¥"); }
            };
            reader.readAsText(file);
        },

        restore(savedData) {
            if (!savedData) return;
            // ç®€å•å…¼å®¹æ—§ç‰ˆ
            if (savedData.radius !== undefined) {
                this.inputs.radius.value = savedData.radius;
                this.inputs.theta.value = savedData.theta;
                this.inputs.phi.value = savedData.phi;
                this.inputs.targetX.value = savedData.targetX || 0; // å…¼å®¹æ—§æ¡£
                this.inputs.targetY.value = savedData.targetY;
                this.applyFromUIToScene();
            }
        },

        reset() { this.restore(this.defaults); }
    };

    function refreshAllMidiMeshes() {
        if (!STATE || !STATE.clips) return;

        STATE.clips.forEach(c => {
            if (c.track.type === 'midi') c.build3D();
        });
        // ç¡®ä¿ updateAllTracksVisibility ä¹Ÿæ˜¯å…¨å±€å¯è®¿é—®çš„ï¼ˆé€šå¸¸å®ƒå·²ç»æ˜¯äº†ï¼‰
        if (typeof updateAllTracksVisibility === 'function') {
            updateAllTracksVisibility();
        }
    }

    function initDragAndDrop() {
        // 1. å…¨å±€é˜»æ­¢é»˜è®¤è¡Œä¸º
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            window.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
            }, false);
        });

        // 2. æ‹–å…¥æ˜¾ç¤ºå…¨å±é®ç½©
        window.addEventListener('dragenter', () => {
            document.body.classList.add('global-drag-over');
        });

        // 3. æ‹–ç¦»éšè—é®ç½©
        window.addEventListener('dragleave', (e) => {
            if (e.relatedTarget === null) {
                document.body.classList.remove('global-drag-over');
            }
        });

        // 4. é‡Šæ”¾æ–‡ä»¶
        window.addEventListener('drop', async (e) => {
            document.body.classList.remove('global-drag-over');

            // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šå¿…é¡»åœ¨ await ä¹‹å‰è·å– filesï¼ğŸ”¥ğŸ”¥ğŸ”¥
            // å¦åˆ™ä¸€æ—¦è¿›å…¥ await å¼‚æ­¥æµç¨‹ï¼Œe.dataTransfer å°±ä¼šè¢«æµè§ˆå™¨æ¸…ç©º
            const files = e.dataTransfer.files;

            // ğŸ”¥ å°è¯•è·å– FileSystemHandle (ç”¨äºæ”¯æŒæ‹–æ‹½åçš„ä¿å­˜)
            const items = e.dataTransfer.items;
            let droppedHandle = null;

            // ç°ä»£æµè§ˆå™¨æ”¯æŒ getAsFileSystemHandle
            if (items && items.length > 0) {
                const item = items[0];
                if (item.kind === 'file' && item.getAsFileSystemHandle) {
                    try {
                        const handle = await item.getAsFileSystemHandle();
                        if (handle.kind === 'file' && handle.name.endsWith('.json')) {
                            droppedHandle = handle;
                        }
                    } catch(err) { console.log("Drop handle access denied"); }
                }
            }

            // è¿™é‡Œä½¿ç”¨æˆ‘ä»¬æœ€å¼€å§‹æ•è·çš„ files å˜é‡ï¼Œè€Œä¸æ˜¯ e.dataTransfer.files
            if (files.length > 0) {
                // å¦‚æœæ£€æµ‹åˆ°æ˜¯ JSON ä¸”è·å–åˆ°äº†å¥æŸ„ï¼Œå­˜å…¥ ProjectMgr
                if (droppedHandle && files[0].name.endsWith('.json')) {
                    ProjectMgr.currentFileHandle = droppedHandle;
                } else {
                    // å¦‚æœæ‹–æ‹½çš„æ˜¯å…¶ä»–æ–‡ä»¶ï¼Œæˆ–è€…æµè§ˆå™¨ä¸æ”¯æŒ handleï¼Œæ¸…ç©ºå¥æŸ„ä»¥å…è¯¯å†™
                    if (files[0].name.endsWith('.json')) {
                        ProjectMgr.currentFileHandle = null;
                    }
                }

                handleGlobalDrop(files);
            }
        });
    }

    // ğŸ”¥ ç»Ÿä¸€çš„æ™ºèƒ½æ–‡ä»¶å¤„ç†å™¨
    function handleGlobalDrop(files) {
        Array.from(files).forEach(file => {
            const name = file.name.toLowerCase();
            const type = file.type;

            console.log(`æ£€æµ‹åˆ°æ–‡ä»¶: ${name} (${type})`);

            // ----------------------------------------------------
            // 1. MIDI æ–‡ä»¶
            // ----------------------------------------------------
            if (name.endsWith('.mid') || name.endsWith('.midi')) {
                processMidiFile(file);
            }

                // ----------------------------------------------------
                // 2. éŸ³é¢‘æ–‡ä»¶ (Audio)
                // ----------------------------------------------------
            // å®½æ¾åˆ¤æ–­ï¼šåªè¦ MIME æ˜¯ audio å¼€å¤´ï¼Œæˆ–è€…åç¼€æ˜¯ mp3/wav/ogg
            else if (type.startsWith('audio/') || name.endsWith('.mp3') || name.endsWith('.wav') || name.endsWith('.ogg') || name.endsWith('.m4a')) {
                processAudioFile(file);
            }

                // ----------------------------------------------------
                // 3. èƒŒæ™¯ç´ æ (Image / Video)
            // ----------------------------------------------------
            else if (type.startsWith('image/') || type.startsWith('video/') ||
                name.endsWith('.png') || name.endsWith('.jpg') || name.endsWith('.jpeg') ||
                name.endsWith('.mp4') || name.endsWith('.webm') || name.endsWith('.mov')) {
                processBackgroundFile(file);
            }

                // ----------------------------------------------------
                // 4. JSON æ–‡ä»¶ (éœ€è¦è¯»å–å†…å®¹æ¥åŒºåˆ†æ˜¯ "å·¥ç¨‹" è¿˜æ˜¯ "è§†è§’")
            // ----------------------------------------------------
            else if (name.endsWith('.json')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const json = JSON.parse(e.target.result);

                        // A. åˆ¤æ–­æ˜¯å¦ä¸ºã€å·¥ç¨‹æ–‡ä»¶ã€‘ (ç‰¹å¾ï¼šæœ‰ tracks å’Œ settings)
                        if (json.tracks && json.settings) {
                            console.log("è¯†åˆ«ä¸ºï¼šå·¥ç¨‹æ–‡ä»¶");
                            // æ”¯æŒæ’¤å›çš„åŠ è½½é€»è¾‘
                            const oldProjectState = ProjectMgr.getCurrentState();
                            ProjectMgr.restoreState(json);
                            HistoryMgr.add({
                                type: 'load_project',
                                oldProject: oldProjectState,
                                newProject: json
                            });
                        }
                        // B. åˆ¤æ–­æ˜¯å¦ä¸ºã€è§†è§’é¢„è®¾ã€‘ (ç‰¹å¾ï¼šæœ‰ params.radius)
                        else if (json.name === "SeeMusic Spherical View" || (json.params && json.params.radius !== undefined)) {
                            console.log("è¯†åˆ«ä¸ºï¼šè§†è§’é¢„è®¾");
                            const params = json.params || json;

                            // æ”¯æŒæ’¤å›çš„åŠ è½½é€»è¾‘
                            const oldView = ViewMgr.getCurrentSpherical();
                            ViewMgr.restore(params);
                            HistoryMgr.add({
                                type: 'change_view',
                                oldView: oldView,
                                newView: params
                            });

                            // ç®€å•çš„æ–‡å­—æç¤º
                            alert("âœ… è§†è§’å‚æ•°å·²åº”ç”¨");
                        }
                        else {
                            alert("âŒ æ— æ³•è¯†åˆ«çš„ JSON æ–‡ä»¶æ ¼å¼");
                        }
                    } catch (err) {
                        console.error(err);
                        alert("JSON è§£æå¤±è´¥");
                    }
                };
                reader.readAsText(file);
            }

                // ----------------------------------------------------
                // 5. 3D æ¨¡å‹ (.glb / .gltf)
            // ----------------------------------------------------
            else if (name.endsWith('.glb') || name.endsWith('.gltf')) {
                // æ—¢ç„¶æ”¯æŒå…¨å±æ‹–æ‹½ï¼Œè¿™é‡Œä¹Ÿå¯ä»¥é¡ºä¾¿æ”¯æŒæ‹–å…¥æ¨¡å‹
                // æ¨¡æ‹Ÿç‚¹å‡» inputï¼Œæˆ–è€…ç›´æ¥è°ƒç”¨ä¹‹å‰çš„æ¨¡å‹åŠ è½½é€»è¾‘
                // è¿™é‡Œç®€å•å¤„ç†ï¼šæç¤ºç”¨æˆ·å»ä¸‹é¢é€‰ï¼Œæˆ–è€…ä½ å¯ä»¥æŠŠä¹‹å‰çš„ GLTF åŠ è½½é€»è¾‘å¤ç”¨åˆ°è¿™é‡Œ
                alert("æ£€æµ‹åˆ° 3D æ¨¡å‹ï¼Œè¯·åœ¨ä¸‹æ–¹ã€Shape -> Customã€‘ä¸­é€‰æ‹©åŠ è½½ï¼Œæˆ–ç¼–å†™ä¸“é—¨çš„æ‹–æ‹½é€»è¾‘ã€‚");
            }

            else {
                console.warn("ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹:", name);
                alert("ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: " + name);
            }
        });
    }

    function initResizeHandle() {
        const handle = document.getElementById('resize-handle');
        const dawContainer = document.getElementById('daw-container');

        if (!handle || !dawContainer) return;

        handle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            document.body.classList.add('resizing');

            const startY = e.clientY;
            const startHeight = dawContainer.getBoundingClientRect().height;
            let animationFrameId = null;

            const onMouseMove = (moveEvent) => {
                // 1. è®¡ç®—é«˜åº¦
                const deltaY = moveEvent.clientY - startY;
                let newHeight = startHeight + deltaY;
                const minHeight = 100;
                const maxHeight = window.innerHeight - 150;

                if (newHeight >= minHeight && newHeight <= maxHeight) {
                    dawContainer.style.height = newHeight + 'px';

                    // 2. ä½¿ç”¨ 'drag' æ¨¡å¼è°ƒç”¨ï¼Œæè‡´ä¸æ»‘
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    animationFrameId = requestAnimationFrame(() => {
                        onResize('drag');
                    });
                }
            };

            const onMouseUp = () => {
                document.body.classList.remove('resizing');
                window.removeEventListener('mousemove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);

                // 3. æ¾æ‰‹ç¬é—´ï¼Œæ‰§è¡Œä¸€æ¬¡â€œå®Œç¾æ¸²æŸ“â€
                // æ­¤æ—¶è™½ç„¶ä¼šé—ªä¸€ä¸‹ï¼Œä½†ç”¨æˆ·å·²ç»åœæ­¢æ“ä½œäº†ï¼Œä½“éªŒæ˜¯å¯ä»¥æ¥å—çš„
                requestAnimationFrame(() => {
                    onResize();
                });
            };

            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
        });
    }

    // è¾…åŠ©ï¼šæ˜¾ç¤ºèœå• (å·²ä¼˜åŒ–è¾¹ç•Œæ£€æµ‹)
    function showContextMenu(x, y) {
        const menu = document.getElementById('context-menu');

        // å…ˆæ˜¾ç¤ºå‡ºæ¥ï¼Œæ‰èƒ½è·å–åˆ°å®ƒçš„å®½åº¦å’Œé«˜åº¦
        menu.style.display = 'block';

        // è·å–èœå•å°ºå¯¸å’Œçª—å£å°ºå¯¸
        const rect = menu.getBoundingClientRect();
        const winWidth = window.innerWidth;
        const winHeight = window.innerHeight;

        // 1. é˜²æ­¢è¶…å‡ºå³è¾¹ç•Œï¼šå¦‚æœ é¼ æ ‡X + èœå•å®½ > å±å¹•å®½ï¼Œåˆ™èœå•æ˜¾ç¤ºåœ¨é¼ æ ‡å·¦ä¾§
        if (x + rect.width > winWidth) {
            x -= rect.width;
        }

        // 2. é˜²æ­¢è¶…å‡ºä¸‹è¾¹ç•Œï¼šå¦‚æœ é¼ æ ‡Y + èœå•é«˜ > å±å¹•é«˜ï¼Œåˆ™èœå•æ˜¾ç¤ºåœ¨é¼ æ ‡ä¸Šæ–¹
        if (y + rect.height > winHeight) {
            y -= rect.height;
        }

        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
    }

    function updateGridBackground() {
        // æ›´æ–° CSS grid èƒŒæ™¯å¤§å°ä»¥åŒ¹é… 1ç§’çš„åƒç´ æ•°
        DOM.grid.style.backgroundSize = `${STATE.pxPerSec}px 100%`;
    }

    // ğŸ”¥ æ–°å¢è¾…åŠ©å‡½æ•°ï¼šç›´æ¥ä»äºŒè¿›åˆ¶æ•°æ®ä¸­æ‰«æè½¨é“åç§°
    function scanTrackNames(arrayBuffer) {
        const data = new Uint8Array(arrayBuffer);
        const names = [];
        let p = 0;

        // è¾…åŠ©ï¼šè¯»å–å˜é•¿æ•°å€¼ (Variable Length Quantity)
        function readVarInt() {
            let result = 0;
            while (p < data.length) {
                const b = data[p++];
                result = (result << 7) | (b & 0x7f);
                if ((b & 0x80) === 0) break;
            }
            return result;
        }

        // è¾…åŠ©ï¼šè¯»å–æŒ‡å®šé•¿åº¦å­—ç¬¦ä¸²
        function readString(len) {
            let s = "";
            for (let i = 0; i < len; i++) {
                if (p < data.length) {
                    // è¿‡æ»¤ä¸å¯è§å­—ç¬¦ï¼Œåªä¿ç•™ ASCII æˆ– UTF-8
                    const code = data[p++];
                    if (code > 0) s += String.fromCharCode(code);
                }
            }
            return decodeURIComponent(escape(s)); // å°è¯•è§£å†³ç®€å•çš„ç¼–ç é—®é¢˜
        }

        // 1. è·³è¿‡ Header Chunk (MThd)
        if (data.length > 14 &&
            data[0] === 0x4D && data[1] === 0x54 && data[2] === 0x68 && data[3] === 0x64) {
            p = 14;
        }

        // 2. éå† Track Chunks (MTrk)
        while (p < data.length - 8) {
            // å¯»æ‰¾ 'MTrk' æ ‡å¿—
            if (data[p] === 0x4D && data[p+1] === 0x54 && data[p+2] === 0x72 && data[p+3] === 0x6B) {
                p += 4; // è·³è¿‡æ ‡å¿—
                const trackLen = (data[p] << 24) | (data[p+1] << 16) | (data[p+2] << 8) | data[p+3];
                p += 4; // è·³è¿‡é•¿åº¦å­—æ®µ

                const chunkEnd = p + trackLen;
                let foundName = null;

                // æ‰«æè¯¥è½¨é“çš„å‰ 500 ä¸ªå­—èŠ‚ï¼ˆé€šå¸¸åå­—åœ¨æœ€å‰é¢ï¼‰
                // æ³¨æ„ï¼šè¿™æ˜¯ç®€åŒ–ç‰ˆæ‰«æï¼Œå‡è®¾ DeltaTime ä¸º 0 æˆ–å¾ˆçŸ­
                let scanLimit = p + 1000;
                if (scanLimit > chunkEnd) scanLimit = chunkEnd;

                let tempP = p;

                // ç®€å•çš„è¯•æ¢æ€§æ‰«æï¼šå¯»æ‰¾ FF 03 (Track Name)
                // åœ¨æ ‡å‡†çš„ MIDI æµä¸­ï¼Œæ ¼å¼é€šå¸¸æ˜¯ï¼š[DeltaTime] FF 03 [Len] [Text]
                // å¤§å¤šæ•° DAW å¯¼å‡ºçš„è½¨é“åéƒ½åœ¨ Tick 0ï¼ŒDeltaTime = 00
                while (tempP < scanLimit - 3) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ 00 FF 03 (DeltaTime=0, Meta=FF, Type=03)
                    // æˆ–è€…å¯èƒ½æ˜¯å˜é•¿ DeltaTimeï¼Œè¿™é‡Œä¸»è¦é€šè¿‡ç‰¹å¾ç  FF 03 æš´åŠ›åŒ¹é…
                    if (data[tempP] === 0xFF && data[tempP+1] === 0x03) {
                        const len = data[tempP+2];
                        // ç®€å•çš„å®Œæ•´æ€§æ£€æŸ¥ï¼šé•¿åº¦ä¸è¦å¤ªç¦»è°±
                        if (len > 0 && len < 100) {
                            let extracted = "";
                            for(let k=0; k<len; k++) extracted += String.fromCharCode(data[tempP+3+k]);
                            // ç§»é™¤ç©ºå­—ç¬¦å’Œä¹±ç 
                            foundName = extracted.replace(/\u0000/g, '').trim();
                            break;
                        }
                    }
                    tempP++;
                }
                names.push(foundName); // å³ä½¿æ˜¯ null ä¹Ÿè¦å ä½ï¼Œä¿æŒç´¢å¼•å¯¹é½

                p = chunkEnd; // è·³åˆ°ä¸‹ä¸€è½¨é“
            } else {
                p++; // æ²¡æ‰¾åˆ° MTrkï¼Œé€å­—èŠ‚åç§»ï¼ˆå®¹é”™ï¼‰
            }
        }
        return names;
    }

    function processMidiFile(file) {
        if (!file) return;

        DOM.loading.style.display = 'flex';
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                const arrayBuffer = ev.target.result;
                const midiData = new Midi(arrayBuffer);

                // 1. è¯»å– BPM å’Œ æ‹å·
                if (midiData.header) {
                    if (midiData.header.tempos && midiData.header.tempos.length > 0) {
                        STATE.bpm = Math.round(midiData.header.tempos[0].bpm);
                    }
                    if (midiData.header.timeSignatures && midiData.header.timeSignatures.length > 0) {
                        const tsObj = midiData.header.timeSignatures[0];
                        if (tsObj.timeSignature && tsObj.timeSignature.length >= 1) {
                            STATE.timeSignature = tsObj.timeSignature[0];
                        }
                    }
                    console.log(`å·²æ›´æ–°å·¥ç¨‹è®¾ç½®: BPM=${STATE.bpm}, æ‹å·=${STATE.timeSignature}/4`);
                }

                // ==========================================
                // ğŸ”¥ğŸ”¥ æ–°å¢ï¼šè‡ªåŠ¨ç§»é™¤ MIDI å¼€å¤´ç©ºç™½ ğŸ”¥ğŸ”¥
                // ==========================================
                let globalStartTime = Infinity;

                // 1. ç¬¬ä¸€æ¬¡éå†ï¼šæ‰¾åˆ°å…¨æ›²æœ€æ—©çš„éŸ³ç¬¦æ—¶é—´
                midiData.tracks.forEach(track => {
                    track.notes.forEach(note => {
                        if (note.time < globalStartTime) globalStartTime = note.time;
                    });
                });

                // 2. å¦‚æœå¼€å¤´æœ‰æ˜æ˜¾çš„ç©ºç™½ (ä¾‹å¦‚ > 0.05ç§’)ï¼Œåˆ™æ‰§è¡Œä¿®å‰ª
                if (globalStartTime > 0.05 && globalStartTime !== Infinity) {
                    console.log(`æ£€æµ‹åˆ° MIDI å¼€å¤´ç©ºç™½: ${globalStartTime.toFixed(3)}ç§’ï¼Œæ­£åœ¨è‡ªåŠ¨ç§»é™¤...`);

                    const offset = globalStartTime;

                    // 3. ç¬¬äºŒæ¬¡éå†ï¼šå°†æ‰€æœ‰äº‹ä»¶å‘å‰å¹³ç§»
                    midiData.tracks.forEach(track => {
                        // A. ç§»åŠ¨éŸ³ç¬¦
                        track.notes.forEach(note => {
                            note.time = Math.max(0, note.time - offset);
                        });

                        // B. ç§»åŠ¨æ§åˆ¶ä¿¡æ¯ (å¦‚å»¶éŸ³è¸æ¿ CC64)
                        if (track.controlChanges) {
                            Object.keys(track.controlChanges).forEach(ccKey => {
                                track.controlChanges[ccKey].forEach(ccEvent => {
                                    ccEvent.time = Math.max(0, ccEvent.time - offset);
                                });
                            });
                        }
                    });

                    // âŒ åˆ é™¤è¿™ä¸€è¡Œï¼šmidiData.duration æ˜¯è‡ªåŠ¨è®¡ç®—çš„åªè¯»å±æ€§ï¼Œæ— éœ€æ‰‹åŠ¨ä¿®æ”¹
                    // midiData.duration = Math.max(0, midiData.duration - offset);
                }
                // ==========================================
                // ğŸ”¥ğŸ”¥ ç»“æŸè‡ªåŠ¨ç§»é™¤é€»è¾‘ ğŸ”¥ğŸ”¥
                // ==========================================


                // è·å–æ‰€æœ‰åŸå§‹è½¨é“åç§°
                const rawTrackNames = scanTrackNames(arrayBuffer);
                const trackIndexOffset = Math.max(0, rawTrackNames.length - midiData.tracks.length);

                let targetTrack = STATE.tracks.find(t => t.type === 'midi' && t.clips.length === 0);
                let nameQueue = [];
                const newTrackIds = [];

                for (let i = 0; i < midiData.tracks.length; i++) {
                    const t = midiData.tracks[i];
                    const rawIndex = i + trackIndexOffset;

                    let currentRawName = "";
                    if (rawTrackNames[rawIndex] && rawTrackNames[rawIndex].length > 0) {
                        currentRawName = rawTrackNames[rawIndex].replace(/\u0000/g, '').trim();
                    }

                    if (currentRawName) {
                        nameQueue.push(currentRawName);
                    }

                    const hasNotes = t.notes.length > 0;

                    if (hasNotes) {
                        let finalName = "";
                        if (nameQueue.length > 0) {
                            finalName = nameQueue.shift();
                        } else {
                            finalName = `Track ${STATE.nextTrackId}`;
                        }

                        if (!finalName && t.instrument && t.instrument.name) {
                            finalName = t.instrument.name;
                        }

                        if (!targetTrack) {
                            targetTrack = new Track(`MIDI ${STATE.nextTrackId}`, 'midi');
                            STATE.tracks.push(targetTrack);
                        }

                        newTrackIds.push(targetTrack.id);
                        targetTrack.setName(finalName);

                        targetTrack.addClip(0, midiData.duration, t, finalName, t);
                        targetTrack = null;
                    }
                }

                updateTrackZRanks();

                autoFitZoom(midiData.duration);
                updateTotalDuration();
                STATE.clips.forEach(c => c.updateDOMPosition());
                reorderTracks();

                if (newTrackIds.length > 0) {
                    HistoryMgr.add({
                        type: 'import_tracks',
                        trackIds: newTrackIds
                    });
                }

            } catch (err) {
                console.error(err);
                alert("MIDI è§£æå¤±è´¥: " + file.name);
            }

            requestAnimationFrame(() => {
                window.dispatchEvent(new Event('resize'));
                if(typeof updateGridBackground === 'function') updateGridBackground();
            });

            DOM.loading.style.display = 'none';
        };
        reader.readAsArrayBuffer(file);
    }

    // ğŸ”¥ è¾…åŠ©å‡½æ•°ï¼šå°†è½¨é“å¯¹è±¡è½¬æ¢ä¸º JSON æ•°æ® (ç”¨äº Undo/Redo ä¿å­˜)
    function serializeTrack(track) {
        return {
            id: track.id,
            name: track.name,
            type: track.type,
            ownColor: track.ownColor,
            groupId: track.groupId,
            isMuted: track.isMuted,
            isSoloed: track.isSoloed,
            clips: track.clips.map(c => ({
                start: c.startTime,
                duration: c.duration,
                name: c.name,
                resourceId: c.name// è¿™é‡Œçš„ sourceFile åŒ…å«äº† Base64 æˆ–åŸå§‹æ•°æ®
            }))
        };
    }

    function reorderTracks() {
        // 1. æ’åºæ•°æ®æ•°ç»„ (Audio ä¼˜å…ˆï¼Œå…¶ä»–æŒ‰ ID)
        STATE.tracks.sort((a, b) => {
            // å¦‚æœç±»å‹ä¸åŒï¼ŒAudio æ’å‰é¢ (-1)
            if (a.type === 'audio' && b.type !== 'audio') return -1;
            if (a.type !== 'audio' && b.type === 'audio') return 1;

            // å¦‚æœç±»å‹ç›¸åŒï¼ŒæŒ‰åˆ›å»º ID æ’åº (ä¿æŒå…ˆåé¡ºåº)
            return a.id - b.id;
        });

        // 2. æŒ‰ç…§æ–°é¡ºåºé‡æ–°æ’åˆ— DOM
        // (appendChild å¦‚æœå…ƒç´ å·²å­˜åœ¨ï¼Œä¼šå°†å…¶ç§»åŠ¨åˆ°æœ«å°¾ï¼Œä»è€Œå®ç°é‡æ’)
        STATE.tracks.forEach(track => {
            // ç§»åŠ¨å·¦ä¾§ Header
            if (track.headerEl) {
                DOM.headers.appendChild(track.headerEl);
            }
            // ç§»åŠ¨å³ä¾§ Lane
            if (track.laneEl) {
                // æ³¨æ„ï¼šDOM.lanes é‡Œå¯èƒ½æœ‰ gridLines å’Œ playhead ç­‰ç»å¯¹å®šä½å…ƒç´ 
                // ä½† track-lane æ˜¯æµå¼å¸ƒå±€çš„ blockï¼Œè¿½åŠ åˆ°æœ€åå³å¯ä¿æŒå‚ç›´å †å é¡ºåº
                DOM.lanes.appendChild(track.laneEl);
            }
        });

        console.log("è½¨é“å·²é‡æ–°æ’åºï¼šAudio ç½®é¡¶");
    }

    // ğŸ”¥ æ–°å¢ï¼šä¸“é—¨ç”¨äºè®¡ç®— Zè½´æ’åçš„å‡½æ•° (åªåœ¨éœ€è¦æ—¶è°ƒç”¨ï¼Œä¸æ”¾åœ¨æ¸²æŸ“å¾ªç¯é‡Œ)
    function updateTrackZRanks() {
        const allMidiTracks = STATE.tracks.filter(t => t.type === 'midi');

        // è®¡ç®—æ¯ä¸ªè½¨é“çš„â€œç¬¬ä¸€é¢—éŸ³ç¬¦æ—¶é—´â€
        const trackOrderMap = allMidiTracks.map(t => {
            let realFirstNoteTime = Infinity;

            if (t.clips.length > 0) {
                t.clips.forEach(c => {
                    if (c.data && c.data.notes && c.data.notes.length > 0) {
                        let minRelTime = Infinity;
                        for (let n of c.data.notes) {
                            if (n.time < minRelTime) minRelTime = n.time;
                        }
                        const absTime = c.startTime + minRelTime;
                        if (absTime < realFirstNoteTime) {
                            realFirstNoteTime = absTime;
                        }
                    }
                });
            }
            if (realFirstNoteTime === Infinity) realFirstNoteTime = 999999;
            return { id: t.id, time: realFirstNoteTime };
        });

        // æ’åº
        trackOrderMap.sort((a, b) => {
            if (Math.abs(a.time - b.time) < 0.01) {
                return b.id - a.id;
            }
            return a.time - b.time;
        });

        // ğŸ”¥ å°†æ’åç›´æ¥å†™å…¥ Track å¯¹è±¡ç¼“å­˜èµ·æ¥
        trackOrderMap.forEach((item, index) => {
            const track = STATE.tracks.find(t => t.id === item.id);
            if(track) track.zRank = index;
        });

        console.log("Z-Index æ’åå·²æ›´æ–° (Cached)");
    }

    // ğŸ”¥ æ–°å¢å·¥å…·ï¼šè‡ªåŠ¨å‰ªåˆ‡éŸ³é¢‘å¼€å¤´çš„é™éŸ³
    function trimSilence(audioCtx, buffer, threshold = 0.01) {
        const rawData = buffer.getChannelData(0); // é€šå¸¸æ£€æµ‹å·¦å£°é“å³å¯
        const len = rawData.length;
        let startSample = 0;

        // 1. å¯»æ‰¾ç¬¬ä¸€ä¸ªè¶…è¿‡é˜ˆå€¼çš„ç‚¹
        for (let i = 0; i < len; i++) {
            if (Math.abs(rawData[i]) > threshold) {
                startSample = i;
                break;
            }
        }

        // å¦‚æœå¼€å¤´é™éŸ³å°‘äº 0.05ç§’ï¼Œå°±ä¸å¤„ç†äº†ï¼Œé¿å…ä¸å¿…è¦çš„è®¡ç®—
        // buffer.sampleRate é€šå¸¸æ˜¯ 44100 æˆ– 48000
        const safetyPadding = Math.floor(0.05 * buffer.sampleRate);

        // å›é€€ä¸€ç‚¹ç‚¹ï¼Œä¿ç•™ 0.05ç§’ çš„å‘¼å¸ç©ºé—´ï¼Œé˜²æ­¢èµ·éŸ³è¢«åˆ‡å
        startSample = Math.max(0, startSample - safetyPadding);

        if (startSample === 0) {
            console.log("éŸ³é¢‘å¼€å¤´æ²¡æœ‰æ˜æ˜¾çš„é™éŸ³ï¼Œæ— éœ€å‰ªåˆ‡ã€‚");
            return buffer;
        }

        console.log(`æ£€æµ‹åˆ°é™éŸ³ï¼Œå‰ªåˆ‡å‰ ${ (startSample / buffer.sampleRate).toFixed(3) } ç§’`);

        // 2. åˆ›å»ºæ–°çš„ Buffer
        const newLength = len - startSample;
        const newBuffer = audioCtx.createBuffer(
            buffer.numberOfChannels,
            newLength,
            buffer.sampleRate
        );

        // 3. å¤åˆ¶æ•°æ® (æ‰€æœ‰å£°é“éƒ½è¦åˆ‡)
        for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
            const oldChannelData = buffer.getChannelData(channel);
            const newChannelData = newBuffer.getChannelData(channel);

            // ä½¿ç”¨é«˜æ€§èƒ½çš„ subarray è¿›è¡Œå†…å­˜å¤åˆ¶
            // ä¹Ÿå°±æ˜¯æŠŠ oldData ä» startSample å¼€å§‹åˆ°æœ€åçš„æ•°æ®ï¼Œå¤åˆ¶åˆ° newData ä¸­
            newChannelData.set(oldChannelData.subarray(startSample));
        }

        return newBuffer;
    }

    async function processAudioFile(file) {
        if (!file) return;

        DOM.loading.style.display = 'flex';
        try {
            const existingTrack = STATE.tracks.find(t => t.type === 'audio');
            // å¦‚æœå­˜åœ¨æ—§è½¨é“ï¼Œä¿å­˜å®ƒçš„æ•°æ®ï¼›å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™ä¸º null
            const oldTrackData = existingTrack ? serializeTrack(existingTrack) : null;
            // ğŸ”¥ğŸ”¥ğŸ”¥ ä¿®å¤å¼€å§‹ï¼šå¤ç”¨å…¨å±€ AudioContext ğŸ”¥ğŸ”¥ğŸ”¥
            if (!sharedAudioCtx) {
                sharedAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            // ç¡®ä¿ Context æ˜¯è¿è¡ŒçŠ¶æ€ (æµè§ˆå™¨æœ‰æ—¶ä¼šä¸ºäº†çœç”µæš‚åœå®ƒ)
            if (sharedAudioCtx.state === 'suspended') {
                await sharedAudioCtx.resume();
            }
            const audioCtx = sharedAudioCtx;
            // ğŸ”¥ğŸ”¥ğŸ”¥ ä¿®å¤ç»“æŸ ğŸ”¥ğŸ”¥ğŸ”¥

            const arrayBuffer = await file.arrayBuffer();
            // 1. åŸå§‹è§£ç 
            let buffer = await audioCtx.decodeAudioData(arrayBuffer);

            // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šåœ¨è¿™é‡Œè°ƒç”¨è‡ªåŠ¨å‰ªåˆ‡ ğŸ”¥ğŸ”¥ğŸ”¥
            // é˜ˆå€¼ 0.01 ç›¸å½“äº -40dB å·¦å³ï¼Œæ—¢èƒ½åˆ‡æ‰åº•å™ªï¼Œåˆä¸ä¼šåˆ‡æ‰æå¼±çš„å¼€åœºéŸ³
            buffer = trimSilence(audioCtx, buffer, 0.01);

            // é‡æ–°è¯»å– Base64 ç”¨äºä¿å­˜ (è¿™ä¸ªä»…ä»…ç”¨äºå­˜æ¡£ï¼Œè§†è§‰å’Œæ’­æ”¾ä½¿ç”¨çš„æ˜¯ä¸Šé¢çš„ buffer)
            const base64Str = await new Promise((resolve) => {
                const r = new FileReader();
                r.onload = e => resolve(e.target.result);
                r.readAsDataURL(file);
            });

            // ==========================================
            // ğŸ”¥ æ ¸å¿ƒé€»è¾‘ï¼šæŸ¥æ‰¾æˆ–æ–°å»º
            // ==========================================

            let targetTrack = STATE.tracks.find(t => t.type === 'audio');

            if (targetTrack) {
                console.log("å¤ç”¨ç°æœ‰ Audio è½¨é“:", targetTrack.name);
                targetTrack.clearClips();
            } else {
                targetTrack = new Track("Audio", 'audio');
                STATE.tracks.push(targetTrack);
            }

            // ==========================================

            // 2. æ·»åŠ æ–° Clip (ä½¿ç”¨å‰ªåˆ‡åçš„ buffer)
            const clip = targetTrack.addClip(0, buffer.duration, buffer, file.name, base64Str);

            const url = URL.createObjectURL(file);
            DOM.audio.src = url;

            DOM.audio.playbackRate = 1.0;
            DOM.audio.preservesPitch = true;

            // ğŸ”¥ å…³é”®ä¿®æ­£ï¼šå› ä¸ºæˆ‘ä»¬åˆ‡æ‰äº†å¼€å¤´çš„é™éŸ³ï¼ŒHTML5 Audio æ’­æ”¾æ—¶éœ€è¦è·³è¿‡é‚£æ®µé™éŸ³
            // æˆ‘ä»¬è®¡ç®—ä¸€ä¸‹åˆ‡æ‰äº†å¤šå°‘ç§’
            const originalCtx = new (window.AudioContext || window.webkitAudioContext)();
            const originalBuffer = await originalCtx.decodeAudioData(await file.slice(0).arrayBuffer());
            const trimmedTime = originalBuffer.duration - buffer.duration;

            // è®°å½•è¿™ä¸ªåç§»é‡ï¼Œä»¥åæ’­æ”¾æ—¶å¯èƒ½ç”¨åˆ° (æš‚æ—¶åªéœ€å­˜ç€)
            clip.trimOffset = trimmedTime;

            // 4. æ›´æ–°å…¨å±€å¼•ç”¨
            STATE.activeAudioClip = clip;

            // 5. è§†å›¾è°ƒæ•´
            autoFitZoom(buffer.duration);
            updateTotalDuration();
            STATE.clips.forEach(c => c.updateDOMPosition());

            // 6. è‡ªåŠ¨å¯¹é½
            autoAlignAudioToMidi(true);

            // 7. é‡æ–°æ’åº
            if (typeof reorderTracks === 'function') reorderTracks();

            const newTrackData = serializeTrack(targetTrack);

            HistoryMgr.add({
                type: 'import_audio',
                oldData: oldTrackData, // å¦‚æœä¹‹å‰æ²¡è½¨é“ï¼Œè¿™é‡Œæ˜¯ null (æ’¤é”€=åˆ é™¤)
                newData: newTrackData  // (é‡åš=æ¢å¤è¿™ä¸ªæ–°è½¨é“)
            });

            requestAnimationFrame(() => {
                window.dispatchEvent(new Event('resize'));
                if(typeof updateGridBackground === 'function') updateGridBackground();
            });

        } catch (err) {
            console.error(err);
            alert("éŸ³é¢‘å¯¼å…¥å¤±è´¥: " + file.name);
        }
        DOM.loading.style.display = 'none';
    }

    function autoAlignAudioToMidi(isAuto = false) {
        // 1. å¯»æ‰¾ç›®æ ‡ Audio Track (æˆ‘ä»¬è¦ç§»åŠ¨çš„é‚£ä¸ª)
        // ç›®å‰é€»è¾‘æ˜¯ç§»åŠ¨ç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„ Audio è½¨é“
        const audioTrack = STATE.tracks.find(t => t.type === 'audio' && t.clips.length > 0);

        // 2. æ‰«ææ‰€æœ‰ MIDI è½¨é“ï¼Œå¯»æ‰¾å…¨å±€æœ€æ—©çš„éŸ³ç¬¦æ—¶é—´
        let earliestMidiTime = Infinity;
        let hasMidi = false;

        STATE.tracks.forEach(track => {
            if (track.type === 'midi') {
                track.clips.forEach(clip => {
                    // ç¡®ä¿æœ‰éŸ³ç¬¦æ•°æ®
                    if (clip.data && clip.data.notes && clip.data.notes.length > 0) {
                        hasMidi = true;

                        // éå†è¯¥ Clip å†…çš„æ‰€æœ‰éŸ³ç¬¦
                        clip.data.notes.forEach(note => {
                            // ğŸ”¥ å…³é”®ï¼šè®¡ç®—ç»å¯¹æ—¶é—´
                            // Note.time æ˜¯ç›¸å¯¹äº Clip å¼€å§‹çš„ï¼Œæ‰€ä»¥è¦åŠ ä¸Š Clip.startTime
                            const absTime = clip.startTime + note.time;

                            if (absTime < earliestMidiTime) {
                                earliestMidiTime = absTime;
                            }
                        });
                    }
                });
            }
        });

        // 3. æ ¡éªŒæ¡ä»¶
        if (!hasMidi || !audioTrack) {
            // åªæœ‰æ‰‹åŠ¨ç‚¹å‡»æŒ‰é’®æ—¶æ‰å¼¹çª—è­¦å‘Š
            if (!isAuto) {
                alert("æ— æ³•å¯¹é½ï¼šéœ€è¦è‡³å°‘ä¸€ä¸ª MIDI è½¨é“ï¼ˆå«éŸ³ç¬¦ï¼‰å’Œä¸€ä¸ª Audio è½¨é“ï¼");
            }
            return;
        }

        console.log(`å…¨å±€æœ€æ—© MIDI éŸ³ç¬¦æ—¶é—´: ${earliestMidiTime.toFixed(3)}s`);

        const audioClip = audioTrack.clips[0];

        // 4. åˆ†æ Audio çš„ç¬¬ä¸€ä¸ªå‘å£°ç‚¹ (é™éŸ³æ£€æµ‹)
        const audioBuffer = audioClip.data;
        const rawData = audioBuffer.getChannelData(0); // å–å·¦å£°é“
        const sampleRate = audioBuffer.sampleRate;

        let firstSampleIndex = 0;
        const threshold = 0.015; // é™éŸ³é˜ˆå€¼

        for (let i = 0; i < rawData.length; i++) {
            if (Math.abs(rawData[i]) > threshold) {
                firstSampleIndex = i;
                break;
            }
        }

        // éŸ³é¢‘å†…éƒ¨çš„é™éŸ³æ—¶é•¿ï¼ˆç©ºç™½å¤´ï¼‰
        const audioSilenceDuration = firstSampleIndex / sampleRate;

        // 5. è®¡ç®—æ–°ä½ç½®
        // å…¬å¼ï¼šAudioæ–°èµ·ç‚¹ = MIDIæœ€æ—©æ—¶é—´ - Audioç©ºç™½å¤´æ—¶é•¿
        let newStartTime = earliestMidiTime - audioSilenceDuration;

        console.log(`Audio ç©ºç™½å¤´: ${audioSilenceDuration.toFixed(3)}s`);
        console.log(`Audio ç§»åŠ¨: ${audioClip.startTime.toFixed(3)}s -> ${newStartTime.toFixed(3)}s`);

        // 6. è®°å½•å†å² (Undo)
        if (Math.abs(audioClip.startTime - newStartTime) > 0.001) {
            HistoryMgr.add({
                type: 'move_clip',
                clip: audioClip,
                oldStart: audioClip.startTime,
                newStart: newStartTime
            });

            // 7. åº”ç”¨ä½ç½®
            audioClip.startTime = newStartTime;
            audioClip.updateDOMPosition();
            audioClip.update3DPosition();
            updateTotalDuration();

            // è·³è½¬è¿‡å»æŸ¥çœ‹
            seekTo(Math.max(0, newStartTime));
        } else {
            if(!isAuto) console.log("æ— éœ€å¯¹é½ï¼Œä½ç½®æœªå˜");
        }
    }

    function updateTotalDuration() {
        // 1. åˆå§‹åŒ–ä¸º 0 (æˆ–è€…ç»™ä¸€ä¸ªå¾ˆå°çš„é»˜è®¤å€¼ï¼Œæ¯”å¦‚ 4å°èŠ‚/8ç§’ï¼Œä»¥é˜²ç©ºå·¥ç¨‹å¤ªéš¾çœ‹)
        let maxTime = 0;

        // 2. éå†æ‰€æœ‰ Clip æ‰¾åˆ°æœ€æ™šç»“æŸçš„æ—¶é—´ç‚¹
        if (STATE.clips.length > 0) {
            STATE.clips.forEach(c => {
                const end = c.startTime + c.duration;
                if (end > maxTime) maxTime = end;
            });

            // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šåªåœ¨æœ«å°¾å¢åŠ å°‘é‡ç¼“å†² (ä¾‹å¦‚ 1 ä¸ªå°èŠ‚çš„æ—¶é—´ï¼Œæˆ–å›ºå®š 2 ç§’)
            // è¿™æ ·æ—¢ä¸ä¼šé¡¶æ ¼å¤ªéš¾å—ï¼Œä¹Ÿä¸ä¼šç•™å‡ºå¤§ç‰‡ç©ºç™½
            const bufferSeconds = (60 / STATE.bpm) * 4; // è‡ªåŠ¨ç•™ 1 ä¸ªå°èŠ‚çš„ç¼“å†²
            maxTime += bufferSeconds;
        } else {
            // å¦‚æœæ²¡æœ‰ä»»ä½• Clipï¼Œä¿æŒä¸€ä¸ªé»˜è®¤é•¿åº¦ (ä¾‹å¦‚ 10ç§’)
            maxTime = 10;
        }

        STATE.totalDuration = maxTime;

        // 3. æ ¹æ®å†…å®¹æ›´æ–°å®¹å™¨å®½åº¦
        const contentWidth = (maxTime * STATE.pxPerSec) + 20; // +100px é˜²æ­¢å³ä¾§æº¢å‡º

        // è¿™æ˜¯ä¸€ä¸ªå®‰å…¨æ£€æŸ¥ï¼Œé˜²æ­¢å®½åº¦è¿‡å°å¯¼è‡´å¸ƒå±€å´©å
        const minWidth = DOM.timelineLanes.clientWidth;
        const finalWidth = Math.max(minWidth, contentWidth);

        DOM.lanes.style.minWidth = finalWidth + 'px';
        DOM.lanes.style.width = finalWidth + 'px';
        DOM.grid.style.width = finalWidth + 'px';

        // æ ‡å°ºå®½åº¦ç•¥å®½ä¸€ç‚¹
        const rulerCompensatedWidth = finalWidth + 10;
        DOM.barRuler.style.width = rulerCompensatedWidth + 'px';
        DOM.timeRuler.style.width = rulerCompensatedWidth + 'px';

        renderRulers();
    }

    // --- æ’­æ”¾æ§åˆ¶ ---
    function togglePlay() {
        if (STATE.isPlaying) {
            STATE.isPlaying = false;
            DOM.audio.pause();
            DOM.playBtn.innerText = "PLAY (Space)";
            DOM.playBtn.classList.remove('btn-primary'); // å»æ‰é«˜äº®
        } else {
            STATE.isPlaying = true;
            STATE.lastFrameTime = performance.now();
            DOM.playBtn.innerText = "PAUSE (Space)";
            DOM.playBtn.classList.add('btn-primary');

            // å°è¯•æ’­æ”¾éŸ³é¢‘
            syncAudio();
        }
    }

    function stopPlay() {
        STATE.isPlaying = false;
        DOM.audio.pause();
        DOM.playBtn.innerText = "PLAY (Space)";
        DOM.playBtn.classList.remove('btn-primary');
        seekTo(0);
    }



    function seekTo(time) {
        if (!camera || !controls) return;
        STATE.currentTime = Math.max(0, Math.min(time, STATE.totalDuration));
        updatePlayhead();

        // 3D ç›¸æœºç¬ç§»
        const targetX = STATE.currentTime * STATE.playbackSpeed;
        const delta = targetX - cameraTargetX;
        camera.position.x += delta;
        controls.target.x = targetX;
        cameraTargetX = targetX;

        // å¦‚æœæ­£åœ¨æ’­æ”¾ï¼ŒåŒæ­¥éŸ³é¢‘
        if (STATE.isPlaying) {
            syncAudio();
        }
    }

    // æ ¸å¿ƒéŸ³é¢‘åŒæ­¥é€»è¾‘
    function syncAudio() {
        if (!STATE.activeAudioClip) return;
        const clip = STATE.activeAudioClip;
        const visualRelativeTime = STATE.currentTime - clip.startTime;
        const realAudioTime = visualRelativeTime + (clip.trimOffset || 0);
        if (visualRelativeTime >= 0 && visualRelativeTime < clip.duration) {
            if (DOM.audio.paused || Math.abs(DOM.audio.currentTime - realAudioTime) > 0.3) {
                DOM.audio.currentTime = realAudioTime;
                DOM.audio.play().catch(e => console.log("Auto-play blocked"));
            }
        } else {
            if (!DOM.audio.paused) DOM.audio.pause();
        }
    }

    function updatePlayhead() {
        // UI æ›´æ–°
        const px = STATE.currentTime * STATE.pxPerSec;

        // 1. ç§»åŠ¨ä¸‹æ–¹è½¨é“çš„æŒ‡é’ˆ (åŸæœ‰)
        DOM.playhead.style.left = px + 'px';

        // 2. ğŸ”¥ æ–°å¢ï¼šç§»åŠ¨æ ‡å°ºä¸Šçš„æŒ‡é’ˆ
        if (DOM.rulerPlayhead) {
            DOM.rulerPlayhead.style.left = px + 'px';
        }

        // è‡ªåŠ¨æ»šåŠ¨ (åŸæœ‰é€»è¾‘ä¿æŒä¸å˜)
        const scrollCenter = DOM.timelineLanes.scrollLeft + (DOM.timelineLanes.clientWidth / 2);
        if (Math.abs(px - scrollCenter) > DOM.timelineLanes.clientWidth / 3) {
            DOM.timelineLanes.scrollLeft = px - 1000;
        }
    }

    function renderRulers() {
        const duration = STATE.totalDuration + (1000 / STATE.pxPerSec); // å¯¹åº”ä¸Šé¢çš„é¢„ç•™ç©ºé—´
        const pxPerSec = STATE.pxPerSec;
        const totalWidth = duration * pxPerSec;

        // è®¾ç½®å®¹å™¨å®½åº¦
        DOM.barRuler.style.width = totalWidth + 'px';
        DOM.timeRuler.style.width = totalWidth + 'px';

        // ==========================================
        // 1. æ™ºèƒ½ç»˜åˆ¶æ—¶é—´è½¨é“ (Time Ruler)
        // ==========================================
        DOM.timeRuler.innerHTML = '';

        // å®šä¹‰æœ€å°æ ‡ç­¾é—´è· (åƒç´ )
        const minTimeLabelDist = 60;

        // åŸºç¡€æ­¥é•¿ç­–ç•¥ (ç§’): 1, 2, 5, 10, 15, 30, 60
        const timeSteps = [1, 2, 5, 10, 15, 30, 60];
        let timeStep = 1;

        // æ‰¾åˆ°åˆé€‚çš„æ­¥é•¿
        for (let step of timeSteps) {
            if (step * pxPerSec >= minTimeLabelDist) {
                timeStep = step;
                break;
            }
        }

        for (let s = 0; s < duration; s += timeStep) {
            const div = document.createElement('div');
            div.className = 'ruler-mark';

            // å¦‚æœæ˜¯æ•´åˆ†é’Ÿï¼Œæˆ–è€…æ ¹æ®æ­¥é•¿åˆ¤æ–­æ˜¯"å¤§åˆ»åº¦"ï¼ŒåŠ ç²—æ˜¾ç¤º
            const isMajor = (s % 60 === 0);
            if (isMajor) div.className += ' major';

            div.style.left = (s * pxPerSec) + 'px';
            div.innerText = formatRulerTime(s);
            DOM.timeRuler.appendChild(div);
        }

        // ==========================================
        // 2. æ™ºèƒ½ç»˜åˆ¶å°èŠ‚è½¨é“ (Bar Ruler)
        // ==========================================
        DOM.barRuler.innerHTML = '';

        const bps = STATE.bpm / 60;
        const secPerBeat = 1 / bps;
        const secPerBar = secPerBeat * STATE.timeSignature;
        const totalBars = Math.ceil(duration / secPerBar);

        // è®¡ç®—å½“å‰ç¼©æ”¾ä¸‹ä¸€å°èŠ‚æœ‰å¤šå®½
        const pxPerBar = secPerBar * pxPerSec;
        const minBarLabelDist = 40; // å°èŠ‚å·æ¯”è¾ƒçŸ­ï¼Œé—´è·å¯ä»¥å°ä¸€ç‚¹

        // åŠ¨æ€è®¡ç®—æ­¥é•¿ (Step): 1 -> 2 -> 4 -> 8 -> 16 ... (2çš„å€æ•°ç¬¦åˆéŸ³ä¹é€»è¾‘)
        let barStep = 1;
        while (pxPerBar * barStep < minBarLabelDist) {
            barStep *= 2;
        }

        for (let b = 0; b < totalBars; b++) {
            const currentBarX = b * secPerBar * pxPerSec;

            // 1. ç»˜åˆ¶å°èŠ‚å· (åªæœ‰ç¬¦åˆæ­¥é•¿çš„æ‰ç»˜åˆ¶æ–‡å­—)
            if (b % barStep === 0) {
                const div = document.createElement('div');
                div.className = 'ruler-mark major';
                div.style.left = currentBarX + 'px';
                div.style.borderLeftColor = '#aaa';
                div.innerText = (b + 1).toString();
                DOM.barRuler.appendChild(div);
            } else if (pxPerBar * barStep > minBarLabelDist * 2) {
                // å¦‚æœç©ºé—´éå¸¸å……è£•ï¼Œä½†åˆæ²¡åˆ° barStepï¼Œå¯ä»¥ç”»ä¸ªæ·¡ä¸€ç‚¹çš„çº¿ä½†ä¸å†™å­— (å¯é€‰)
                // è¿™é‡Œä¸ºäº†ç®€æ´æš‚ä¸ç”»ä¸­é—´çš„ç»†çº¿ï¼Œé¿å…æ··ä¹±
            }

            // 2. ç»˜åˆ¶æ‹å­ç»†åˆ† (Beat Subdivisions)
            // åªæœ‰å½“"ä¸€å°èŠ‚"éå¸¸å®½ï¼ˆæ¯”å¦‚å¤§äº 150pxï¼‰æ—¶ï¼Œæ‰æ˜¾ç¤ºæ‹å­åˆ»åº¦
            if (pxPerBar >= 150) {
                for(let beat = 1; beat < STATE.timeSignature; beat++) {
                    const beatDiv = document.createElement('div');
                    beatDiv.className = 'ruler-mark';
                    // è®¡ç®—ä½ç½®
                    beatDiv.style.left = (currentBarX + (beat * secPerBeat * pxPerSec)) + 'px';
                    beatDiv.style.height = '5px'; // çŸ­çº¿
                    beatDiv.style.top = '15px';   // é ä¸‹
                    beatDiv.style.borderLeft = '1px solid #444';
                    DOM.barRuler.appendChild(beatDiv);
                }
            }
        }
    }

    // è¾…åŠ©æ ¼å¼åŒ–æ—¶é—´ 0:05
    function formatRulerTime(seconds) {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, '0')}`;
    }

    // --- å®æ—¶ HUD æ›´æ–°é€»è¾‘ (Spherical ç‰ˆ) ---
    const HUD = {
        zoom: document.getElementById('hud-radius'), // å¯¹åº” HTML é‡Œçš„ id
        theta: document.getElementById('hud-theta'),
        phi: document.getElementById('hud-phi'),
        panX: document.getElementById('hud-pan-x'),
        panY: document.getElementById('hud-pan-y'),
        frameCounter: 0
    };

    function updateRealtimeHUD() {
        HUD.frameCounter++;
        if (HUD.frameCounter % 3 !== 0) return;

        // ç›´æ¥å¤ç”¨ ViewMgr çš„è®¡ç®—é€»è¾‘ï¼Œç¡®ä¿æ•°æ® 100% ä¸€è‡´
        const s = ViewMgr.getCurrentSpherical();
        if (!s) return;

        // 1. è·ç¦»
        HUD.zoom.innerText = s.radius.toFixed(1);

        // 2. è§’åº¦ (å·²ç»æ˜¯ä¿®æ­£è¿‡çš„: å¹³è§†=0)
        HUD.theta.innerText = Math.round(s.theta) + "Â°";
        HUD.phi.innerText = Math.round(s.phi) + "Â°";

        // 3. å¹³ç§»
        HUD.panX.innerText = s.targetX.toFixed(1);
        HUD.panY.innerText = s.targetY.toFixed(1);
    }

    // ==========================================
    // 5. åŠ¨ç”»å¾ªç¯
    // ==========================================
    // ==========================================
    // 5. åŠ¨ç”»å¾ªç¯ (å·²ä¿®å¤å½•åˆ¶å¡é¡¿é—®é¢˜)
    // ==========================================
    function animate() {
        requestAnimationFrame(animate);

        const now = performance.now();
        // å¦‚æœæ˜¯ç¬¬ä¸€å¸§ï¼Œåˆå§‹åŒ– lastFrameTime
        if (!STATE.lastFrameTime) STATE.lastFrameTime = now;

        // 1. è®¡ç®—è¿™ä¸€å¸§è·ç¦»ä¸Šä¸€å¸§çš„æ—¶é—´å·® (ç§’)
        let delta = (now - STATE.lastFrameTime) / 1000;

        // 2. æ›´æ–°æ—¶é—´æˆ³ (ä¾›ä¸‹ä¸€å¸§ä½¿ç”¨)
        STATE.lastFrameTime = now;

        // 3. å®‰å…¨é’³åˆ¶ï¼šéå½•åˆ¶çŠ¶æ€ä¸‹ï¼Œå¦‚æœå¡é¡¿è¶…è¿‡0.5ç§’ï¼Œä¿®æ­£ä¸ºä¸€å¸§çš„æ—¶é—´ï¼Œé˜²æ­¢åˆ‡å±å›æ¥åç”»é¢ç¬ç§»
        if (!ExportMgr.isRecording && delta > 0.5) delta = 0.016;

        // --- æ˜Ÿç©ºæ—‹è½¬ (å§‹ç»ˆè½¬åŠ¨) ---
        if (starMesh){
            starMesh.rotation.y += 0.0002;
            starMesh.rotation.x += 0.000005;
        }

        if (STATE.isPlaying) {
            // ğŸ”¥ã€æ ¸å¿ƒä¿®å¤ã€‘å½•åˆ¶æ—¶å¼ºåˆ¶ä½¿ç”¨å›ºå®šå¸§ç‡ (Fixed Time Step)
            // è¿™è§£å†³äº†ä¸¤ä¸ªé—®é¢˜ï¼š
            // 1. ä¿®å¤äº† delta ä¸º 0 å¯¼è‡´è¿›åº¦æ¡å¡ä½çš„é—®é¢˜ã€‚
            // 2. å³ä½¿æ¸²æŸ“æ…¢ï¼Œå¯¼å‡ºçš„è§†é¢‘ä¹Ÿèƒ½ä¿æŒå®Œç¾çš„ 60FPSï¼Œä¸ä¼šæ‰å¸§ã€‚
            if (ExportMgr.isRecording) {
                const fpsVal = document.getElementById('exportFps') ? parseInt(document.getElementById('exportFps').value) : 60;
                delta = 1.0 / fpsVal;
            }

            // --- æ—¶é—´ç´¯åŠ é€»è¾‘ ---

            // æƒ…å†µ A: æ­£å¸¸æ’­æ”¾ä¸”æœ‰éŸ³é¢‘ -> è§†è§‰å¯¹é½éŸ³é¢‘ (Sync to Audio)
            if (!ExportMgr.isRecording && !DOM.audio.paused && STATE.activeAudioClip) {
                const clip = STATE.activeAudioClip;
                // è®¡ç®—éŸ³é¢‘å½“å‰çš„çœŸå®æ’­æ”¾æ—¶é—´å¯¹åº”çš„å·¥ç¨‹æ—¶é—´
                const rawVisualTime = DOM.audio.currentTime - (clip.trimOffset || 0);
                const audioBasedTime = rawVisualTime + clip.startTime;

                const timeDiff = Math.abs(STATE.currentTime - audioBasedTime);

                // å¦‚æœè¯¯å·®å¤ªå¤§(>0.5s)ï¼Œç›´æ¥ç¬ç§»çº æ­£ï¼›å¦åˆ™å¹³æ»‘æ’å€¼çº æ­£
                if (timeDiff > 0.5) {
                    STATE.currentTime = audioBasedTime;
                } else {
                    STATE.currentTime = THREE.MathUtils.lerp(STATE.currentTime, audioBasedTime, 0.5);
                }
            }
            // æƒ…å†µ B: å½•åˆ¶æ¨¡å¼ æˆ– çº¯MIDIæ— éŸ³é¢‘ -> ä½¿ç”¨æ•°å­¦ç´¯åŠ  (Sync to Delta)
            else {
                STATE.currentTime += delta;
            }

            // æ›´æ–° UI æŒ‡é’ˆä½ç½®
            updatePlayhead();

            // æ£€æŸ¥éŸ³é¢‘åŒæ­¥ (è´Ÿè´£å¯åŠ¨/åœæ­¢/è·³è½¬éŸ³é¢‘)
            syncAudio();

            // ç§»åŠ¨ 3D ç›¸æœº
            const targetX = STATE.currentTime * STATE.playbackSpeed;
            const camMove = targetX - cameraTargetX;
            camera.position.x += camMove;
            controls.target.x += camMove;
            cameraTargetX = targetX;
        }

        // --- Shader Uniforms æ›´æ–° ---
        const playheadX = STATE.currentTime * STATE.playbackSpeed;
        STATE.clips.forEach(clip => {
            // å…¼å®¹ InstancedMesh (clip.mesh) æˆ– Group (clip.mesh.children)
            const targets = [];
            if (clip.mesh) {
                if (clip.mesh.material) targets.push(clip.mesh); // InstancedMesh
                else if (clip.mesh.children) targets.push(...clip.mesh.children); // Group
            }

            targets.forEach(meshChild => {
                if (meshChild.material && meshChild.material.uniforms) {
                    if (meshChild.material.uniforms.uPlayheadX) {
                        meshChild.material.uniforms.uPlayheadX.value = playheadX;
                    }
                }
            });
        });

        controls.update();
        updateRealtimeHUD();
        ViewMgr.updateLiveUI();

        // --- èƒŒæ™¯æ¸²æŸ“ (å«æ¨¡ç³Šé€»è¾‘) ---
        if (bgMesh && bgMesh.visible && bgTexture) {
            let blurAmount = BG_STATE.blur;

            if (blurAmount > 0) {
                // åŠ¨æ€è°ƒæ•´æ¨¡ç³Šç”»è´¨ä»¥ä¿è¯æ€§èƒ½
                if (ExportMgr.isRecording) {
                    // å½•åˆ¶æ—¶ï¼šå¦‚æœè¿™ä¸€å¸§æ¸²æŸ“å¤ªæ…¢ (>40ms)ï¼Œç¨å¾®é™ä½æ¨¡ç³Šé‡‡æ ·ç‡é˜²æ­¢å´©æºƒ
                    if (delta > 0.04) {
                        ExportMgr.blurThrottle = Math.max(0.0, ExportMgr.blurThrottle - 0.01);
                    }
                } else {
                    // å¹³æ—¶ï¼šç”»è´¨ä¼˜å…ˆ
                    ExportMgr.blurThrottle = Math.min(1.0, ExportMgr.blurThrottle + 0.05);
                }

                const effectiveBlur = blurAmount * ExportMgr.blurThrottle;

                // Pass 1: æ¨ªå‘æ¨¡ç³Š
                blurMesh.material = blurMatX;
                blurMatX.uniforms.tMap.value = bgTexture;
                blurMatX.uniforms.uBlur.value = effectiveBlur;
                renderer.setRenderTarget(blurRtX);
                renderer.render(blurScene, blurCamera);

                // Pass 2: çºµå‘æ¨¡ç³Š
                blurMesh.material = blurMatY;
                blurMatY.uniforms.tMap.value = blurRtX.texture;
                blurMatY.uniforms.uBlur.value = effectiveBlur;
                renderer.setRenderTarget(blurRtY);
                renderer.render(blurScene, blurCamera);

                // Final: ä¸Šå±
                renderer.setRenderTarget(null);
                bgMaterial.uniforms.tMap.value = blurRtY.texture;
            } else {
                bgMaterial.uniforms.tMap.value = bgTexture;
            }
        }

        renderer.render(scene, camera);

        // --- å½•åˆ¶å¸§æ•è· ---
        if (ExportMgr.isRecording && ExportMgr.videoTrack) {
            // å‘Šè¯‰æµè§ˆå™¨ï¼š"è¿™ä¸€å¸§ç”»å¥½äº†ï¼Œç«‹åˆ»æŠŠå®ƒé€åˆ°å½•åˆ¶å™¨é‡Œ"
            ExportMgr.videoTrack.requestFrame();
        }
    }

    const ExportMgr = {
        modal: document.getElementById('export-modal'),
        statusEl: document.getElementById('recording-status'),
        recTimeEl: document.getElementById('rec-time'),
        recTotalEl: document.getElementById('rec-total'),

        mediaRecorder: null,
        isRecording: false,
        blurThrottle: 1.0,

        // ğŸ”¥ æ–°å¢ï¼šæµå¼å†™å…¥ç›¸å…³çš„å¥æŸ„
        fileHandle: null,
        writableStream: null,
        isStreamMode: false, // æ ‡è®°æ˜¯å¦æ”¯æŒæµå¼å†™å…¥

        // å¤‡ç”¨æ–¹æ¡ˆçš„å†…å­˜æ•°ç»„ï¼ˆä»…å½“ä¸æ”¯æŒæµå¼å†™å…¥æ—¶ä½¿ç”¨ï¼‰
        chunks: [],

        originalSize: { width: 0, height: 0 },
        audioContext: null,
        destNode: null,
        sourceNode: null,

        init() {
            // 1. å¡«å……æ ¼å¼é€‰é¡¹
            const formatSel = document.getElementById('exportFormat');
            const types = [
                'video/mp4',
                'video/webm;codecs=vp9',
                'video/webm;codecs=vp8',
                'video/webm',
            ];
            types.forEach(type => {
                if (MediaRecorder.isTypeSupported(type)) {
                    const opt = document.createElement('option');
                    opt.value = type;
                    opt.innerText = type;
                    formatSel.appendChild(opt);
                }
            });

            // 2. ç»‘å®šæŒ‰é’®
            document.getElementById('showExportBtn').addEventListener('click', () => {
                // ğŸ”¥ ä¿®æ”¹ç‚¹ï¼šå¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œåªæš‚åœ (togglePlay)ï¼Œä¸è¦åœæ­¢ (stopPlay)
                // stopPlay() ä¼šå¼ºåˆ¶ seekTo(0)ï¼Œå¯¼è‡´è¿›åº¦ä¸¢å¤±
                if (STATE.isPlaying) {
                    togglePlay();
                }
                this.modal.style.display = 'flex';
            });

            document.getElementById('cancelExportBtn').addEventListener('click', () => {
                this.modal.style.display = 'none';
            });

            document.getElementById('startExportBtn').addEventListener('click', () => {
                this.startRecording();
            });

            document.getElementById('stopRecBtn').addEventListener('click', () => {
                this.stopRecording();
            });
        },

        async startRecording() {
            // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ 1: å…ˆç«‹ flagï¼Œé˜²æ­¢ CSS å˜åŠ¨è§¦å‘ onResize æ£ä¹± ğŸ”¥ğŸ”¥ğŸ”¥
            this.isRecording = true;
            this.statusEl.style.display = 'flex';

            this.modal.style.display = 'none';

            // è‡ªåŠ¨å›æ»šé€»è¾‘
            if (STATE.currentTime >= STATE.totalDuration - 0.5) {
                seekTo(0);
            }

            this.wasBgVisible = bgMesh ? bgMesh.visible : false;
            this.forcedBgVisible = false;

            const isStarfieldOn = document.getElementById('starfieldToggle').checked;

            if (!currentBgType && isStarfieldOn && bgMesh && bgMaterial) {
                if (window.starfieldBgTexture) {
                    bgMaterial.uniforms.tMap.value = window.starfieldBgTexture;
                }
                bgMaterial.uniforms.uOpacity.value = 1.0;
                bgMaterial.uniforms.uBrightness.value = 0.0;
                bgMaterial.uniforms.uContrast.value = 1.0;
                BG_STATE.fit = 'cover';
                updateBackgroundUV();
                bgMesh.visible = true;
                this.forcedBgVisible = true;
            }
            else if (bgMesh && this.wasBgVisible) {
                bgMesh.visible = true;
            }

            // è·å–å¯¼å‡ºå‚æ•°
            const ratio = parseFloat(document.getElementById('exportRatio').value);
            const resolutionP = parseInt(document.getElementById('exportRes').value);
            const fps = parseInt(document.getElementById('exportFps').value);
            const mimeType = document.getElementById('exportFormat').value;

            let width, height;
            if (ratio >= 1) {
                height = resolutionP;
                width = Math.round(height * ratio);
            } else {
                width = resolutionP;
                height = Math.round(width / ratio);
            }
            width = width % 2 === 0 ? width : width + 1;
            height = height % 2 === 0 ? height : height + 1;

            // --- æµå¼å†™å…¥åˆå§‹åŒ– ---
            this.isStreamMode = false;
            this.fileHandle = null;
            this.writableStream = null;
            this.chunks = [];

            if (window.showSaveFilePicker) {
                try {
                    const isMp4 = mimeType.includes('mp4');
                    const ext = isMp4 ? '.mp4' : '.webm';
                    this.fileHandle = await window.showSaveFilePicker({
                        suggestedName: `SeeMusic_${new Date().getTime()}${ext}`,
                        types: [{
                            description: 'Video File',
                            accept: isMp4 ? {'video/mp4': ['.mp4']} : {'video/webm': ['.webm']}
                        }],
                    });
                    this.writableStream = await this.fileHandle.createWritable();
                    this.isStreamMode = true;
                } catch (err) {
                    if (err.name === 'AbortError') {
                        this.cleanup(); // å¦‚æœå–æ¶ˆä¿å­˜ï¼Œè®°å¾—æ¸…ç†çŠ¶æ€
                        this.isRecording = false; // å¤ä½æ ‡è®°
                        return;
                    }
                    console.warn("æ— æ³•å»ºç«‹æ–‡ä»¶æµï¼Œé™çº§ä¸ºå†…å­˜æ¨¡å¼:", err);
                }
            }

            // --- è®¾ç½®åœºæ™¯å‚æ•° ---
            const canvas = renderer.domElement;
            this.originalSize.width = canvas.width;
            this.originalSize.height = canvas.height;
            this.originalPixelRatio = renderer.getPixelRatio();

            renderer.setClearColor(0x000000, 1.0);

            // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ 2: å¼ºåˆ¶ 1.0 åƒç´ æ¯”ï¼Œç¡®ä¿ 1080p å°±æ˜¯ 1080p ğŸ”¥ğŸ”¥ğŸ”¥
            renderer.setPixelRatio(1.0);
            renderer.setSize(width, height);

            // æ¨¡ç³Šç³»ç»Ÿç¼©æ”¾ (é…åˆä¹‹å‰å»ºè®®çš„ BLUR_SCALE ä½¿ç”¨ï¼Œå»ºè®®è®¾ä¸º 0.5)
            // ç¡®ä¿ä½ å·²ç»å®šä¹‰äº†å…¨å±€çš„ BLUR_SCALE (åœ¨ä»£ç é¡¶éƒ¨)
            const bScale = (typeof BLUR_SCALE !== 'undefined') ? BLUR_SCALE : 0.5;

            if (blurRtX) blurRtX.setSize(width * bScale, height * bScale);
            if (blurRtY) blurRtY.setSize(width * bScale, height * bScale);
            if (blurMatX) blurMatX.uniforms.uResolution.value.set(width * bScale, height * bScale);
            if (blurMatY) blurMatY.uniforms.uResolution.value.set(width * bScale, height * bScale);

            // é”å®š CSS æ ·å¼ (è¿™å¯èƒ½ä¼šè§¦å‘ resizeï¼Œä½†å› ä¸º isRecording=trueï¼Œä¼šè¢« onResize æ‹¦æˆª)
            document.getElementById('canvas-wrapper').classList.add('recording-mode');

            camera.aspect = ratio;
            camera.updateProjectionMatrix();
            updateBackgroundSize();
            updateBackgroundUV();

            // --- éŸ³é¢‘èŠ‚ç‚¹ ---
            if (!this.audioContext) this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (this.audioContext.state === 'suspended') await this.audioContext.resume();

            if (!this.sourceNode && DOM.audio) {
                try {
                    this.sourceNode = this.audioContext.createMediaElementSource(DOM.audio);
                    this.sourceNode.connect(this.audioContext.destination);
                } catch (e) { console.warn(e); }
            }

            if (this.sourceNode) {
                if (this.destNode) {
                    try { this.sourceNode.disconnect(this.destNode); } catch(e) {}
                }
                this.destNode = this.audioContext.createMediaStreamDestination();
                this.sourceNode.connect(this.destNode);
            }

            // --- å¼€å§‹å½•åˆ¶ ---
            const canvasStream = canvas.captureStream(0); // 0 = æ‰‹åŠ¨é©±åŠ¨
            this.videoTrack = canvasStream.getVideoTracks()[0];
            const tracks = [...canvasStream.getVideoTracks()];

            if (this.destNode) tracks.push(...this.destNode.stream.getAudioTracks());

            const combinedStream = new MediaStream(tracks);

            // æé«˜ç ç‡ä¸Šé™
            const bitrate = resolutionP > 1080 ? 40000000 : 12000000;
            const options = {
                mimeType: mimeType,
                videoBitsPerSecond: bitrate,
                // ğŸ”¥ æ–°å¢ï¼šæ˜ç¡®æŒ‡å®šéŸ³é¢‘æ¯”ç‰¹ç‡ï¼ˆå»ºè®® 128kbps æˆ–æ›´é«˜ï¼‰
                audioBitsPerSecond: 256000
            };

            try {
                this.mediaRecorder = new MediaRecorder(combinedStream, options);
            } catch (e) {
                this.mediaRecorder = new MediaRecorder(combinedStream);
            }

            this.mediaRecorder.ondataavailable = async (e) => {
                if (e.data && e.data.size > 0) {
                    if (this.isStreamMode && this.writableStream) {
                        try {
                            await this.writableStream.write(e.data);
                        } catch (err) {
                            console.error("å†™å…¥å¤±è´¥:", err);
                            this.stopRecording();
                        }
                    } else {
                        this.chunks.push(e.data);
                    }
                }
            };

            this.mediaRecorder.onstop = async () => {
                if (this.isStreamMode && this.writableStream) {
                    await this.writableStream.close();
                    this.fileHandle = null;
                    this.writableStream = null;
                    alert("è§†é¢‘å·²ä¿å­˜ï¼");
                } else {
                    const blob = new Blob(this.chunks, { type: this.mediaRecorder.mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = `SeeMusic_Export_${new Date().getTime()}.webm`;
                    document.body.appendChild(a);
                    a.click();
                    setTimeout(() => {
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                        this.chunks = [];
                    }, 100);
                }
                this.cleanup();
            };

            this.recTotalEl.innerText = formatTime(STATE.totalDuration);
            this.mediaRecorder.start(1000);

            if (!STATE.isPlaying) togglePlay();

            this.checkInterval = setInterval(() => {
                this.recTimeEl.innerText = formatTime(STATE.currentTime);
                if (STATE.currentTime >= STATE.totalDuration) {
                    this.stopRecording();
                }
            }, 500);
        },

        stopRecording() {
            if (!this.isRecording) return;
            this.isRecording = false;

            this.blurThrottle = 1.0;

            if (STATE.isPlaying) togglePlay();

            if(this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                this.mediaRecorder.stop();
                this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
            clearInterval(this.checkInterval);
        },

        cleanup() {
            this.statusEl.style.display = 'none';
            document.getElementById('canvas-wrapper').classList.remove('recording-mode');

            renderer.setPixelRatio(this.originalPixelRatio || window.devicePixelRatio);

            renderer.setClearColor(0x0b0c15, 0);

            if (this.forcedBgVisible) {
                // å¦‚æœæ˜¯æˆ‘ä»¬åˆšæ‰å¼ºè¡Œæ‰“å¼€çš„ï¼Œç°åœ¨å…³æ‰å®ƒ
                if (bgMesh) bgMesh.visible = false;
                this.forcedBgVisible = false;
            } else {
                // å¦åˆ™æ¢å¤ä¹‹å‰çš„çŠ¶æ€
                if (bgMesh) bgMesh.visible = this.wasBgVisible;
            }

            const wrapper = document.getElementById('canvas-wrapper');
            renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);

            camera.aspect = wrapper.clientWidth / wrapper.clientHeight;
            camera.updateProjectionMatrix();
            updateBackgroundSize();
            updateBackgroundUV();
            const starToggle = document.getElementById('starfieldToggle');
            if (starToggle && starToggle.checked && !currentBgType) {
                setStarfieldState(true);
            }
            renderer.render(scene, camera);
        }
    };

    // ==========================================
    // 6. å·¥ç¨‹ç®¡ç† (Save / Load / Undo)
    // ==========================================
    const ProjectMgr = {
        // ğŸ”¥ æ–°å¢ï¼šç”¨äºå­˜å‚¨å½“å‰æ‰“å¼€æ–‡ä»¶çš„å¥æŸ„
        currentFileHandle: null,

        init() {
            // ç‚¹å‡»ä¿å­˜æŒ‰é’® (é»˜è®¤ä¸ºå¦å­˜ä¸ºï¼Œä½†å¦‚æœå·²æœ‰å¥æŸ„åˆ™è¯¢é—®æˆ–è¦†ç›–ï¼Œè¿™é‡Œä¿ç•™åŸé€»è¾‘ä¸ºå¦å­˜ä¸ºï¼Œæˆ–è€…ä½ å¯ä»¥æ”¹ä¸ºè°ƒç”¨ quickSave)
            // å»ºè®®ï¼šç‚¹å‡»å·¥å…·æ çš„â€œä¿å­˜å·¥ç¨‹â€æŒ‰é’®æ‰§è¡Œ QuickSaveï¼ˆå¦‚æœæœ‰æ–‡ä»¶ï¼‰ï¼Œå¦åˆ™æ‰§è¡Œ SaveAs
            document.getElementById('saveProjectBtn').addEventListener('click', () => {
                this.quickSave();
            });

            // ğŸ”¥ ä¿®æ”¹è¯»å–æŒ‰é’®é€»è¾‘ï¼šä¼˜å…ˆä½¿ç”¨ showOpenFilePicker ä»¥è·å–å¥æŸ„
            document.getElementById('loadProjectBtn').addEventListener('click', async () => {
                if (window.showOpenFilePicker) {
                    try {
                        const [handle] = await window.showOpenFilePicker({
                            types: [{
                                description: 'SeeMusic Project File',
                                accept: { 'application/json': ['.json'] }
                            }],
                            multiple: false
                        });

                        // è·å–æ–‡ä»¶å¹¶åŠ è½½
                        const file = await handle.getFile();
                        this.currentFileHandle = handle; // ğŸ”¥ å…³é”®ï¼šä¿å­˜å¥æŸ„
                        this.loadProject(file);
                    } catch (err) {
                        // ç”¨æˆ·å–æ¶ˆæˆ–ä¸æ”¯æŒï¼Œå¿½ç•¥
                        if (err.name !== 'AbortError') console.error(err);
                    }
                } else {
                    // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨æ—§çš„ input æ–¹å¼ (ä¸æ”¯æŒè¦†ç›–ä¿å­˜)
                    document.getElementById('projectInput').click();
                }
            });

            // æ–‡ä»¶å˜æ›´ç›‘å¬ (é™çº§æ–¹æ¡ˆ)
            document.getElementById('projectInput').addEventListener('change', (e) => {
                this.currentFileHandle = null; // input æ–¹å¼æ— æ³•è·å–å†™æƒé™ï¼Œé‡ç½®å¥æŸ„
                this.loadProject(e.target.files[0]);
                e.target.value = '';
            });
        },

        getCurrentState() {
            // è·å–è§†è§’
            const currentViewParams = ViewMgr.getCurrentSpherical();

            // è·å–ç¼–ç»„ (Set è½¬ Array)
            const serializedGroups = {};
            for (const key in STATE.groups) {
                const group = STATE.groups[key];
                serializedGroups[key] = {
                    ...group,
                    trackIds: Array.from(group.trackIds)
                };
            }

            // è¿”å›å®Œæ•´çš„å·¥ç¨‹å¯¹è±¡
            return {
                version: "1.2",
                timestamp: new Date().toISOString(),
                settings: {
                    duration: STATE.totalDuration,
                    pxPerSec: STATE.pxPerSec,
                    playbackSpeed: STATE.playbackSpeed,
                    noteThickness: STATE.noteThickness,
                    noteHeightScale: STATE.noteHeightScale,

                    // âœ…ã€ä¿®å¤é‡ç‚¹ã€‘å¦‚æœ DOM å…ƒç´ ä¸å­˜åœ¨ï¼Œç›´æ¥ç”¨ STATE å˜é‡
                    sceneZoom: DOM.sceneZoom ? parseInt(DOM.sceneZoom.value) : STATE.playbackSpeed,
                    timelineZoom: STATE.pxPerSec, // âœ… ä¸å†è¯»å– DOM.timelineZoom.value

                    zSeparation: STATE.zSeparation,
                    noteShape: STATE.noteShape,
                    cameraView: currentViewParams,
                    starfieldVisible: document.getElementById('starfieldToggle') ? document.getElementById('starfieldToggle').checked : true
                },
                background: {
                    params: BG_STATE,
                    type: currentBgType,
                    data: storedBgBase64ForSave
                },
                groups: serializedGroups,
                tracks: STATE.tracks.map(t => ({
                    id: t.id,
                    name: t.name,
                    type: t.type,
                    ownColor: t.ownColor,
                    groupId: t.groupId,
                    isMuted: t.isMuted,
                    isSoloed: t.isSoloed,
                    clips: t.clips.map(c => ({
                        start: c.startTime,
                        duration: c.duration,
                        name: c.name,
                        sourceData: c.sourceFile
                    }))
                }))
            };
        },

        // ğŸ”¥ æ–°å¢ï¼šæ™ºèƒ½ä¿å­˜ (Quick Save / Ctrl+S)
        async quickSave() {
            // 1. å¦‚æœæœ‰å¥æŸ„ï¼Œç›´æ¥å†™å…¥åŸæ–‡ä»¶
            if (this.currentFileHandle) {
                try {
                    const project = this.getCurrentState();
                    const jsonStr = JSON.stringify(project);

                    // åˆ›å»ºå¯å†™æµ
                    const writable = await this.currentFileHandle.createWritable();
                    await writable.write(jsonStr);
                    await writable.close();

                    // ç®€å•çš„è§†è§‰åé¦ˆ
                    const btn = document.getElementById('saveProjectBtn');
                    const originalText = btn.innerText;
                    btn.innerText = "å·²ä¿å­˜!";
                    setTimeout(() => btn.innerText = originalText, 1500);
                    console.log("å·¥ç¨‹å·²ä¿å­˜åˆ°åŸæ–‡ä»¶");
                    return;
                } catch (err) {
                    console.warn("å†™å…¥åŸæ–‡ä»¶å¤±è´¥ï¼Œè½¬ä¸ºå¦å­˜ä¸º:", err);
                    // å¦‚æœå†™å…¥å¤±è´¥ï¼ˆä¾‹å¦‚æƒé™ä¸¢å¤±ï¼‰ï¼Œè½¬ä¸º Save As
                }
            }

            // 2. å¦‚æœæ²¡æœ‰å¥æŸ„ï¼Œæ‰§è¡Œâ€œå¦å­˜ä¸ºâ€
            const defaultName = `SeeMusic_Project_${new Date().toLocaleDateString().replace(/\//g, '-')}`;
            this.executeSave(defaultName);
        },

        // å¦å­˜ä¸º (Save As)
        async executeSave(fileName) {
            const project = this.getCurrentState();
            const jsonStr = JSON.stringify(project);

            if (window.showSaveFilePicker) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: `${fileName}.json`,
                        types: [{
                            description: 'SeeMusic Project File',
                            accept: { 'application/json': ['.json'] },
                        }],
                    });

                    // ğŸ”¥ å…³é”®ï¼šå¦å­˜ä¸ºæˆåŠŸåï¼Œæ›´æ–°å½“å‰å¥æŸ„
                    this.currentFileHandle = handle;

                    const writable = await handle.createWritable();
                    await writable.write(jsonStr);
                    await writable.close();
                    return;
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error('Save File Error:', err);
                        alert("ä¿å­˜å¤±è´¥ï¼Œè½¬ä¸ºè‡ªåŠ¨ä¸‹è½½...");
                    } else {
                        return;
                    }
                }
            }

            // å¤‡ç”¨æ–¹æ¡ˆï¼šè‡ªåŠ¨ä¸‹è½½ (æ— æ³•æ›´æ–°å¥æŸ„)
            const blob = new Blob([jsonStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${fileName}.json`;
            a.click();
            URL.revokeObjectURL(url);
        },

        async restoreState(json) {
            // å…ˆæ¸…ç©ºå½“å‰æ‰€æœ‰å†…å®¹
            this.clearAll();

            // 1. æ¢å¤å…¨å±€è®¾ç½®
            if (json.settings) {
                STATE.pxPerSec = json.settings.pxPerSec || 50;
                STATE.playbackSpeed = json.settings.playbackSpeed || 20;
                STATE.noteThickness = json.settings.noteThickness || 1.0;
                STATE.noteHeightScale = json.settings.noteHeightScale || 1.5;
                STATE.zSeparation = (json.settings.zSeparation !== undefined) ? json.settings.zSeparation : 0.3;

                if (json.settings.noteShape) {
                    STATE.noteShape = json.settings.noteShape;
                    const shapeSel = document.getElementById('noteShapeSelect');
                    if (shapeSel) shapeSel.value = STATE.noteShape;
                }

                if(DOM.timelineZoom) DOM.timelineZoom.value = STATE.pxPerSec;
                if(DOM.sceneZoom) DOM.sceneZoom.value = STATE.playbackSpeed;

                const thickSlider = document.getElementById('thicknessSlider');
                if(thickSlider) thickSlider.value = STATE.noteThickness * 100;

                const heightSlider = document.getElementById('heightSlider');
                if(heightSlider) heightSlider.value = STATE.noteHeightScale * 100;

                const zSlider = document.getElementById('zSpaceSlider');
                if(zSlider) zSlider.value = STATE.zSeparation * 10;

                if (json.settings.cameraView) {
                    ViewMgr.restore(json.settings.cameraView);
                }
                const starVisible = (json.settings.starfieldVisible !== undefined)
                    ? json.settings.starfieldVisible
                    : true;

                // è°ƒç”¨å…¨å±€å‡½æ•°è®¾ç½®çŠ¶æ€ (å®ƒä¼šè‡ªåŠ¨å¤„ç† checkbox å’Œ 3D åœºæ™¯)
                setStarfieldState(starVisible);
            }

            // 2. æ¢å¤èƒŒæ™¯
            if (json.background) {
                if (json.background.params) {
                    Object.assign(BG_STATE, json.background.params);
                    updateBgUI();
                    if (bgMaterial) {
                        bgMaterial.uniforms.uOpacity.value = BG_STATE.opacity;
                        bgMaterial.uniforms.uBrightness.value = (BG_STATE.brightness - 100) / 100;
                        bgMaterial.uniforms.uContrast.value = BG_STATE.contrast / 100;
                    }
                }
                if (json.background.data && json.background.type) {
                    currentBgBase64 = json.background.data;
                    currentBgType = json.background.type;
                    storedBgBase64ForSave = json.background.data;
                    applyBackgroundSource(currentBgBase64, currentBgType);
                }
            } else {
                if (bgMesh) bgMesh.visible = false;
                if (bgVideoElement) {
                    bgVideoElement.pause();
                    bgVideoElement = null;
                }
                currentBgBase64 = null;
                storedBgBase64ForSave = null;
            }

            // 3. æ¢å¤ç¼–ç»„ (Group)
            if (json.groups) {
                STATE.groups = json.groups;
                let maxId = 0;
                for (const gid in STATE.groups) {
                    const g = STATE.groups[gid];
                    if(g.id > maxId) maxId = g.id;

                    // ğŸ”¥ å…³é”®ä¿®å¤ 2ï¼šé˜²æ­¢è¯»å–æ—§åæ¡£æ—¶æŠ¥é”™
                    // å¦‚æœæ˜¯æ•°ç»„(æ–°ç‰ˆæ­£å¸¸æ¡£)ï¼Œç›´æ¥ç”¨ï¼›å¦‚æœæ˜¯å¯¹è±¡{}(æ—§ç‰ˆåæ¡£)æˆ–undefinedï¼Œç”¨ç©ºæ•°ç»„ä»£æ›¿
                    const ids = Array.isArray(g.trackIds) ? g.trackIds : [];
                    g.trackIds = new Set(ids);
                }
                STATE.nextGroupId = maxId + 1;
            }

            // 4. æ¢å¤è½¨é“ (Tracks)
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            let maxTrackId = 0;

            for (const tData of json.tracks) {
                const track = new Track(tData.name, tData.type);
                track.id = tData.id;
                if (track.id > maxTrackId) maxTrackId = track.id;

                if (track.laneEl) track.laneEl.id = `lane-${track.id}`;
                const groupInd = track.headerEl.querySelector('.group-indicator');
                if (groupInd) groupInd.id = `group-ind-${track.id}`;

                track.ownColor = tData.ownColor;

                // æ¢å¤ç¼–ç»„å…³è”
                if (tData.groupId && STATE.groups[tData.groupId]) {
                    track.groupId = tData.groupId;
                    // ç¡®ä¿æ˜¯ Set å†æ·»åŠ  (ä¸Šé¢ä¿®å¤åè¿™é‡Œä¸€å®šæ˜¯ Set)
                    if (STATE.groups[tData.groupId].trackIds instanceof Set) {
                        STATE.groups[tData.groupId].trackIds.add(track.id);
                    }
                } else {
                    track.groupId = null;
                }

                STATE.tracks.push(track);

                const colorInput = track.headerEl.querySelector('.track-color-picker');
                if(colorInput) colorInput.value = tData.ownColor;

                for (const cData of tData.clips) {
                    let processedData = null;
                    if (tData.type === 'midi') {
                        processedData = cData.sourceData;
                    } else if (tData.type === 'audio') {
                        try {
                            const res = await fetch(cData.sourceData);
                            const ab = await res.arrayBuffer();
                            processedData = await audioCtx.decodeAudioData(ab);
                        } catch (err) { console.error("éŸ³é¢‘æ¢å¤å¤±è´¥", err); }
                    }

                    if (processedData) {
                        track.addClip(cData.start, cData.duration, processedData, cData.name, cData.sourceData);
                    }
                }

                track.setMute(tData.isMuted || false);
                track.setSolo(tData.isSoloed || false);
                track.refreshColor();
            }

            STATE.nextTrackId = maxTrackId + 1;

            updateTrackZRanks();

            updateTotalDuration();
            autoFitZoom(STATE.totalDuration);

            // å¦‚æœæœ‰éŸ³é¢‘ï¼Œæ¢å¤æ’­æ”¾å™¨
            const firstAudioClip = STATE.clips.find(c => c.track.type === 'audio');
            if (firstAudioClip) {
                STATE.activeAudioClip = firstAudioClip;
                DOM.audio.src = firstAudioClip.sourceFile;
            }

            console.log("å·¥ç¨‹å·²æ¢å¤ï¼ŒåŒ…å«è§†è§’å‚æ•°ã€‚");
        },

        // ç”¨äº Undo åˆ é™¤çš„æ¢å¤é€»è¾‘ (ä¿æŒä¸å˜)
        async restoreSingleTrack(tData, insertIndex) {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const track = new Track(tData.name, tData.type);

            track.id = tData.id;
            if (track.laneEl) track.laneEl.id = `lane-${track.id}`;
            const groupInd = track.headerEl.querySelector('.group-indicator');
            if (groupInd) groupInd.id = `group-ind-${track.id}`;

            track.ownColor = tData.ownColor;
            track.groupId = tData.groupId;

            const colorInput = track.headerEl.querySelector('.track-color-picker');
            if(colorInput) colorInput.value = tData.ownColor;

            STATE.tracks.splice(insertIndex, 0, track);
            DOM.headers.appendChild(track.headerEl);
            DOM.lanes.appendChild(track.laneEl);

            for (const cData of tData.clips) {
                let processedData = null;
                if (tData.type === 'midi') {
                    processedData = cData.sourceData;
                } else if (tData.type === 'audio') {
                    try {
                        const res = await fetch(cData.sourceData);
                        const ab = await res.arrayBuffer();
                        processedData = await audioCtx.decodeAudioData(ab);
                    } catch (err) { console.error(err); }
                }

                if (processedData) {
                    track.addClip(cData.start, cData.duration, processedData, cData.name, cData.sourceData);
                }
            }

            if (track.type === 'audio' && track.clips.length > 0) {
                const clip = track.clips[0];
                STATE.activeAudioClip = clip;
                DOM.audio.src = clip.sourceFile;
                DOM.audio.load();
                if (STATE.currentTime > 0) {
                    DOM.audio.currentTime = STATE.currentTime - clip.startTime;
                }
            }

            track.refreshColor();
            updateGridBackground();
            updateTotalDuration();
            STATE.clips.forEach(c => c.updateDOMPosition());
        },

        loadProject(file) {
            if (!file) return;
            DOM.loading.style.display = 'flex';

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const json = JSON.parse(e.target.result);
                    const oldProjectState = this.getCurrentState();
                    await this.restoreState(json);

                    HistoryMgr.add({
                        type: 'load_project',
                        oldProject: oldProjectState, // å­˜å…¥æ—§ç‰ˆæ‰€æœ‰æ•°æ®
                        newProject: json             // å­˜å…¥æ–°ç‰ˆæ‰€æœ‰æ•°æ®
                    });

                    requestAnimationFrame(() => {
                        window.dispatchEvent(new Event('resize'));
                    });
                } catch (err) {
                    console.error(err);
                    alert("å·¥ç¨‹æ–‡ä»¶æŸåæˆ–æ ¼å¼é”™è¯¯");
                }
                DOM.loading.style.display = 'none';
            };
            reader.readAsText(file);
        },

        clearAll() {
            stopPlay();
            STATE.clips.forEach(c => c.destroy());
            STATE.tracks.forEach(t => {
                if(t.headerEl) t.headerEl.remove();
                if(t.laneEl) t.laneEl.remove();
            });
            STATE.tracks = [];
            STATE.clips = [];
            STATE.groups = {};
            STATE.selectedTrackIds.clear();
            STATE.nextTrackId = 1;
            STATE.nextGroupId = 1;

            DOM.headers.innerHTML = '';
            DOM.lanes.innerHTML = `
                <div class="grid-lines" id="gridLines"></div>
                <div id="ui-playhead"></div>
            `;
            DOM.grid = document.getElementById('gridLines');
            DOM.playhead = document.getElementById('ui-playhead');
            updateGridBackground();

            // é‡ç½®è§†è§’åˆ°é»˜è®¤
            ViewMgr.reset();
        }
    };

    // ç®€å•çš„ç§’è½¬ mm:ss æ ¼å¼åŒ–å‡½æ•°
    function formatTime(seconds) {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }

    // åœ¨åˆå§‹åŒ–é‡Œå¯åŠ¨
    ExportMgr.init();

    // ğŸ”¥ å¯åŠ¨å·¥ç¨‹ç®¡ç†å™¨
    ProjectMgr.init();

    // å¯åŠ¨
    initController();
    window.addEventListener('beforeunload', () => {
        // 1. åœæ­¢åŠ¨ç”»å¾ªç¯
        STATE.isPlaying = false;

        // å¦‚æœä½ æœ‰ä¿å­˜ animationIdï¼Œæœ€å¥½åœ¨è¿™é‡Œ cancelAnimationFrame(id)
        // ä½†ç”±äºä½ çš„ animate æ˜¯é€’å½’è°ƒç”¨çš„ï¼Œè®¾ç½® isPlaying = false
        // é…åˆä¸‹é¢çš„å¼ºåˆ¶ç½®ç©ºï¼Œé€šå¸¸è¶³å¤Ÿæ‰“æ–­å¾ªç¯

        // 2. åœæ­¢å¹¶é‡Šæ”¾éŸ³é¢‘ä¸Šä¸‹æ–‡
        if (DOM.audio) {
            DOM.audio.pause();
            DOM.audio.src = "";
        }
        if (sharedAudioCtx) {
            sharedAudioCtx.close().catch(e => {});
            sharedAudioCtx = null;
        }

        // 3. å¼ºåˆ¶æ¸…ç©ºå†å²è®°å½•æ ˆ (é‡Šæ”¾å·¨å¤§çš„ Base64 å­—ç¬¦ä¸²)
        HistoryMgr.undoStack = [];
        HistoryMgr.redoStack = [];

        // 4. é‡Šæ”¾ Three.js èµ„æº (æ˜¾å­˜)
        if (renderer) {
            renderer.dispose();
            renderer.forceContextLoss(); // å¼ºåˆ¶ä¸¢å¤± WebGL ä¸Šä¸‹æ–‡
            renderer.domElement = null;
        }

        if (scene) {
            scene.traverse(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(m => m.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });
        }

        // 5. é‡Šæ”¾å¤§å˜é‡
        currentBgBase64 = null;
        STATE.tracks = [];
        STATE.clips = [];
    });

    init3D();
    initDragAndDrop();
    initResizeHandle();
    if (document.getElementById('starfieldToggle').checked) {
        // ç¨å¾®å»¶è¿Ÿä¸€ç‚¹ç‚¹ï¼Œç¡®ä¿ init3D ä¸­çš„æè´¨å’Œçº¹ç†éƒ½å‡†å¤‡å¥½äº†
        setTimeout(() => {
            setStarfieldState(true);
        }, 100);
    }
    setTimeout(() => {
        window.dispatchEvent(new Event('resize'));
    }, 100);

</script>
</body>
</html>